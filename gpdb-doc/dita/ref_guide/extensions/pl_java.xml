<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE topic
  PUBLIC "-//OASIS//DTD DITA Composite//EN" "ditabase.dtd">
<topic id="topic1" xml:lang="en">
  <title id="pv161085">PL/Java Language</title>
  <body>
    <p>This section contains an overview of the Greenplum Database PL/Java language.</p>
    <ul>
      <li id="pv161174">
        <xref href="#topic2" type="topic" format="dita"/>
      </li>
      <li id="pv161261">
        <xref href="#topic10" type="topic" format="dita"/>
      </li>
      <li><xref href="#topic_qx1_xcp_w3b" format="dita"/></li>
      <li id="pv161280" otherprops="pivotal">
        <xref href="#topic4" type="topic" format="dita"/>
      </li>
      <li otherprops="pivotal">
        <xref href="#topic6" format="dita"/></li>
      <li otherprops="pivotal">
        <xref href="#topic7" format="dita"/></li>
      <li id="pv161254">
        <xref href="#topic13" type="topic" format="dita"/>
      </li>
      <li id="pv165944">
        <xref href="#topic24" type="topic" format="dita"/>
      </li>
      <li id="pv165963">
        <xref href="#topic25" type="topic" format="dita"/>
      </li>
      <li id="pv165978">
        <xref href="#topic26" type="topic" format="dita"/>
      </li>
      <li id="pv165997">
        <xref href="#topic27" type="topic" format="dita"/>
      </li>
      <li id="pv166027">
        <xref href="#topic28" type="topic" format="dita"/>
      </li>
      <li id="pv166042">
        <xref href="#topic33" type="topic" format="dita"/>
      </li>
      <li id="pv161247">
        <xref href="#topic40" type="topic" format="dita"/>
      </li>
      <li id="pv161240">
        <xref href="#topic41" type="topic" format="dita"/>
      </li>
    </ul>
  </body>
  <topic id="topic2" xml:lang="en">
    <title id="pv161093">About PL/Java </title>
    <body>
      <p>With the Greenplum Database PL/Java extension, you can write Java methods using your
        favorite Java IDE and install the JAR files that contain those methods into Greenplum
        Database. </p>
      <p>Greenplum Database PL/Java package is based on the open source PL/Java 1.5.0. Greenplum
        Database PL/Java provides the following features.</p>
      <ul>
        <li id="pv161029">Ability to execute PL/Java functions with Java 8 or Java 11.</li>
        <li>Ability to specify Java runtime.</li>
        <li id="pv161030">Standardized utilities (modeled after the SQL 2003 proposal) to install
          and maintain Java code in the database.</li>
        <li id="pv161031">Standardized mappings of parameters and result. Complex types as well as
          sets are supported.</li>
        <li id="pv161032">An embedded, high performance, JDBC driver utilizing the internal
          Greenplum Database SPI routines.</li>
        <li id="pv161033">Metadata support for the JDBC driver. Both
            <codeph>DatabaseMetaData</codeph> and <codeph>ResultSetMetaData</codeph> are
          included.</li>
        <li id="pv161034">The ability to return a ResultSet from a query as an alternative to
          building a ResultSet row by row.</li>
        <li id="pv161035">Full support for savepoints and exception handling.</li>
        <li id="pv161036">The ability to use IN, INOUT, and OUT parameters. </li>
        <li id="pv161037">Two separate Greenplum Database languages:<ul id="ul_rl4_vc5_lv">
            <li>pljava, TRUSTED PL/Java language</li>
            <li>pljavau, UNTRUSTED PL/Java language</li>
          </ul></li>
        <li id="pv161038">Transaction and Savepoint listeners enabling code execution when a
          transaction or savepoint is committed or rolled back.</li>
        <li id="pv161039">Integration with GNU GCJ on selected platforms.</li>
      </ul>
      <p>A function in SQL will appoint a static method in a Java class. In order for the function
        to execute, the appointed class must available on the class path specified by the Greenplum
        Database server configuration parameter <codeph>pljava_classpath</codeph>. The PL/Java
        extension adds a set of functions that helps installing and maintaining the java classes.
        Classes are stored in normal Java archives, JAR files. A JAR file can optionally contain a
        deployment descriptor that in turn contains SQL commands to be executed when the JAR is
        deployed or undeployed. The functions are modeled after the standards proposed for SQL
        2003.</p>
      <p>PL/Java implements a standardized way of passing parameters and return values. Complex
        types and sets are passed using the standard JDBC ResultSet class. </p>
      <p>A JDBC driver is included in PL/Java. This driver calls Greenplum Database internal SPI
        routines. The driver is essential since it is common for functions to make calls back to the
        database to fetch data. When PL/Java functions fetch data, they must use the same
        transactional boundaries that are used by the main function that entered PL/Java execution
        context.</p>
      <p>PL/Java is optimized for performance. The Java virtual machine executes within the same
        process as the backend to minimize call overhead. PL/Java is designed with the objective to
        enable the power of Java to the database itself so that database intensive business logic
        can execute as close to the actual data as possible.</p>
      <p>The standard Java Native Interface (JNI) is used when bridging calls between the backend
        and the Java VM.</p>
    </body>
  </topic>
  <topic id="topic10" xml:lang="en">
    <title id="pv159836">About Greenplum Database PL/Java</title>
    <body>
      <p>There are a few key differences between the implementation of PL/Java in standard
        PostgreSQL and Greenplum Database.</p>
    </body>
    <topic id="topic11" xml:lang="en">
      <title>Functions</title>
      <body>
        <p>The following functions are not supported in Greenplum Database. The classpath is handled
          differently in a distributed Greenplum Database environment than in the PostgreSQL environment.<sl>
            <sli><codeph>sqlj.install_jar</codeph>
            </sli>
            <sli><codeph>sqlj.replace_jar</codeph>
            </sli>
            <sli><codeph>sqlj.remove_jar</codeph></sli>
            <sli><codeph>sqlj.get_classpath</codeph></sli>
            <sli><codeph>sqlj.set_classpath</codeph></sli>
          </sl></p>
        <p> Greenplum Database uses the <codeph>pljava_classpath</codeph> server configuration
          parameter in place of the <codeph>sqlj.set_classpath</codeph> function. </p>
      </body>
    </topic>
    <topic id="topic12" xml:lang="en">
      <title>Server Configuration Parameters</title>
      <body>
        <p>The following server configuration parameters are used by PL/Java in Greenplum Database.
          These parameters replace the <codeph>pljava.*</codeph> parameters that are used in the
          standard PostgreSQL PL/Java implementation:</p>
        <ul id="ul_ksz_5r5_b1b">
          <li id="pv159849">
            <codeph>pljava_classpath</codeph>
            <p>A colon (<codeph>:</codeph>) separated list of the jar files containing the Java
              classes used in any PL/Java functions. The jar files must be installed in the same
              locations on all Greenplum Database hosts. With the trusted PL/Java language handler,
              jar file paths must be relative to the <codeph>$GPHOME/lib/postgresql/java/</codeph>
              directory. With the untrusted language handler (javaU language tag), paths may be
              relative to <codeph>$GPHOME/lib/postgresql/java/</codeph> or absolute. </p><p>The
              server configuration parameter <codeph>pljava_classpath_insecure</codeph> controls
              whether the server configuration parameter <codeph>pljava_classpath</codeph> can be
              set by a user without Greenplum Database superuser privileges. When
                <codeph>pljava_classpath_insecure</codeph> is enabled, Greenplum Database developers
              who are working on PL/Java functions do not have to be database superusers to change
                <codeph>pljava_classpath</codeph>.</p>
            <note type="warning">Enabling <codeph>pljava_classpath_insecure</codeph> exposes a
              security risk by giving non-administrator database users the ability to run
              unauthorized Java methods.</note></li>
          <li id="pv159853">
            <codeph>pljava_statement_cache_size</codeph>
            <p>Sets the size in KB of the Most Recently Used (MRU) cache for prepared statements.
            </p></li>
          <li id="pv159856">
            <codeph>pljava_release_lingering_savepoints</codeph>
            <p>If <codeph>TRUE</codeph>, lingering savepoints will be released on function exit. If
                <codeph>FALSE</codeph>, they will be rolled back. </p></li>
          <li id="pv159859">
            <codeph>pljava_vmoptions</codeph>
            <p>Defines the start up options for the Greenplum Database Java VM. </p></li>
        </ul>
        <p>See the <cite>Greenplum Database Reference Guide</cite> for information about the
          Greenplum Database server configuration parameters.</p>
      </body>
    </topic>
  </topic>
  <topic id="topic_qx1_xcp_w3b">
    <title>Installing Java</title>
    <body>
      <p>PL/Java requires a Java runtime environment on each Greenplum Database host. Ensure that
        the same Java environment is at the same location on all hosts: masters and segments. The
        command <codeph>java -version</codeph> displays the Java version.</p>
      <p>The commands that you use to install Java depend on the host system operating system and
        Java version. This list describes how to install OpenJDK 8 or 11 (Java 8 JDK or Java 11 JDK)
        on RHEL/CentOS or Ubuntu.<ul id="ul_cld_gdp_w3b">
          <li>RHEL 7/CentOS 7 - This <codeph>yum</codeph> command installs OpenJDK 8 or
              11.<codeblock>$ sudo yum install java-&lt;<varname>version</varname>>-openjdk-devel</codeblock><p>For
              OpenJDK 8 the <varname>version</varname> is <codeph>1.8.0</codeph>, for OpenJDK 11 the
                <varname>version</varname> is <codeph>11</codeph>.</p></li>
          <li>RHEL 6/CentOS 6<ul id="ul_wqf_4p4_w3b">
              <li>Java 8 - This <codeph>yum</codeph> command installs OpenJDK
                8.<codeblock>$ sudo yum install java-1.8.0-openjdk-devel</codeblock></li>
              <li> Java 11 - Download the OpenJDK 11 tar file from <xref
                  href="http://jdk.java.net/archive/" format="html" scope="external"
                  >http://jdk.java.net/archive/</xref> and install and configure the operating
                system to use Java 11. <p>
                  <ol id="ol_k2l_ys5_w3b">
                    <li>This example <codeph>tar</codeph> command installs the OpenJDK 11 in
                        <codeph>/usr/lib/jvm</codeph>.<codeblock>$ sudo tar xzf openjdk-11.0.2_linux-x64_bin.tar.gz --directory /usr/lib/jvm</codeblock></li>
                    <li>Run these two commands to add OpenJDK 11 to the
                        <codeph>update-alternatives</codeph> command. The
                        <codeph>update-alternatives</codeph>command maintains symbolic links that
                      determine the default version of operating system
                        commands.<codeblock>$ sudo sh -c 'for bin in /usr/lib/jvm/jdk-11.0.2/bin/*; do update-alternatives --install /usr/bin/$(basename $bin) $(basename $bin) $bin 100; done'
$ sudo sh -c 'for bin in /usr/lib/jvm/jdk-11.0.2/bin/*; do update-alternatives --set $(basename $bin) $bin; done'</codeblock><p>The
                        second command returns some <codeph>failed to read link</codeph> errors that
                        can be ignored.</p></li>
                  </ol>
                </p></li>
            </ul></li>
          <li>Ubuntu - These <codeph>apt</codeph> commands install OpenJDK 8 or
              11.<codeblock>$ sudo apt update
$ sudo apt install openjdk-&lt;<varname>version</varname>>-jdk</codeblock><p>For
              OpenJDK 8 the <varname>version</varname> is <codeph>8</codeph>, for OpenJDK 11 the
                <varname>version</varname> is <codeph>11</codeph>.</p></li>
        </ul></p>
      <p>After installing OpenJDK on a RHEL or CentOS system, run this
          <codeph>update-alternatives</codeph> command to change the default Java. Enter the number
        that represents the OpenJDK version to use as the
        default.<codeblock>$ sudo update-alternatives --config java </codeblock></p>
      <p>The <codeph>update-alternatives</codeph> command is not required on Ubuntu systems.</p>
      <note>When configuring host systems, you can use the <codeph><xref
            href="../../utility_guide/ref/gpssh.xml"/></codeph> utility to run bash
        shell commands on multiple remote hosts.</note>
    </body>
  </topic>
  <topic id="topic4" xml:lang="en" otherprops="pivotal">
    <title id="pv158223">Installing PL/Java</title>
    <body>
      <p>For Greenplum Database, the PL/Java extension is available as a package. Download the
        package from the Greenplum Database page on <xref
          href="https://network.pivotal.io/products/pivotal-gpdb" scope="external" format="html"
          class="- topic/xref ">Pivotal Network</xref> and then install it with the Greenplum
        Package Manager (<codeph>gppkg</codeph>). </p>
      <p>The <xref href="../../utility_guide/ref/gppkg.xml"/> utility installs Greenplum
        Database extensions, along with any dependencies, on all hosts across a cluster. It also
        automatically installs extensions on new hosts in the case of system expansion and segment
        recovery.</p>
      <p>To install and use PL/Java:</p>
      <ol>
        <li>Specify the Java version used by PL/Java. Set the environment variables
            <codeph>JAVA_HOME</codeph> and <codeph>LD_LIBRARY_PATH</codeph> in the
            <codeph>greenplum_path.sh</codeph>.</li>
        <li id="pv158542">Install the Greenplum Database PL/Java extension. </li>
        <li id="pv158366">Enable the language for each database where you intend to use
          PL/Java.</li>
        <li id="pv158382">Install user-created JAR files containing Java methods into the same
          directory on all Greenplum Database hosts.</li>
        <li id="pv158391">Add the name of the JAR file to the Greenplum Database server
          configuration parameter <codeph>pljava_classpath</codeph>. The parameter lists the
          installed JAR files. For information about the parameter, see the <cite>Greenplum Database
            Reference Guide</cite>.</li>
      </ol>
    </body>
    <topic id="topic5" xml:lang="en">
      <title>Installing the Greenplum PL/Java Extension</title>
      <body>
        <p>Before you install the PL/Java extension, make sure that your Greenplum database is
          running, you have sourced <codeph>greenplum_path.sh</codeph>, and that the
            <codeph>$MASTER_DATA_DIRECTORY</codeph> and <codeph>$GPHOME</codeph> variables are
          set.</p>
        <ol>
          <li id="pv158485">Download the PL/Java extension package from <xref
              href="https://network.pivotal.io/products/pivotal-gpdb" scope="external" format="html"
              class="- topic/xref ">Pivotal Network</xref> then copy it to the master host. </li>
          <li id="pv160918">Install the software extension package by running the
              <codeph>gppkg</codeph> command. This example installs the PL/Java extension package on
            a Linux
            system:<codeblock>$ gppkg -i pljava-1.4.3-gp5-rhel<varname>osversion</varname>_x86_64.gppkg</codeblock></li>
          <li>Ensure that the environment variables <codeph>JAVA_HOME</codeph> and
              <codeph>LD_LIBRARY_PATH</codeph> are set properly in
              <codeph>$GPHOME/greenplum_path.sh</codeph> on all Greenplum Database hosts.<ul
              id="ul_mgq_wgh_qw">
              <li>Set the <codeph>JAVA_HOME</codeph> variable to the directory where your Java
                Runtime is installed. For example, for Oracle JRE this directory would be
                  <codeph>/usr/java/latest</codeph>. For OpenJDK, the directory is
                  <codeph>/usr/lib/jvm</codeph>. This example changes the environment variable to
                use
                <codeph>/usr/lib/jvm</codeph>.<codeblock>export JAVA_HOME=/usr/lib/jvm</codeblock></li>
              <li>Set the <codeph>LD_LIBRARY_PATH</codeph> to include the directory with the Java
                server runtime libraries. PL/Java depends on <codeph>libjvm.so</codeph> and the
                shared object should be in your <codeph>LD_LIBRARY_PATH</codeph>. By default,
                  <codeph>libjvm.so</codeph> is available in <codeph>$JAVA_HOME/lib/server</codeph>
                with JDK 11, or in <codeph>$JAVA_HOME/jre/lib/amd64/server</codeph> with JDK 8. This
                example adds the JDK 11 directory to the environment
                variable.<codeblock>export LD_LIBRARY_PATH=$GPHOME/lib:$GPHOME/ext/python/lib:<b>$JAVA_HOME/lib/server</b>:$LD_LIBRARY_PATH</codeblock></li>
            </ul>This example <codeph><xref href="../../utility_guide/ref/gpscp.xml"
              /></codeph> command copies the file to all hosts specified in the file
              <codeph>gphosts_file</codeph>.<codeblock>$ gpscp -f gphosts_file $GPHOME/greenplum_path.sh 
=:$GPHOME/greenplum_path.sh</codeblock></li>
          <li dir="ltr">Reload
            <codeph>greenplum_path.sh</codeph>.<codeblock dir="ltr">$ source $GPHOME/greenplum_path.sh</codeblock></li>
          <li id="pv162228">Restart Greenplum Database.<codeblock>$ gpstop -r</codeblock></li>
        </ol>
      </body>
    </topic>
  </topic>
  <topic id="topic6" xml:lang="en">
    <title id="pv161784">Enabling PL/Java and Installing JAR Files</title>
    <body>
      <p>Perform the following steps as the Greenplum Database administrator
          <codeph>gpadmin</codeph>.</p>
      <ol id="ol_dpn_qr5_b1b">
        <li id="pv162268">Enable PL/Java in a database by executing the <codeph>CREATE
            EXTENSION</codeph> command to register the language. For example, this command enables
          PL/Java in the <codeph>testdb</codeph> database:<codeblock>$ psql -d testdb -c 'CREATE EXTENSION pljava;'</codeblock>
          <note>The PL/Java <codeph>install.sql</codeph> script, used in previous releases to
            register the language, is deprecated. Also using the deprecated
              <codeph>createlang</codeph> command to register PL/Java generates an
          error.</note></li>
        <li id="pv160325">Copy your Java archives (JAR files) to the same directory on all Greenplum
          Database hosts. This example uses the Greenplum Database <codeph>gpscp</codeph> utility to
          copy the file <codeph>myclasses.jar</codeph> to the directory
            <codeph>$GPHOME/lib/postgresql/java/</codeph>:<codeblock>$ gpscp -f gphosts_file myclasses.jar 
=:/usr/local/greenplum-db/lib/postgresql/java/</codeblock><p>The
            file <codeph>gphosts_file</codeph> contains a list of the Greenplum Database
          hosts.</p></li>
        <li id="pv160327">Set the <codeph>pljava_classpath</codeph> server configuration parameter
          in the master <codeph>postgresql.conf</codeph> file. For this example, the parameter value
          is a colon (:) separated list of the JAR files. For
            example:<codeblock>$ gpconfig -c pljava_classpath -v 'examples.jar:myclasses.jar'</codeblock><p>The
            file <codeph>examples.jar</codeph> is installed when you install the PL/Java extension
            package with the <codeph>gppkg</codeph> utility.</p>
          <note>If you install JAR files in a directory other than
              <codeph>$GPHOME/lib/postgresql/java/</codeph>, you must specify the absolute path to
            the JAR file. Each JAR file must be in the same location on all Greenplum Database
            hosts. For more information about specifying the location of JAR files, see the
            information about the <codeph>pljava_classpath</codeph> server configuration parameter
            in the <cite>Greenplum Database Reference Guide</cite>.</note></li>
        <li id="pv160329">Reload the <codeph>postgresql.conf</codeph>
          file.<codeblock>$ gpstop -u</codeblock></li>
        <li id="pv160335">(optional) Greenplum provides an <codeph>examples.sql</codeph> file
          containing sample PL/Java functions that you can use for testing. Run the commands in this
          file to create the test functions (which use the Java classes in
            <codeph>examples.jar</codeph>).
          <codeblock>$ psql -f $GPHOME/share/postgresql/pljava/examples.sql</codeblock></li>
      </ol>
    </body>
  </topic>
  <topic id="topic7" xml:lang="en" otherprops="pivotal">
    <title>Uninstalling PL/Java</title>
    <body>
      <ul id="ul_zsz_fs5_b1b">
        <li id="pv165655"><xref href="#topic8" type="topic" format="dita"/>
        </li>
        <li id="pv165686"><xref href="#topic9" type="topic" format="dita"/>
        </li>
      </ul>
    </body>
    <topic id="topic8" xml:lang="en">
      <title id="pv165472">Remove PL/Java Support for a Database</title>
      <body>
        <p>Use the <codeph>DROP EXTENSION</codeph> command to remove support for PL/Java from a
          database. For example, this command disables the PL/Java language in the
            <codeph>testdb</codeph> database: </p>
        <codeblock>$ psql -d testdb -c 'DROP EXTENSION pljava;'</codeblock>
        <p> The default command fails if any existing objects (such as functions) depend on the
          language. Specify the <codeph>CASCADE</codeph> option to also drop all dependent objects,
          including functions that you created with PL/Java. </p>
        <note>The PL/Java <codeph>uninstall.sql</codeph> script, used in previous releases to remove
          the language registration, is deprecated. Also using the deprecated
            <codeph>droplang</codeph> command to remove support for PL/Java generates an
          error.</note>
      </body>
    </topic>
    <topic id="topic9" xml:lang="en">
      <title id="pv165506">Uninstall the Java JAR files and Software Package</title>
      <body>
        <p>If no databases have PL/Java as a registered language, remove the Java JAR files and
          uninstall the Greenplum PL/Java extension with the <codeph>gppkg</codeph> utility. </p>
        <ol id="ol_atz_fs5_b1b">
          <li id="pv165538">Remove the <codeph>pljava_classpath</codeph> server configuration
            parameter from the <codeph>postgresql.conf</codeph> file on all Greenplum Database
            hosts. For example:<codeblock>$ gpconfig -r pljava_classpath</codeblock></li>
          <li id="pv165539">Remove the JAR files from the directories where they were installed on
            all Greenplum Database hosts. For information about JAR file installation directories,
            see <xref href="#topic6" format="dita"/>.</li>
          <li id="pv160641">Use the Greenplum <codeph>gppkg</codeph> utility with the
              <codeph>-r</codeph> option to uninstall the PL/Java extension. This example uninstalls
            the PL/Java extension on a Linux
              system:<codeblock>$ gppkg -r pljava-1.4.3</codeblock><p>You can run the
                <codeph>gppkg</codeph> utility with the options <codeph>-q --all</codeph> to list
              the installed extensions and their versions.</p></li>
          <li>Remove any updates you made to <codeph>greenplum_path.sh</codeph> for PL/Java.</li>
          <li dir="ltr">Reload <codeph>greenplum_path.sh</codeph> and restart the
            database<codeblock dir="ltr">$ source $GPHOME/greenplum_path.sh
$ gpstop -r </codeblock></li>
        </ol>
      </body>
    </topic>
  </topic>
  <topic id="topic13" xml:lang="en">
    <title id="pv158066">Writing PL/Java functions</title>
    <body>
      <p>Information about writing functions with PL/Java.</p>
      <ul>
        <li id="pv164880">
          <xref href="#topic14" type="topic" format="dita"/>
        </li>
        <li id="pv164915">
          <xref href="#topic15" type="topic" format="dita"/>
        </li>
        <li id="pv164922">
          <xref href="#topic16" type="topic" format="dita"/>
        </li>
        <li id="pv164929">
          <xref href="#topic17" type="topic" format="dita"/>
        </li>
        <li id="pv164936">
          <xref href="#topic18" type="topic" format="dita"/>
        </li>
        <li id="pv164947">
          <xref href="#topic18" type="topic" format="dita"/>
        </li>
        <li id="pv164954">
          <xref href="#topic19" type="topic" format="dita"/>
        </li>
        <li id="pv164961">
          <xref href="#topic20" type="topic" format="dita"/>
        </li>
        <li id="pv164995">
          <xref href="#topic21" type="topic" format="dita"/>
        </li>
      </ul>
    </body>
    <topic id="topic14" xml:lang="en">
      <title id="pv164882">SQL Declaration</title>
      <body>
        <p>A Java function is declared with the name of a class and a static method on that class.
          The class will be resolved using the classpath that has been defined for the schema where
          the function is declared. If no classpath has been defined for that schema, the public
          schema is used. If no classpath is found there either, the class is resolved using the
          system classloader.</p>
        <p>The following function can be declared to access the static method
            <codeph>getProperty</codeph> on <codeph>java.lang.System</codeph> class:</p>
        <codeblock>CREATE FUNCTION getsysprop(VARCHAR)
  RETURNS VARCHAR
  AS 'java.lang.System.getProperty'
  LANGUAGE java;</codeblock>
        <p>Run the following command to return the Java <codeph>user.home</codeph> property:</p>
        <codeblock>SELECT getsysprop('user.home');</codeblock>
      </body>
    </topic>
    <topic id="topic15" xml:lang="en">
      <title id="pv157321">Type Mapping</title>
      <body>
        <p>Scalar types are mapped in a straight forward way. This table lists the current mappings. </p>
        <table id="pv157323">
          <title>PL/Java data type mapping</title>
          <tgroup cols="2">
            <colspec colnum="1" colname="col1" colwidth="110pt"/>
            <colspec colnum="2" colname="col2" colwidth="165pt"/>
            <thead>
              <row>
                <entry colname="col1">PostgreSQL</entry>
                <entry colname="col2">Java</entry>
              </row>
            </thead>
            <tbody>
              <row>
                <entry colname="col1">bool</entry>
                <entry colname="col2">boolean</entry>
              </row>
              <row>
                <entry colname="col1">char</entry>
                <entry colname="col2">byte</entry>
              </row>
              <row>
                <entry colname="col1">int2</entry>
                <entry colname="col2">short</entry>
              </row>
              <row>
                <entry colname="col1">int4</entry>
                <entry colname="col2">int</entry>
              </row>
              <row>
                <entry colname="col1">int8</entry>
                <entry colname="col2">long</entry>
              </row>
              <row>
                <entry colname="col1">varchar</entry>
                <entry colname="col2"> java.lang.String</entry>
              </row>
              <row>
                <entry colname="col1">text</entry>
                <entry colname="col2"> java.lang.String</entry>
              </row>
              <row>
                <entry colname="col1">bytea</entry>
                <entry colname="col2">byte[ ]</entry>
              </row>
              <row>
                <entry colname="col1">date</entry>
                <entry colname="col2">java.sql.Date</entry>
              </row>
              <row>
                <entry colname="col1">time</entry>
                <entry colname="col2">java.sql.Time (stored value treated as local time)</entry>
              </row>
              <row>
                <entry colname="col1">timetz</entry>
                <entry colname="col2">java.sql.Time</entry>
              </row>
              <row>
                <entry colname="col1">timestamp</entry>
                <entry colname="col2">java.sql.Timestamp (stored value treated as local
                  time)</entry>
              </row>
              <row>
                <entry colname="col1">timestamptz</entry>
                <entry colname="col2">java.sql.Timestamp</entry>
              </row>
              <row>
                <entry colname="col1">complex</entry>
                <entry colname="col2">java.sql.ResultSet</entry>
              </row>
              <row>
                <entry colname="col1">setof complex</entry>
                <entry colname="col2">java.sql.ResultSet</entry>
              </row>
            </tbody>
          </tgroup>
        </table>
        <p>All other types are mapped to java.lang.String and will utilize the standard
            <codeph>textin</codeph>/<codeph>textout</codeph> routines registered for respective
          type.</p>
      </body>
    </topic>
    <topic id="topic16" xml:lang="en">
      <title id="pv157393">NULL Handling</title>
      <body>
        <p>The scalar types that map to Java primitives can not be passed as <codeph>NULL</codeph>
          values. To pass <codeph>NULL</codeph> values, those types can have an alternative mapping.
          You enable this mapping by explicitly denoting it in the method reference.</p>
        <codeblock>CREATE FUNCTION trueIfEvenOrNull(integer)
  RETURNS bool
  AS 'foo.fee.Fum.trueIfEvenOrNull(java.lang.Integer)'
  LANGUAGE java;</codeblock>
        <p>The Java code would be similar to this:</p>
        <codeblock>package foo.fee;
public class Fum
{
  static boolean trueIfEvenOrNull(Integer value)
  {
    return (value == null)
      ? true
      : (value.intValue() % 2) == 0;
  }
}</codeblock>
        <p>The following two statements both yield true:</p>
        <codeblock>SELECT trueIfEvenOrNull(NULL);
SELECT trueIfEvenOrNull(4);</codeblock>
        <p>In order to return <codeph>NULL</codeph> values from a Java method, you use the object
          type that corresponds to the primitive (for example, you return
            <codeph>java.lang.Integer</codeph> instead of <codeph>int</codeph>). The PL/Java resolve
          mechanism finds the method regardless. Since Java cannot have different return types for
          methods with the same name, this does not introduce any ambiguity.</p>
      </body>
    </topic>
    <topic id="topic17" xml:lang="en">
      <title id="pv157414">Complex Types</title>
      <body>
        <p>A complex type will always be passed as a read-only <codeph>java.sql.ResultSet</codeph>
          with exactly one row. The ResultSet is positioned on its row so a call to
            <codeph>next()</codeph> should not be made. The values of the complex type are retrieved
          using the standard getter methods of the ResultSet.</p>
        <p>Example:</p>
        <codeblock>CREATE TYPE complexTest
  AS(base integer, incbase integer, ctime timestamptz);
CREATE FUNCTION useComplexTest(complexTest)
  RETURNS VARCHAR
  AS 'foo.fee.Fum.useComplexTest'
  IMMUTABLE LANGUAGE java;</codeblock>
        <p>In the Java class <codeph>Fum</codeph>, we add the following static method:</p>
        <codeblock>public static String useComplexTest(ResultSet complexTest)
throws SQLException
{
  int base = complexTest.getInt(1);
  int incbase = complexTest.getInt(2);
  Timestamp ctime = complexTest.getTimestamp(3);
  return "Base = \"" + base +
    "\", incbase = \"" + incbase +
    "\", ctime = \"" + ctime + "\"";
}</codeblock>
      </body>
    </topic>
    <topic id="topic18" xml:lang="en">
      <title id="pv157435">Returning Complex Types</title>
      <body>
        <p>Java does not stipulate any way to create a ResultSet. Hence, returning a ResultSet is
          not an option. The SQL-2003 draft suggests that a complex return value should be handled
          as an IN/OUT parameter. PL/Java implements a ResultSet that way. If you declare a function
          that returns a complex type, you will need to use a Java method with boolean return type
          with a last parameter of type <codeph>java.sql.ResultSet</codeph>. The parameter will be
          initialized to an empty updateable ResultSet that contains exactly one row.</p>
        <p>Assume that the <codeph>complexTest</codeph> type in previous section has been
          created.</p>
        <codeblock>CREATE FUNCTION createComplexTest(int, int)
  RETURNS complexTest
  AS 'foo.fee.Fum.createComplexTest'
  IMMUTABLE LANGUAGE java;</codeblock>
        <p>The PL/Java method resolve will now find the following method in the <codeph>Fum</codeph>
          class:</p>
        <codeblock>public static boolean complexReturn(int base, int increment, 
  ResultSet receiver)
throws SQLException
{
  receiver.updateInt(1, base);
  receiver.updateInt(2, base + increment);
  receiver.updateTimestamp(3, new 
    Timestamp(System.currentTimeMillis()));
  return true;
}</codeblock>
        <p>The return value denotes if the receiver should be considered as a valid tuple (true) or
          NULL (false).</p>
      </body>
    </topic>
    <topic id="topic19" xml:lang="en">
      <title id="pv165879">Functions That Return Sets</title>
      <body>
        <p>When returning result set, you should not build a result set before returning it, because
          building a large result set would consume a large amount of resources. It is better to
          produce one row at a time. Incidentally, that is what the Greenplum Database backend
          expects a function with SETOF return to do. You can return a SETOF a scalar type such as
          an <codeph>int</codeph>, <codeph>float</codeph> or <codeph>varchar</codeph>, or you can
          return a SETOF a complex type. </p>
      </body>
    </topic>
    <topic id="topic20" xml:lang="en">
      <title id="pv157454">Returning a SETOF &lt;scalar type></title>
      <body>
        <p>In order to return a set of a scalar type, you need create a Java method that returns
          something that implements the <codeph>java.util.Iterator</codeph> interface. Here is an
          example of a method that returns a SETOF <codeph>varchar</codeph>:</p>
        <codeblock>CREATE FUNCTION javatest.getSystemProperties()
  RETURNS SETOF varchar
  AS 'foo.fee.Bar.getNames'
  IMMUTABLE LANGUAGE java;</codeblock>
        <p>This simple Java method returns an iterator:</p>
        <codeblock>package foo.fee;
import java.util.Iterator;

public class Bar
{
    public static Iterator getNames()
    {
        ArrayList names = new ArrayList();
        names.add("Lisa");
        names.add("Bob");
        names.add("Bill");
        names.add("Sally");
        return names.iterator();
    }
}</codeblock>
      </body>
    </topic>
    <topic id="topic21" xml:lang="en">
      <title id="pv157476">Returning a SETOF &lt;complex type></title>
      <body>
        <p>A method returning a SETOF &lt;complex type> must use either the interface
            <codeph>org.postgresql.pljava.ResultSetProvider</codeph> or
            <codeph>org.postgresql.pljava.ResultSetHandle</codeph>. The reason for having two
          interfaces is that they cater for optimal handling of two distinct use cases. The former
          is for cases when you want to dynamically create each row that is to be returned from the
          SETOF function. The latter makes is in cases where you want to return the result of an
          executed query. </p>
      </body>
      <topic id="topic22" xml:lang="en">
        <title>Using the ResultSetProvider Interface</title>
        <body>
          <p>This interface has two methods. The boolean <codeph>assignRowValues(java.sql.ResultSet
              tupleBuilder, int rowNumber)</codeph> and the <codeph>void close()</codeph> method.
            The Greenplum Database query evaluator will call the <codeph>assignRowValues</codeph>
            repeatedly until it returns false or until the evaluator decides that it does not need
            any more rows. Then it calls close.</p>
          <p>You can use this interface the following way:</p>
          <codeblock>CREATE FUNCTION javatest.listComplexTests(int, int)
  RETURNS SETOF complexTest
  AS 'foo.fee.Fum.listComplexTest'
  IMMUTABLE LANGUAGE java;</codeblock>
          <p>The function maps to a static java method that returns an instance that implements the
              <codeph>ResultSetProvider</codeph> interface.</p>
          <codeblock>public class Fum implements ResultSetProvider
{
  private final int m_base;
  private final int m_increment;
  public Fum(int base, int increment)
  {
    m_base = base;
    m_increment = increment;
  }
  public boolean assignRowValues(ResultSet receiver, int 
currentRow)
  throws SQLException
  {
    // Stop when we reach 12 rows.
    //
    if(currentRow &gt;= 12)
      return false;
    receiver.updateInt(1, m_base);
    receiver.updateInt(2, m_base + m_increment * currentRow);
    receiver.updateTimestamp(3, new 
Timestamp(System.currentTimeMillis()));
    return true;
  }
  public void close()
  {
   // Nothing needed in this example
  }
  public static ResultSetProvider listComplexTests(int base, 
int increment)
  throws SQLException
  {
    return new Fum(base, increment);
  }
}</codeblock>
          <p>The <codeph>listComplextTests</codeph> method is called once. It may return
              <codeph>NULL</codeph> if no results are available or an instance of the
              <codeph>ResultSetProvider</codeph>. Here the Java class <codeph>Fum</codeph>
            implements this interface so it returns an instance of itself. The method
              <codeph>assignRowValues</codeph> will then be called repeatedly until it returns
            false. At that time, close will be called</p>
        </body>
      </topic>
      <topic id="topic23" xml:lang="en">
        <title>Using the ResultSetHandle Interface</title>
        <body>
          <p>This interface is similar to the <codeph>ResultSetProvider</codeph> interface in that
            it has a <codeph>close()</codeph> method that will be called at the end. But instead of
            having the evaluator call a method that builds one row at a time, this method has a
            method that returns a ResultSet. The query evaluator will iterate over this set and
            deliver the RestulSet contents, one tuple at a time, to the caller until a call to
              <codeph>next()</codeph> returns false or the evaluator decides that no more rows are
            needed.</p>
          <p>Here is an example that executes a query using a statement that it obtained using the
            default connection. The SQL suitable for the deployment descriptor looks like this:</p>
          <codeblock>CREATE FUNCTION javatest.listSupers()
  RETURNS SETOF pg_user
  AS 'org.postgresql.pljava.example.Users.listSupers'
  LANGUAGE java;
CREATE FUNCTION javatest.listNonSupers()
  RETURNS SETOF pg_user
  AS 'org.postgresql.pljava.example.Users.listNonSupers'
  LANGUAGE java;</codeblock>
          <p>And in the Java package <codeph>org.postgresql.pljava.example</codeph> a class
              <codeph>Users</codeph> is added:</p>
          <codeblock>public class Users implements ResultSetHandle
{
  private final String m_filter;
  private Statement m_statement;
  public Users(String filter)
  {
    m_filter = filter;
  }
  public ResultSet getResultSet()
  throws SQLException
  {
    m_statement = 
      DriverManager.getConnection("jdbc:default:connection").cr
eateStatement();
    return m_statement.executeQuery("SELECT * FROM pg_user 
       WHERE " + m_filter);
  }

  public void close()
  throws SQLException
  {
    m_statement.close();
  }

  public static ResultSetHandle listSupers()
  {
    return new Users("usesuper = true");
  }

  public static ResultSetHandle listNonSupers()
  {
    return new Users("usesuper = false");
  }
}</codeblock>
        </body>
      </topic>
    </topic>
  </topic>
  <topic id="topic24" xml:lang="en">
    <title id="pv157564">Using JDBC</title>
    <body>
      <p>PL/Java contains a JDBC driver that maps to the PostgreSQL SPI functions. A connection that
        maps to the current transaction can be obtained using the following statement:</p>
      <codeblock>Connection conn = 
  DriverManager.getConnection("jdbc:default:connection"); </codeblock>
      <p>After obtaining a connection, you can prepare and execute statements similar to other JDBC
        connections. These are limitations for the PL/Java JDBC driver:</p>
      <ul>
        <li id="pv157568">The transaction cannot be managed in any way. Thus, you cannot use methods
          on the connection such as:<ul id="ul_yxm_d3c_lp">
            <li id="pv157569"><codeph>commit()</codeph></li>
            <li id="pv157570"><codeph>rollback()</codeph></li>
            <li id="pv157571"><codeph>setAutoCommit()</codeph></li>
            <li id="pv157572"><codeph>setTransactionIsolation()</codeph></li>
          </ul></li>
        <li id="pv157573">Savepoints are available with some restrictions. A savepoint cannot
          outlive the function in which it was set and it must be rolled back or released by that
          same function.</li>
        <li id="pv157574">A ResultSet returned from <codeph>executeQuery()</codeph> are always
            <codeph>FETCH_FORWARD</codeph> and <codeph>CONCUR_READ_ONLY</codeph>.</li>
        <li id="pv157575">Meta-data is only available in PL/Java 1.1 or higher.</li>
        <li id="pv157576"><codeph>CallableStatement</codeph> (for stored procedures) is not
          implemented.</li>
        <li id="pv157577">The types <codeph>Clob</codeph> or <codeph>Blob</codeph> are not
          completely implemented, they need more work. The types <codeph>byte[]</codeph> and
            <codeph>String</codeph> can be used for <codeph>bytea</codeph> and <codeph>text</codeph>
          respectively.</li>
      </ul>
    </body>
  </topic>
  <topic id="topic25" xml:lang="en">
    <title id="pv157578">Exception Handling</title>
    <body>
      <p>You can catch and handle an exception in the Greenplum Database backend just like any other
        exception. The backend ErrorData structure is exposed as a property in a class called
          <codeph>org.postgresql.pljava.ServerException</codeph> (derived from
          <codeph>java.sql.SQLException</codeph>) and the Java try/catch mechanism is synchronized
        with the backend mechanism.</p>
      <note type="important">You will not be able to continue executing backend functions until your
        function has returned and the error has been propagated when the backend has generated an
        exception unless you have used a savepoint. When a savepoint is rolled back, the exceptional
        condition is reset and you can continue your execution.</note>
    </body>
  </topic>
  <topic id="topic26" xml:lang="en">
    <title id="pv157582">Savepoints</title>
    <body>
      <p>Greenplum Database savepoints are exposed using the java.sql.Connection interface. Two
        restrictions apply.</p>
      <ul>
        <li id="pv157584">A savepoint must be rolled back or released in the function where it was
          set.</li>
        <li id="pv157585">A savepoint must not outlive the function where it was set</li>
      </ul>
    </body>
  </topic>
  <topic id="topic27" xml:lang="en">
    <title id="pv157586">Logging</title>
    <body>
      <p>PL/Java uses the standard Java Logger. Hence, you can write things like:</p>
      <codeblock>Logger.getAnonymousLogger().info( "Time is " + new 
Date(System.currentTimeMillis()));</codeblock>
      <p>At present, the logger uses a handler that maps the current state of the Greenplum Database
        configuration setting <codeph>log_min_messages</codeph> to a valid Logger level and that
        outputs all messages using the Greenplum Database backend function <codeph>elog()</codeph>. </p>
      <note>The <codeph>log_min_messages</codeph> setting is read from the database the first time a
        PL/Java function in a session is executed. On the Java side, the setting does not change
        after the first PL/Java function execution in a specific session until the Greenplum
        Database session that is working with PL/Java is restarted.</note>
      <p>The following mapping apply between the Logger levels and the Greenplum Database backend
        levels.</p>
      <table id="pv157590">
        <title>PL/Java Logging Levels</title>
        <tgroup cols="2">
          <colspec colnum="1" colname="col1" colwidth="131.25pt"/>
          <colspec colnum="2" colname="col2" colwidth="165pt"/>
          <thead>
            <row>
              <entry colname="col1">java.util.logging.Level</entry>
              <entry colname="col2">Greenplum Database Level</entry>
            </row>
          </thead>
          <tbody>
            <row>
              <entry colname="col1">SEVERE ERROR</entry>
              <entry colname="col2">ERROR</entry>
            </row>
            <row>
              <entry colname="col1">WARNING</entry>
              <entry colname="col2">WARNING</entry>
            </row>
            <row>
              <entry colname="col1">CONFIG</entry>
              <entry colname="col2">LOG</entry>
            </row>
            <row>
              <entry colname="col1">INFO</entry>
              <entry colname="col2">INFO</entry>
            </row>
            <row>
              <entry colname="col1">FINE</entry>
              <entry colname="col2">DEBUG1</entry>
            </row>
            <row>
              <entry colname="col1">FINER</entry>
              <entry colname="col2">DEBUG2</entry>
            </row>
            <row>
              <entry colname="col1">FINEST</entry>
              <entry colname="col2">DEBUG3</entry>
            </row>
          </tbody>
        </tgroup>
      </table>
    </body>
  </topic>
  <topic id="topic28" xml:lang="en">
    <title id="pv157624">Security</title>
    <body>
      <ul>
        <li id="pv165238">
          <xref href="#topic29" type="topic" format="dita"/>
        </li>
        <li id="pv165263">
          <xref href="#topic30" type="topic" format="dita"/>
        </li>
      </ul>
    </body>
    <topic id="topic29" xml:lang="en">
      <title id="pv157625">Installation</title>
      <body>
        <p>Only a database superuser can install PL/Java. The PL/Java utility functions are
          installed using SECURITY DEFINER so that they execute with the access permissions that
          where granted to the creator of the functions.</p>
      </body>
    </topic>
    <topic id="topic30" xml:lang="en">
      <title id="pv157627">Trusted Language</title>
      <body>
        <p>PL/Java is a <i>trusted</i> language. The trusted PL/Java language has no access to the
          file system as stipulated by PostgreSQL definition of a trusted language. Any database
          user can create and access functions in a trusted language.</p>
        <p>PL/Java also installs a language handler for the language <codeph>javau</codeph>. This
          version is <i>not trusted</i> and only a superuser can create new functions that use it.
          Any user can call the functions.</p>
      </body>
    </topic>
  </topic>
  <topic id="topic33" xml:lang="en">
    <title id="pv157633">Some PL/Java Issues and Solutions</title>
    <body>
      <p>When writing the PL/Java, mapping the JVM into the same process-space as the Greenplum
        Database backend code, some concerns have been raised regarding multiple threads, exception
        handling, and memory management. Here are brief descriptions explaining how these issues
        where resolved.</p>
      <ul>
        <li id="pv165334">
          <xref href="#topic34" type="topic" format="dita"/>
        </li>
        <li id="pv165352">
          <xref href="#topic36" type="topic" format="dita"/>
        </li>
        <li id="pv165359">
          <xref href="#topic38" type="topic" format="dita"/>
        </li>
      </ul>
    </body>
    <topic id="topic34" xml:lang="en">
      <title id="pv157635">Multi-threading</title>
      <body>
        <p>Java is inherently multi-threaded. The Greenplum Database backend is not. There is
          nothing stopping a developer from utilizing multiple Threads class in the Java code.
          Finalizers that call out to the backend might have been spawned from a background Garbage
          Collection thread. Several third party Java-packages that are likely to be used make use
          of multiple threads. How can this model coexist with the Greenplum Database backend in the
          same process?</p>
      </body>
      <topic id="topic35" xml:lang="en">
        <title>Solution</title>
        <body>
          <p>The solution is simple. PL/Java defines a special object called the
              <codeph>Backend.THREADLOCK</codeph>. When PL/Java is initialized, the backend
            immediately grabs this objects monitor (i.e. it will synchronize on this object). When
            the backend calls a Java function, the monitor is released and then immediately regained
            when the call returns. All calls from Java out to backend code are synchronized on the
            same lock. This ensures that only one thread at a time can call the backend from Java,
            and only at a time when the backend is awaiting the return of a Java function call.</p>
        </body>
      </topic>
    </topic>
    <topic id="topic36" xml:lang="en">
      <title id="pv157639">Exception Handling</title>
      <body>
        <p>Java makes frequent use of try/catch/finally blocks. Greenplum Database sometimes use an
          exception mechanism that calls <codeph>longjmp</codeph> to transfer control to a known
          state. Such a jump would normally effectively bypass the JVM. </p>
      </body>
      <topic id="topic37" xml:lang="en">
        <title>Solution</title>
        <body>
          <p>The backend now allows errors to be caught using the macros
              <codeph>PG_TRY/PG_CATCH</codeph>/<codeph>PG_END_TRY</codeph> and in the catch block,
            the error can be examined using the ErrorData structure. PL/Java implements a
              <codeph>java.sql.SQLException</codeph> subclass called
              <codeph>org.postgresql.pljava.ServerException</codeph>. The ErrorData can be retrieved
            and examined from that exception. A catch handler is allowed to issue a rollback to a
            savepoint. After a successful rollback, execution can continue.</p>
        </body>
      </topic>
    </topic>
    <topic id="topic38" xml:lang="en">
      <title id="pv157643">Java Garbage Collector Versus palloc() and Stack Allocation</title>
      <body>
        <p>Primitive types are always be passed by value. This includes the <codeph>String</codeph>
          type (this is a must since Java uses double byte characters). Complex types are often
          wrapped in Java objects and passed by reference. For example, a Java object can contain a
          pointer to a palloc'ed or stack allocated memory and use native JNI calls to extract and
          manipulate data. Such data will become stale once a call has ended. Further attempts to
          access such data will at best give very unpredictable results but more likely cause a
          memory fault and a crash.</p>
      </body>
      <topic id="topic39" xml:lang="en">
        <title>Solution</title>
        <body>
          <p>The PL/Java contains code that ensures that stale pointers are cleared when the
            MemoryContext or stack where they where allocated goes out of scope. The Java wrapper
            objects might live on but any attempt to use them will result in a stale native handle
            exception.</p>
        </body>
      </topic>
    </topic>
  </topic>
  <topic id="topic40" xml:lang="en">
    <title id="pv158163">Example</title>
    <body>
      <p>The following simple Java example creates a JAR file that contains a single method and runs
        the method. </p>
      <note type="note">The example requires Java SDK to compile the Java file.</note>
      <p>The following method returns a substring.</p>
      <codeblock>{
public static String substring(String text, int beginIndex,
  int endIndex)
    {
    return text.substring(beginIndex, endIndex);
    }
}</codeblock>
      <p>Enter the java code in a text file <codeph>example.class</codeph>. </p>
      <p>Contents of the file <codeph>manifest.txt</codeph>:</p>
      <codeblock>Manifest-Version: 1.0
Main-Class: Example
Specification-Title: "Example"
Specification-Version: "1.0"
Created-By: 1.6.0_35-b10-428-11M3811
Build-Date: 01/20/2013 10:09 AM</codeblock>
      <p>Compile the java code:</p>
      <codeblock>javac *.java</codeblock>
      <p>Create a JAR archive named analytics.jar that contains the class file and the manifest file
        MANIFEST file in the JAR.</p>
      <codeblock>jar cfm analytics.jar manifest.txt *.class</codeblock>
      <p>Upload the jar file to the Greenplum master host.</p>
      <p>Run the <codeph>gpscp</codeph> utility to copy the jar file to the Greenplum Java
        directory. Use the <codeph>-f</codeph> option to specify the file that contains a list of
        the master and segment hosts.</p>
      <codeblock>gpscp -f gphosts_file analytics.jar 
=:/usr/local/greenplum-db/lib/postgresql/java/</codeblock>
      <p>Use the <codeph>gpconfig</codeph> utility to set the Greenplum
          <codeph>pljava_classpath</codeph> server configuration parameter. The parameter lists the
        installed jar files.</p>
      <codeblock>gpconfig -c pljava_classpath -v 'analytics.jar'</codeblock>
      <p>Run the <codeph>gpstop</codeph> utility with the <codeph>-u</codeph> option to reload the
        configuration files.</p>
      <codeblock>gpstop -u</codeblock>
      <p>From the <codeph>psql</codeph> command line, run the following command to show the
        installed jar files.</p>
      <codeblock>show pljava_classpath</codeblock>
      <p>The following SQL commands create a table and define a Java function to test the method in
        the jar file:</p>
      <codeblock>create table temp (a varchar) distributed randomly; 
insert into temp values ('my string'); 
--Example function 
create or replace function java_substring(varchar, int, int) 
returns varchar as 'Example.substring' language java; 
--Example execution 
select java_substring(a, 1, 5) from temp;</codeblock>
      <p>You can place the contents in a file, <codeph>mysample.sql</codeph> and run the command
        from a <codeph>psql</codeph> command line:</p>
      <codeblock>> \i mysample.sql </codeblock>
      <p>The output is similar to this:</p>
      <codeblock>java_substring
----------------
 y st
(1 row)</codeblock>
    </body>
  </topic>
  <topic id="topic41" xml:lang="en">
    <title id="pv157762">References</title>
    <body>
      <p>The PL/Java Github wiki page - <xref href="https://github.com/tada/pljava/wiki"
          format="html" scope="external">https://github.com/tada/pljava/wiki</xref>.</p>
      <p> PL/Java 1.5.0 release - <xref href="https://github.com/tada/pljava/tree/REL1_5_STABLE"
          format="html" scope="external"
        >https://github.com/tada/pljava/tree/REL1_5_STABLE</xref>.</p>
    </body>
  </topic>
</topic>
