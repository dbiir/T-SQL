<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE topic PUBLIC "-//OASIS//DTD DITA Topic//EN" "topic.dtd">
<topic id="topic_o3v_dwy_sp">
  <title id="im204286">Partitioning Large Tables</title>
  <body>
    <p>Table partitioning enables supporting very large tables, such as fact tables, by logically
      dividing them into smaller, more manageable pieces. Partitioned tables can improve query
      performance by allowing the Greenplum Database query optimizer to scan only the data needed to
      satisfy a given query instead of scanning all the contents of a large table. <ul
        id="ul_szj_5sz_bt">
        <li><xref href="#topic_tvx_nsz_bt" format="dita"/></li>
        <li><xref href="#topic65" format="dita"/></li>
        <li><xref href="#topic66" format="dita"/></li>
        <li><xref href="#topic73" format="dita"/></li>
        <li><xref href="#topic74" format="dita"/></li>
        <li><xref href="#topic76" format="dita"/></li>
        <li><xref href="#topic77" format="dita"/></li>
      </ul></p>
  </body>
  <topic id="topic_tvx_nsz_bt">
    <title>About Table Partitioning</title>
    <body>
      <p>Partitioning does not change the physical distribution of table data across the segments.
        Table distribution is physical: Greenplum Database physically divides partitioned tables and
        non-partitioned tables across segments to enable parallel query processing. Table
          <i>partitioning</i> is logical: Greenplum Database logically divides big tables to improve
        query performance and facilitate data warehouse maintenance tasks, such as rolling old data
        out of the data warehouse. </p>
      <p>Greenplum Database supports:</p>
      <ul id="ul_ohc_2wy_sp">
        <li id="im204035"><i>range partitioning</i>: division of data based on a numerical range,
          such as date or price.</li>
        <li id="im207235"><i>list partitioning</i>: division of data based on a list of values, such
          as sales territory or product line.</li>
        <li id="im207242">A combination of both types.</li>
      </ul>
      <fig id="im207241">
        <title>Example Multi-level Partition Design</title>
        <image href="../graphics/partitions.jpg" placement="break" width="344px" height="203px"
          id="image_pmc_2wy_sp"/>
      </fig>
    </body>
  </topic>
  <topic id="topic64" xml:lang="en">
    <title>Table Partitioning in Greenplum Database</title>
    <body>
      <p>Greenplum Database divides tables into parts (also known as partitions) to enable massively
        parallel processing. Tables are partitioned during <codeph>CREATE TABLE</codeph> using the
          <codeph>PARTITION BY</codeph> (and optionally the <codeph>SUBPARTITION BY</codeph>)
        clause. Partitioning creates a top-level (or parent) table with one or more levels of
        sub-tables (or child tables). Internally, Greenplum Database creates an inheritance
        relationship between the top-level table and its underlying partitions, similar to the
        functionality of the <codeph>INHERITS</codeph> clause of PostgreSQL.</p>
      <p>Greenplum uses the partition criteria defined during table creation to create each
        partition with a distinct <codeph>CHECK</codeph> constraint, which limits the data that
        table can contain. The query optimizer uses <codeph>CHECK</codeph> constraints to determine
        which table partitions to scan to satisfy a given query predicate.</p>
      <p>The Greenplum system catalog stores partition hierarchy information so that rows inserted
        into the top-level parent table propagate correctly to the child table partitions. To change
        the partition design or table structure, alter the parent table using <codeph>ALTER
          TABLE</codeph> with the <codeph>PARTITION</codeph> clause.</p>
      <p>To insert data into a partitioned table, you specify the root partitioned table, the table
        created with the <codeph>CREATE TABLE</codeph> command. You also can specify a leaf child
        table of the partitioned table in an <codeph>INSERT</codeph> command. An error is returned
        if the data is not valid for the specified leaf child table. Specifying a non-leaf or a
        non-root partition table in the DML command is not supported. </p>
    </body>
  </topic>
  <topic id="topic65" xml:lang="en">
    <title>Deciding on a Table Partitioning Strategy</title>
    <body>
      <p>Greenplum Database does not support partitioning replicated tables (<codeph>DISTRIBUTED
          REPLICATED</codeph>). Not all hash-distributed or randomly distributed tables are good
        candidates for partitioning. If the answer is <i>yes</i> to all or most of the following
        questions, table partitioning is a viable database design strategy for improving query
        performance. If the answer is <i>no</i> to most of the following questions, table
        partitioning is not the right solution for that table. Test your design strategy to ensure
        that query performance improves as expected.</p>
      <ul id="ul_jpc_2wy_sp">
        <li id="im148863"><b>Is the table large enough?</b> Large fact tables are good candidates
          for table partitioning. If you have millions or billions of records in a table, you may
          see performance benefits from logically breaking that data up into smaller chunks. For
          smaller tables with only a few thousand rows or less, the administrative overhead of
          maintaining the partitions will outweigh any performance benefits you might see.</li>
        <li id="im148864"><b>Are you experiencing unsatisfactory performance?</b> As with any
          performance tuning initiative, a table should be partitioned only if queries against that
          table are producing slower response times than desired. </li>
        <li id="im148865"><b>Do your query predicates have identifiable access patterns?</b> Examine
          the <codeph>WHERE</codeph> clauses of your query workload and look for table columns that
          are consistently used to access data. For example, if most of your queries tend to look up
          records by date, then a monthly or weekly date-partitioning design might be beneficial. Or
          if you tend to access records by region, consider a list-partitioning design to divide the
          table by region.</li>
        <li id="im204373"><b>Does your data warehouse maintain a window of historical data?</b>
          Another consideration for partition design is your organization's business requirements
          for maintaining historical data. For example, your data warehouse may require that you
          keep data for the past twelve months. If the data is partitioned by month, you can easily
          drop the oldest monthly partition from the warehouse and load current data into the most
          recent monthly partition.</li>
        <li id="im148867"><b>Can the data be divided into somewhat equal parts based on some
            defining criteria?</b> Choose partitioning criteria that will divide your data as evenly
          as possible. If the partitions contain a relatively equal number of records, query
          performance improves based on the number of partitions created. For example, by dividing a
          large table into 10 partitions, a query will execute 10 times faster than it would against
          the unpartitioned table, provided that the partitions are designed to support the query's
          criteria.</li>
      </ul>
      <p>Do not create more partitions than are needed. Creating too many partitions can slow down
        management and maintenance jobs, such as vacuuming, recovering segments, expanding the
        cluster, checking disk usage, and others. </p>
      <p>Partitioning does not improve query performance unless the query optimizer can eliminate
        partitions based on the query predicates. Queries that scan every partition run slower than
        if the table were not partitioned, so avoid partitioning if few of your queries achieve
        partition elimination. Check the explain plan for queries to make sure that partitions are
        eliminated. See <xref href="../query/topics/query-profiling.xml#topic39"/> for more about
        partition elimination.</p>
      <note type="warning">Be very careful with multi-level partitioning because the number of
        partition files can grow very quickly. For example, if a table is partitioned by both day
        and city, and there are 1,000 days of data and 1,000 cities, the total number of partitions
        is one million. Column-oriented tables store each column in a physical table, so if this
        table has 100 columns, the system would be required to manage 100 million files for the
        table, for each segment.</note>
      <p>Before settling on a multi-level partitioning strategy, consider a single level partition
        with bitmap indexes. Indexes slow down data loads, so performance testing with your data and
        schema is recommended to decide on the best strategy. </p>
    </body>
  </topic>
  <topic id="topic66" xml:lang="en">
    <title>Creating Partitioned Tables</title>
    <body>
      <p>You partition tables when you create them with <codeph>CREATE TABLE</codeph>. This topic
        provides examples of SQL syntax for creating a table with various partition designs. </p>
      <p>To partition a table:</p>
      <ol id="ol_fsc_2wy_sp">
        <li id="im204435">Decide on the partition design: date range, numeric range, or list of
          values.</li>
        <li id="im204448">Choose the column(s) on which to partition the table. </li>
        <li id="im204455">Decide how many levels of partitions you want. For example, you can create
          a date range partition table by month and then subpartition the monthly partitions by
          sales region. </li>
      </ol>
      <ul id="ul_rvc_2wy_sp">
        <li id="im153718">
          <xref href="#topic67" type="topic" format="dita"/>
        </li>
        <li id="im153726">
          <xref href="#topic68" type="topic" format="dita"/>
        </li>
        <li id="im153737">
          <xref href="#topic69" type="topic" format="dita"/>
        </li>
        <li id="im153742">
          <xref href="#topic70" type="topic" format="dita"/>
        </li>
        <li id="im153747">
          <xref href="#topic71" type="topic" format="dita"/>
        </li>
      </ul>
    </body>
    <topic id="topic67" xml:lang="en">
      <title id="im148871">Defining Date Range Table Partitions</title>
      <body>
        <p>A date range partitioned table uses a single <codeph>date</codeph> or
            <codeph>timestamp</codeph> column as the partition key column. You can use the same
          partition key column to create subpartitions if necessary, for example, to partition by
          month and then subpartition by day. Consider partitioning by the most granular level. For
          example, for a table partitioned by date, you can partition by day and have 365 daily
          partitions, rather than partition by year then subpartition by month then subpartition by
          day. A multi-level design can reduce query planning time, but a flat partition design runs
          faster.</p>
        <p>You can have Greenplum Database automatically generate partitions by giving a
            <codeph>START</codeph> value, an <codeph>END</codeph> value, and an
            <codeph>EVERY</codeph> clause that defines the partition increment value. By default,
            <codeph>START</codeph> values are always inclusive and <codeph>END</codeph> values are
          always exclusive. For example:</p>
        <p>
          <codeblock>CREATE TABLE sales (id int, date date, amt decimal(10,2))
DISTRIBUTED BY (id)
PARTITION BY RANGE (date)
( START (date '2016-01-01') INCLUSIVE
   END (date '2017-01-01') EXCLUSIVE
   EVERY (INTERVAL '1 day') );
</codeblock>
        </p>
        <p>You can also declare and name each partition individually. For example:</p>
        <p>
          <codeblock>CREATE TABLE sales (id int, date date, amt decimal(10,2))
DISTRIBUTED BY (id)
PARTITION BY RANGE (date)
( PARTITION Jan16 START (date '2016-01-01') INCLUSIVE , 
  PARTITION Feb16 START (date '2016-02-01') INCLUSIVE ,
  PARTITION Mar16 START (date '2016-03-01') INCLUSIVE ,
  PARTITION Apr16 START (date '2016-04-01') INCLUSIVE ,
  PARTITION May16 START (date '2016-05-01') INCLUSIVE ,
  PARTITION Jun16 START (date '2016-06-01') INCLUSIVE ,
  PARTITION Jul16 START (date '2016-07-01') INCLUSIVE ,
  PARTITION Aug16 START (date '2016-08-01') INCLUSIVE ,
  PARTITION Sep16 START (date '2016-09-01') INCLUSIVE ,
  PARTITION Oct16 START (date '2016-10-01') INCLUSIVE ,
  PARTITION Nov16 START (date '2016-11-01') INCLUSIVE ,
  PARTITION Dec16 START (date '2016-12-01') INCLUSIVE 
                  END (date '2017-01-01') EXCLUSIVE );
</codeblock>
        </p>
        <p>You do not have to declare an <codeph>END</codeph> value for each partition, only the
          last one. In this example, <codeph>Jan16</codeph> ends where <codeph>Feb16</codeph>
          starts.</p>
      </body>
    </topic>
    <topic id="topic68" xml:lang="en">
      <title id="im172582">Defining Numeric Range Table Partitions</title>
      <body>
        <p>A numeric range partitioned table uses a single numeric data type column as the partition
          key column. For example:</p>
        <p>
          <codeblock>CREATE TABLE rank (id int, rank int, year int, gender 
char(1), count int)
DISTRIBUTED BY (id)
PARTITION BY RANGE (year)
( START (2006) END (2016) EVERY (1), 
  DEFAULT PARTITION extra ); 
</codeblock>
        </p>
        <p>For more information about default partitions, see <xref href="#topic80" type="topic"
            format="dita"/>.</p>
      </body>
    </topic>
    <topic id="topic69" xml:lang="en">
      <title id="im148873">Defining List Table Partitions</title>
      <body>
        <p>A list partitioned table can use any data type column that allows equality comparisons as
          its partition key column. A list partition can also have a multi-column (composite)
          partition key, whereas a range partition only allows a single column as the partition key.
          For list partitions, you must declare a partition specification for every partition (list
          value) you want to create. For example:</p>
        <p>
          <codeblock>CREATE TABLE rank (id int, rank int, year int, gender 
char(1), count int ) 
DISTRIBUTED BY (id)
PARTITION BY LIST (gender)
( PARTITION girls VALUES ('F'), 
  PARTITION boys VALUES ('M'), 
  DEFAULT PARTITION other );
</codeblock>
        </p>
        <note>The current Postgres Planner allows list partitions with
          multi-column (composite) partition keys. A range partition only allows a single column as
          the partition key. GPORCA does not support composite keys, so you
          should not use composite partition keys.</note>
        <p>For more information about default partitions, see <xref href="#topic80" type="topic"
            format="dita"/>.</p>
      </body>
    </topic>
    <topic id="topic70" xml:lang="en">
      <title id="im148875">Defining Multi-level Partitions</title>
      <body>
        <p>You can create a multi-level partition design with subpartitions of partitions. Using a
            <i>subpartition template</i> ensures that every partition has the same subpartition
          design, including partitions that you add later. For example, the following SQL creates
          the two-level partition design shown in <xref href="#topic_tvx_nsz_bt/im207241"
            format="dita"/>:</p>
        <p>
          <codeblock>CREATE TABLE sales (trans_id int, date date, amount 
decimal(9,2), region text) 
DISTRIBUTED BY (trans_id)
PARTITION BY RANGE (date)
SUBPARTITION BY LIST (region)
SUBPARTITION TEMPLATE
( SUBPARTITION usa VALUES ('usa'), 
  SUBPARTITION asia VALUES ('asia'), 
  SUBPARTITION europe VALUES ('europe'), 
  DEFAULT SUBPARTITION other_regions)
  (START (date '2011-01-01') INCLUSIVE
   END (date '2012-01-01') EXCLUSIVE
   EVERY (INTERVAL '1 month'), 
   DEFAULT PARTITION outlying_dates );
</codeblock>
        </p>
        <p>The following example shows a three-level partition design where the
            <codeph>sales</codeph> table is partitioned by <codeph>year</codeph>, then
            <codeph>month</codeph>, then <codeph>region</codeph>. The <codeph>SUBPARTITION
            TEMPLATE</codeph> clauses ensure that each yearly partition has the same subpartition
          structure. The example declares a <codeph>DEFAULT</codeph> partition at each level of the
          hierarchy.</p>
        <p>
          <codeblock>CREATE TABLE p3_sales (id int, year int, month int, day int, 
region text)
DISTRIBUTED BY (id)
PARTITION BY RANGE (year)
    SUBPARTITION BY RANGE (month)
       SUBPARTITION TEMPLATE (
        START (1) END (13) EVERY (1), 
        DEFAULT SUBPARTITION other_months )
           SUBPARTITION BY LIST (region)
             SUBPARTITION TEMPLATE (
               SUBPARTITION usa VALUES ('usa'),
               SUBPARTITION europe VALUES ('europe'),
               SUBPARTITION asia VALUES ('asia'),
               DEFAULT SUBPARTITION other_regions )
( START (2002) END (2012) EVERY (1), 
  DEFAULT PARTITION outlying_years );
</codeblock>
        </p>
        <note type="caution">When you create multi-level partitions on ranges, it is easy to create
          a large number of subpartitions, some containing little or no data. This can add many
          entries to the system tables, which increases the time and memory required to optimize and
          execute queries. Increase the range interval or choose a different partitioning strategy
          to reduce the number of subpartitions created.</note>
      </body>
    </topic>
    <topic id="topic71" xml:lang="en">
      <title id="im162902">Partitioning an Existing Table</title>
      <body>
        <p>Tables can be partitioned only at creation. If you have a table that you want to
          partition, you must create a partitioned table, load the data from the original table into
          the new table, drop the original table, and rename the partitioned table with the original
          table's name. You must also re-grant any table permissions. For example:</p>
        <p>
          <codeblock>CREATE TABLE sales2 (LIKE sales) 
PARTITION BY RANGE (date)
( START (date 2016-01-01') INCLUSIVE
   END (date '2017-01-01') EXCLUSIVE
   EVERY (INTERVAL '1 month') );
INSERT INTO sales2 SELECT * FROM sales;
DROP TABLE sales;
ALTER TABLE sales2 RENAME TO sales;
GRANT ALL PRIVILEGES ON sales TO admin;
GRANT SELECT ON sales TO guest;
</codeblock>
        </p>
      </body>
    </topic>
    <topic id="topic72" xml:lang="en">
      <title>Limitations of Partitioned Tables</title>
      <body>
        <p>For each partition level, a partitioned table can have a maximum of 32,767 partitions. </p>
        <p>A primary key or unique constraint on a partitioned table must contain all the
          partitioning columns. A unique index can omit the partitioning columns; however, it is
          enforced only on the parts of the partitioned table, not on the partitioned table as a
          whole.</p>
        <p>Tables created with the <codeph>DISTRIBUTED REPLICATED</codeph> distribution policy
          cannot be partitioned. </p>
        <p>GPORCA, the Greenplum next generation query optimizer, supports uniform multi-level
          partitioned tables. If GPORCA is enabled (the default) and the multi-level partitioned
          table is not uniform, Greenplum Database executes queries against the table with the
          Postgres Planner. For information about uniform multi-level partitioned tables, see
            <xref href="../query/topics/query-piv-uniform-part-tbl.xml#topic1"/>.</p>
        <p>For information about exchanging a leaf child partition with an external table, see <xref
            href="#topic_yhz_gpn_qs" format="dita"/>.</p>
        <p>These are limitations for partitioned tables when a leaf child partition of the table is
          an external table:</p>
        <ul id="ul_byq_wdd_bt">
          <li>Queries that run against partitioned tables that contain external table partitions are
            executed with the Postgres Planner.</li>
          <li>The external table partition is a read only external table. Commands that attempt to
            access or modify data in the external table partition return an error. For example:<ul
              id="ul_ugr_try_bt">
              <li><codeph>INSERT</codeph>, <codeph>DELETE</codeph>, and <codeph>UPDATE</codeph>
                commands that attempt to change data in the external table partition return an
                error.</li>
              <li><codeph>TRUNCATE</codeph> commands return an error. </li>
              <li><codeph>COPY</codeph> commands cannot copy data to a partitioned table that
                updates an external table partition.</li>
              <li><codeph>COPY</codeph> commands that attempt to copy from an external table
                partition return an error unless you specify the <codeph>IGNORE EXTERNAL
                  PARTITIONS</codeph> clause with <codeph>COPY</codeph> command. If you specify the
                clause, data is not copied from external table partitions.<p>To use the
                    <codeph>COPY</codeph> command against a partitioned table with a leaf child
                  table that is an external table, use an SQL query to copy the data. For example,
                  if the table <codeph>my_sales</codeph> contains a with a leaf child table that is
                  an external table, this command sends the data to
                  <codeph>stdout</codeph>:<codeblock>COPY (SELECT * from my_sales ) TO stdout</codeblock></p></li>
              <li><codeph>VACUUM</codeph> commands skip external table partitions.</li>
            </ul></li>
          <li>
            <p>The following operations are supported if no data is changed on the external table
              partition. Otherwise, an error is returned.</p>
            <ul id="ul_hcw_mrn_qs">
              <li>Adding or dropping a column.</li>
              <li>Changing the data type of column.</li>
            </ul>
          </li>
          <li>These <codeph>ALTER PARTITION</codeph> operations are not supported if the partitioned
            table contains an external table partition:<ul id="ul_edw_mrn_qs">
              <li>Setting a subpartition template.</li>
              <li>Altering the partition properties.</li>
              <li>Creating a default partition.</li>
              <li>Setting a distribution policy.</li>
              <li>Setting or dropping a <codeph>NOT NULL</codeph> constraint of column.</li>
              <li>Adding or dropping constraints.</li>
              <li>Splitting an external partition.</li>
            </ul></li>
          <li> The Greenplum Database <codeph>gpbackup</codeph> utility does not back up
            data from a leaf child partition of a partitioned table if the leaf child
            partition is a readable external table.
          </li>
        </ul>
      </body>
    </topic>
  </topic>
  <topic id="topic73" xml:lang="en">
    <title>Loading Partitioned Tables</title>
    <body>
      <p>After you create the partitioned table structure, top-level parent tables are empty. Data
        is routed to the bottom-level child table partitions. In a multi-level partition design,
        only the subpartitions at the bottom of the hierarchy can contain data.</p>
      <p>Rows that cannot be mapped to a child table partition are rejected and the load fails. To
        avoid unmapped rows being rejected at load time, define your partition hierarchy with a
          <codeph>DEFAULT</codeph> partition. Any rows that do not match a partition's
          <codeph>CHECK</codeph> constraints load into the <codeph>DEFAULT</codeph> partition. See
          <xref href="#topic80" type="topic" format="dita"/>.</p>
      <p>At runtime, the query optimizer scans the entire table inheritance hierarchy and uses the
          <codeph>CHECK</codeph> table constraints to determine which of the child table partitions
        to scan to satisfy the query's conditions. The <codeph>DEFAULT</codeph> partition (if your
        hierarchy has one) is always scanned. <codeph>DEFAULT</codeph> partitions that contain data
        slow down the overall scan time.</p>
      <p>When you use <codeph>COPY</codeph> or <codeph>INSERT</codeph> to load data into a parent
        table, the data is automatically rerouted to the correct partition, just like a regular
        table. </p>
      <p>Best practice for loading data into partitioned tables is to create an intermediate staging
        table, load it, and then exchange it into your partition design. See <xref href="#topic83"
          type="topic" format="dita"/>.</p>
    </body>
  </topic>
  <topic id="topic74" xml:lang="en">
    <title id="im148883">Verifying Your Partition Strategy</title>
    <body>
      <p>When a table is partitioned based on the query predicate, you can use
          <codeph>EXPLAIN</codeph> to verify that the query optimizer scans only the relevant data
        to examine the query plan.</p>
      <p>For example, suppose a <i>sales</i> table is date-range partitioned by month and
        subpartitioned by region as shown in <xref href="#topic_tvx_nsz_bt/im207241" format="dita"
        />. For the following query:</p>
      <p>
        <codeblock>EXPLAIN SELECT * FROM sales WHERE date='01-07-12' AND 
region='usa';
</codeblock>
      </p>
      <p>The query plan for this query should show a table scan of only the following tables:</p>
      <ul id="ul_xyc_2wy_sp">
        <li id="im152925">the default partition returning 0-1 rows (if your partition design has
          one)</li>
        <li id="im148892">the January 2012 partition (<i>sales_1_prt_1</i>) returning 0-1 rows </li>
        <li id="im148893">the USA region subpartition (<i>sales_1_2_prt_usa</i>) returning <i>some
            number</i> of rows. </li>
      </ul>
      <p>The following example shows the relevant portion of the query plan.</p>
      <p>
        <codeblock>-&gt;  <codeph>Seq Scan on</codeph><codeph>sales_1_prt_1</codeph> sales (cost=0.00..0.00 <codeph>rows=0</codeph> 
     width=0)
Filter: "date"=01-07-12::date AND region='USA'::text
-&gt;  <codeph>Seq Scan on</codeph><codeph>sales_1_2_prt_usa</codeph> sales (cost=0.00..9.87 
<codeph>rows=20</codeph> 
      width=40)
</codeblock>
      </p>
      <p>Ensure that the query optimizer does not scan unnecessary partitions or subpartitions (for
        example, scans of months or regions not specified in the query predicate), and that scans of
        the top-level tables return 0-1 rows. </p>
    </body>
    <topic id="topic75" xml:lang="en">
      <title>Troubleshooting Selective Partition Scanning</title>
      <body>
        <p>The following limitations can result in a query plan that shows a non-selective scan of
          your partition hierarchy.</p>
        <ul id="ul_kcd_2wy_sp">
          <li id="im148903">The query optimizer can selectively scan partitioned tables only when
            the query contains a direct and simple restriction of the table using immutable
            operators such as:<p> =, &lt; , &lt;= , &gt;,  &gt;= , and &lt;&gt;</p></li>
          <li id="im183866">Selective scanning recognizes <codeph>STABLE</codeph> and
              <codeph>IMMUTABLE</codeph> functions, but does not recognize <codeph>VOLATILE</codeph>
            functions within a query. For example, <codeph>WHERE</codeph> clauses such as
              <codeph>date &gt; CURRENT_DATE</codeph> cause the query optimizer to selectively scan
            partitioned tables, but <codeph>time &gt; TIMEOFDAY</codeph> does not.</li>
        </ul>
      </body>
    </topic>
  </topic>
  <topic id="topic76" xml:lang="en">
    <title>Viewing Your Partition Design</title>
    <body>
      <p>You can look up information about your partition design using the <i><xref
            href="../../ref_guide/system_catalogs/pg_partitions.xml">pg_partitions</xref></i> system
        view. For example, to see the partition design of the <i>sales</i> table:</p>
      <p>
        <codeblock>SELECT partitionboundary, partitiontablename, partitionname, 
partitionlevel, partitionrank 
FROM pg_partitions 
WHERE tablename='sales';
</codeblock>
      </p>
      <p>The following table and views also show information about partitioned tables.</p>
      <ul id="ul_ycd_2wy_sp">
        <li id="im211944"><i><xref href="../../ref_guide/system_catalogs/pg_partition.xml"
              >pg_partition</xref></i>- Tracks partitioned tables and their inheritance level
          relationships. </li>
        <li id="im156096"><i><xref
              href="../../ref_guide/system_catalogs/pg_partition_templates.xml#topic1"
              >pg_partition_templates</xref></i>- Shows the subpartitions created using a
          subpartition template.</li>
        <li id="im156103"><i><xref href="../../ref_guide/system_catalogs/pg_partition_columns.xml"
              >pg_partition_columns</xref></i> - Shows the partition key columns used in a partition
          design.</li>
      </ul>
      <p otherprops="op-print">For information about Greenplum Database system catalog tables and
        views, see the <i>Greenplum Database Reference Guide</i>. </p>
    </body>
  </topic>
  <topic id="topic77" xml:lang="en">
    <title id="im154268">Maintaining Partitioned Tables</title>
    <body>
      <p>To maintain a partitioned table, use the <codeph>ALTER TABLE</codeph> command against the
        top-level parent table. The most common scenario is to drop old partitions and add new ones
        to maintain a rolling window of data in a range partition design. You can convert
          (<i>exchange</i>) older partitions to the append-optimized compressed storage format to
        save space. If you have a default partition in your partition design, you add a partition by
          <i>splitting</i> the default partition.</p>
      <ul id="ul_ufd_2wy_sp">
        <li id="im154171">
          <xref href="#topic78" type="topic" format="dita"/>
        </li>
        <li id="im153528">
          <xref href="#topic79" type="topic" format="dita"/>
        </li>
        <li id="im153533">
          <xref href="#topic80" type="topic" format="dita"/>
        </li>
        <li id="im153537">
          <xref href="#topic81" type="topic" format="dita"/>
        </li>
        <li id="im153550">
          <xref href="#topic82" type="topic" format="dita"/>
        </li>
        <li id="im153555">
          <xref href="#topic83" type="topic" format="dita"/>
        </li>
        <li id="im153559">
          <xref href="#topic84" type="topic" format="dita"/>
        </li>
        <li id="im163231">
          <xref href="#topic85" type="topic" format="dita"/>
        </li>
        <li>
          <xref href="#topic_yhz_gpn_qs" format="dita"/>
        </li>
      </ul>
      <note type="important">When defining and altering partition designs, use the given partition
        name, not the table object name. The given partition name is the
          <codeph>partitionname</codeph> column value in the <i><xref
            href="../../ref_guide/system_catalogs/pg_partitions.xml">pg_partitions</xref></i> system
        view. Although you can query and load any table (including partitioned tables) directly
        using SQL commands, you can only modify the structure of a partitioned table using the
          <codeph>ALTER TABLE...PARTITION</codeph> clauses.<p>Partitions are not required to have
          names. If a partition does not have a name, use one of the following expressions to
          specify a partition: <codeph>PARTITION FOR (<varname>value</varname>)</codeph> or
            <codeph>PARTITION FOR (RANK(<varname>number</varname>))</codeph>. </p></note>
      <p>For a multi-level partitioned table, you identify a specific partition to change with
          <codeph>ALTER PARTITION</codeph> clauses. For each partition level in the table hierarchy
        that is above the target partition, specify the partition that is related to the target
        partition in an <codeph>ALTER PARTITION</codeph> clause. For example, if you have a
        partitioned table that consists of three levels, year, quarter, and region, this
          <codeph>ALTER TABLE</codeph> command exchanges a leaf partition <codeph>region</codeph>
        with the table <codeph>region_new</codeph>. </p>
      <codeblock>ALTER TABLE sales <b>ALTER PARTITION year_1 ALTER PARTITION quarter_4</b> EXCHANGE PARTITION region WITH TABLE region_new ;</codeblock>
      <p>The two <codeph>ALTER PARTITION</codeph> clauses identify which <codeph>region</codeph>
        partition to exchange. Both clauses are required to identify the specific leaf partition to
        exchange.</p>
    </body>
    <topic id="topic78" xml:lang="en">
      <title id="im172625">Adding a Partition</title>
      <body>
        <p>You can add a partition to a partition design with the <codeph>ALTER TABLE</codeph>
          command. If the original partition design included subpartitions defined by a
            <i>subpartition template</i>, the newly added partition is subpartitioned according to
          that template. For example:</p>
        <p>
          <codeblock>ALTER TABLE sales ADD PARTITION 
            START (date '2017-02-01') INCLUSIVE 
            END (date '2017-03-01') EXCLUSIVE;
</codeblock>
        </p>
        <p>If you did not use a subpartition template when you created the table, you define
          subpartitions when adding a partition:</p>
        <p>
          <codeblock>ALTER TABLE sales ADD PARTITION 
            START (date '2017-02-01') INCLUSIVE 
            END (date '2017-03-01') EXCLUSIVE
      ( SUBPARTITION usa VALUES ('usa'), 
        SUBPARTITION asia VALUES ('asia'), 
        SUBPARTITION europe VALUES ('europe') );
</codeblock>
        </p>
        <p>When you add a subpartition to an existing partition, you can specify the partition to
          alter. For example:</p>
        <p>
          <codeblock>ALTER TABLE sales ALTER PARTITION FOR (RANK(12))
      ADD PARTITION africa VALUES ('africa');
</codeblock>
        </p>
        <note type="note">You cannot add a partition to a partition design that has a default
          partition. You must split the default partition to add a partition. See <xref
            href="#topic84" type="topic" format="dita"/>.</note>
      </body>
    </topic>
    <topic id="topic79" xml:lang="en">
      <title id="im153493">Renaming a Partition</title>
      <body>
        <p>Partitioned tables use the following naming convention. Partitioned subtable names are
          subject to uniqueness requirements and length limitations. </p>
        <p>
          <codeblock><i>&lt;parentname&gt;</i>_<i>&lt;level&gt;</i>_prt_<i>&lt;partition_name&gt;</i></codeblock>
        </p>
        <p>For example:</p>
        <p>
          <codeblock><i>sales_1_prt_jan16</i></codeblock>
        </p>
        <p>For auto-generated range partitions, where a number is assigned when no name is
          given):</p>
        <p>
          <codeblock><i>sales_1_prt_1</i></codeblock>
        </p>
        <p>To rename a partitioned child table, rename the top-level parent table. The
            <i>&lt;parentname&gt;</i> changes in the table names of all associated child table
          partitions. For example, the following command:</p>
        <p>
          <codeblock>ALTER TABLE sales RENAME TO globalsales;
</codeblock>
        </p>
        <p>Changes the associated table names:</p>
        <p>
          <codeblock><i>globalsales_1_prt_1</i></codeblock>
        </p>
        <p>You can change the name of a partition to make it easier to identify. For example:</p>
        <p>
          <codeblock>ALTER TABLE sales RENAME PARTITION FOR ('2016-01-01') TO jan16;
</codeblock>
        </p>
        <p>Changes the associated table name as follows:</p>
        <p>
          <codeblock><i>sales_1_prt_jan16</i></codeblock>
        </p>
        <p>When altering partitioned tables with the <codeph>ALTER TABLE</codeph> command, always
          refer to the tables by their partition name (<i>jan16</i>) and not their full table name
            (<i>sales_1_prt_jan16</i>).</p>
        <note type="note">The table name cannot be a partition name in an <codeph>ALTER
            TABLE</codeph> statement. For example, <codeph>ALTER TABLE sales...</codeph> is correct,
            <codeph>ALTER TABLE sales_1_part_jan16...</codeph> is not allowed.</note>
      </body>
    </topic>
    <topic id="topic80" xml:lang="en">
      <title id="im152983">Adding a Default Partition</title>
      <body>
        <p>You can add a default partition to a partition design with the <codeph>ALTER
            TABLE</codeph> command. </p>
        <p>
          <codeblock>ALTER TABLE sales ADD DEFAULT PARTITION other;
</codeblock>
        </p>
        <p>If your partition design is multi-level, each level in the hierarchy must have a default
          partition. For example:</p>
        <p>
          <codeblock>ALTER TABLE sales ALTER PARTITION FOR (RANK(1)) ADD DEFAULT 
PARTITION other;

ALTER TABLE sales ALTER PARTITION FOR (RANK(2)) ADD DEFAULT 
PARTITION other;

ALTER TABLE sales ALTER PARTITION FOR (RANK(3)) ADD DEFAULT 
PARTITION other;
</codeblock>
        </p>
        <p>If incoming data does not match a partition's <codeph>CHECK</codeph> constraint and there
          is no default partition, the data is rejected. Default partitions ensure that incoming
          data that does not match a partition is inserted into the default partition.</p>
      </body>
    </topic>
    <topic id="topic81" xml:lang="en">
      <title id="im148907">Dropping a Partition</title>
      <body>
        <p>You can drop a partition from your partition design using the <codeph>ALTER
            TABLE</codeph> command. When you drop a partition that has subpartitions, the
          subpartitions (and all data in them) are automatically dropped as well. For range
          partitions, it is common to drop the older partitions from the range as old data is rolled
          out of the data warehouse. For example:</p>
        <p>
          <codeblock>ALTER TABLE sales DROP PARTITION FOR (RANK(1));
</codeblock>
        </p>
      </body>
    </topic>
    <topic id="topic82" xml:lang="en">
      <title id="im164130">Truncating a Partition</title>
      <body>
        <p>You can truncate a partition using the <codeph>ALTER TABLE</codeph> command. When you
          truncate a partition that has subpartitions, the subpartitions are automatically truncated
          as well. </p>
        <p>
          <codeblock>ALTER TABLE sales TRUNCATE PARTITION FOR (RANK(1));
</codeblock>
        </p>
      </body>
    </topic>
    <topic id="topic83" xml:lang="en">
      <title id="im148982">Exchanging a Partition</title>
      <body>
        <p>You can exchange a partition using the <codeph>ALTER TABLE</codeph> command. Exchanging a
          partition swaps one table in place of an existing partition. You can exchange partitions
          only at the lowest level of your partition hierarchy (only partitions that contain data
          can be exchanged). </p>
        <p>You cannot exchange a partition with a replicated table. Exchanging a partition with a partitioned table or a child partition of a partitioned
          table is not supported.</p>
        <p>Partition exchange can be useful for data loading. For example, load a staging table and
          swap the loaded table into your partition design. You can use partition exchange to change
          the storage type of older partitions to append-optimized tables. For example:</p>
        <p>
          <codeblock>CREATE TABLE jan12 (LIKE sales) WITH (appendoptimized=true);
INSERT INTO jan12 SELECT * FROM sales_1_prt_1 ;
ALTER TABLE sales EXCHANGE PARTITION FOR (DATE '2012-01-01') 
WITH TABLE jan12;
</codeblock>
        </p>
        <note type="note">This example refers to the single-level definition of the table
            <codeph>sales</codeph>, before partitions were added and altered in the previous
          examples.</note>
        <note type="warning">If you specify the <codeph>WITHOUT VALIDATION</codeph> clause, you must
          ensure that the data in table that you are exchanging for an existing partition is valid
          against the constraints on the partition. Otherwise, queries against the partitioned table
          might return incorrect results.</note>
        <p>The Greenplum Database server configuration parameter
            <codeph>gp_enable_exchange_default_partition</codeph> controls availability of the
            <codeph>EXCHANGE DEFAULT PARTITION</codeph> clause. The default value for the parameter
          is <codeph>off</codeph>, the clause is not available and Greenplum Database returns an
          error if the clause is specified in an <codeph>ALTER TABLE</codeph> command.</p>
        <p>For information about the parameter, see "Server Configuration Parameters" in the
            <cite>Greenplum Database Reference Guide</cite>.<note type="warning">Before you exchange
            the default partition, you must ensure the data in the table to be exchanged, the new
            default partition, is valid for the default partition. For example, the data in the new
            default partition must not contain data that would be valid in other leaf child
            partitions of the partitioned table. Otherwise, queries against the partitioned table
            with the exchanged default partition that are executed by GPORCA might return incorrect
            results.</note></p>
      </body>
    </topic>
    <topic id="topic84" xml:lang="en">
      <title id="im153485">Splitting a Partition</title>
      <body>
        <p>Splitting a partition divides a partition into two partitions. You can split a partition
          using the <codeph>ALTER TABLE</codeph> command. You can split partitions only at the
          lowest level of your partition hierarchy (partitions that contain data). For a multi-level
          partition, only range partitions can be split, not list partitions. The split value you
          specify goes into the <i>latter</i> partition. </p>
        <p>For example, to split a monthly partition into two with the first partition containing
          dates January 1-15 and the second partition containing dates January 16-31:</p>
        <p>
          <codeblock>ALTER TABLE sales SPLIT PARTITION FOR ('2017-01-01')
AT ('2017-01-16')
INTO (PARTITION jan171to15, PARTITION jan1716to31);
</codeblock>
        </p>
        <p>If your partition design has a default partition, you must split the default partition to
          add a partition.</p>
        <p>When using the <codeph>INTO</codeph> clause, specify the current default partition as the
          second partition name. For example, to split a default range partition to add a new
          monthly partition for January 2017:</p>
        <p>
          <codeblock>ALTER TABLE sales SPLIT DEFAULT PARTITION 
START ('2017-01-01') INCLUSIVE 
END ('2017-02-01') EXCLUSIVE 
INTO (PARTITION jan17, default partition);
</codeblock>
        </p>
      </body>
    </topic>
    <topic id="topic85" xml:lang="en">
      <title id="im163198">Modifying a Subpartition Template</title>
      <body>
        <p>Use <codeph>ALTER TABLE</codeph> SET SUBPARTITION TEMPLATE to modify the subpartition
          template of a partitioned table. Partitions added after you set a new subpartition
          template have the new partition design. Existing partitions are not modified. </p>
        <p>The following example alters the subpartition template of this partitioned
          table:<codeblock>CREATE TABLE sales (trans_id int, date date, amount decimal(9,2), region text)
  DISTRIBUTED BY (trans_id)
  PARTITION BY RANGE (date)
  SUBPARTITION BY LIST (region)
  SUBPARTITION TEMPLATE
    ( SUBPARTITION usa VALUES ('usa'),
      SUBPARTITION asia VALUES ('asia'),
      SUBPARTITION europe VALUES ('europe'),
      DEFAULT SUBPARTITION other_regions )
  ( START (date '2014-01-01') INCLUSIVE
    END (date '2014-04-01') EXCLUSIVE
    EVERY (INTERVAL '1 month') );</codeblock></p>
        <p>This <codeph>ALTER TABLE</codeph> command, modifies the subpartition template.</p>
        <p>
          <codeblock>ALTER TABLE sales SET SUBPARTITION TEMPLATE
( SUBPARTITION usa VALUES ('usa'), 
  SUBPARTITION asia VALUES ('asia'), 
  SUBPARTITION europe VALUES ('europe'),
  SUBPARTITION africa VALUES ('africa'), 
  DEFAULT SUBPARTITION regions );</codeblock>
        </p>
        <p>When you add a date-range partition of the table sales, it includes the new regional list
          subpartition for Africa. For example, the following command creates the subpartitions
            <codeph>usa</codeph>, <codeph>asia</codeph>, <codeph>europe</codeph>,
            <codeph>africa</codeph>, and a default partition named <codeph>other</codeph>:</p>
        <p>
          <codeblock>ALTER TABLE sales ADD PARTITION "4"
  START ('2014-04-01') INCLUSIVE 
  END ('2014-05-01') EXCLUSIVE ;</codeblock>
        </p>
        <p>To view the tables created for the partitioned table <codeph>sales</codeph>, you can use
          the command <codeph>\dt sales*</codeph> from the psql command line.</p>
        <p>To remove a subpartition template, use <codeph>SET SUBPARTITION TEMPLATE</codeph> with
          empty parentheses. For example, to clear the sales table subpartition template:</p>
        <p>
          <codeblock>ALTER TABLE sales SET SUBPARTITION TEMPLATE ();
</codeblock>
        </p>
      </body>
    </topic>
    <topic id="topic_yhz_gpn_qs">
      <title>Exchanging a Leaf Child Partition with an External Table</title>
      <body>
        <p>You can exchange a leaf child partition of a partitioned table with a readable external
          table. The external table data can reside on a host file system, an NFS mount, or a Hadoop
          file system (HDFS).</p>
        <p>For example, if you have a partitioned table that is created with monthly partitions and
          most of the queries against the table only access the newer data, you can copy the older,
          less accessed data to external tables and exchange older partitions with the external
          tables. For queries that only access the newer data, you could create queries that use
          partition elimination to prevent scanning the older, unneeded partitions.</p>
         <p>Exchanging a leaf child partition with an external table is not supported if the
          partitioned table contains a column with a check constraint or a <codeph>NOT NULL</codeph>
          constraint.</p>
        <p>For information about exchanging and altering a leaf child partition, see the
            <codeph>ALTER TABLE</codeph> command in the<cite> Greenplum Database Command
            Reference</cite>.</p>
        <p>For information about limitations of partitioned tables that contain a external table
          partition, see <xref href="#topic72" format="dita"/>.</p>
      </body>
      <topic id="topic_y3y_1xd_bt">
        <title>Example Exchanging a Partition with an External Table</title>
        <body>
          <p>This is a simple example that exchanges a leaf child partition of this partitioned
            table for an external table. The partitioned table contains data for the years 2010
            through 2013.</p>
          <codeblock>CREATE TABLE sales (id int, year int, qtr int, day int, region text)
  DISTRIBUTED BY (id) 
  PARTITION BY RANGE (year) 
  ( PARTITION yr START (2010) END (2014) EVERY (1) ) ;</codeblock>
          <p>There are four leaf child partitions for the partitioned table. Each leaf child
            partition contains the data for a single year. The leaf child partition table
              <codeph>sales_1_prt_yr_1</codeph> contains the data for the year 2010. These steps
            exchange the table <codeph>sales_1_prt_yr_1</codeph> with an external table the uses the
              <codeph>gpfdist</codeph> protocol:</p>
          <ol id="ol_uls_2xd_bt">
            <li>Ensure that the external table protocol is enabled for the Greenplum Database
                system.<p>This example uses the <codeph>gpfdist</codeph> protocol. This command
                starts the <codeph>gpfdist</codeph> protocol.
              <codeblock> $ gpfdist</codeblock></p></li>
            <li>Create a writable external table.<p>This <codeph>CREATE WRITABLE EXTERNAL
                  TABLE</codeph> command creates a writable external table with the same columns as
                the partitioned
              table.</p><codeblock>CREATE WRITABLE EXTERNAL TABLE my_sales_ext ( LIKE sales_1_prt_yr_1 )
  LOCATION ( 'gpfdist://gpdb_test/sales_2010' )
  FORMAT 'csv' 
  DISTRIBUTED BY (id) ;</codeblock></li>
            <li>Create a readable external table that reads the data from that destination of the
              writable external table created in the previous step.<p>This <codeph>CREATE EXTERNAL
                  TABLE</codeph> create a readable external that uses the same external data as the
                writable external
              data.</p><codeblock>CREATE EXTERNAL TABLE sales_2010_ext ( LIKE sales_1_prt_yr_1) 
  LOCATION ( 'gpfdist://gpdb_test/sales_2010' )
  FORMAT 'csv' ;</codeblock></li>
            <li>Copy the data from the leaf child partition into the writable external table.<p>This
                  <codeph>INSERT</codeph> command copies the data from the child leaf partition
                table of the partitioned table into the external
              table.</p><codeblock>INSERT INTO my_sales_ext SELECT * FROM sales_1_prt_yr_1 ;</codeblock></li>
            <li>Exchange the existing leaf child partition with the external table.<p>This
                  <codeph>ALTER TABLE</codeph> command specifies the <codeph>EXCHANGE
                  PARTITION</codeph> clause to switch the readable external table and the leaf child
                partition.
                </p><codeblock>ALTER TABLE sales ALTER PARTITION yr_1 
   EXCHANGE PARTITION yr_1 
   WITH TABLE sales_2010_ext WITHOUT VALIDATION;</codeblock><p>The
                external table becomes the leaf child partition with the table name
                  <codeph>sales_1_prt_yr_1</codeph> and the old leaf child partition becomes the
                table <codeph>sales_2010_ext</codeph>. </p><note type="warning">In order to ensure
                queries against the partitioned table return the correct results, the external table
                data must be valid against the <codeph>CHECK</codeph> constraints on the leaf child
                partition. In this case, the data was taken from the child leaf partition table on
                which the <codeph>CHECK</codeph> constraints were defined.</note></li>
            <li>Drop the table that was rolled out of the partitioned
              table.<codeblock>DROP TABLE sales_2010_ext ;</codeblock></li>
          </ol>
          <p>You can rename the name of the leaf child partition to indicate that
              <codeph>sales_1_prt_yr_1</codeph> is an external table.</p>
          <p>This example command changes the <codeph>partitionname</codeph> to
              <codeph>yr_1_ext</codeph> and the name of the child leaf partition table to
              <codeph>sales_1_prt_yr_1_ext</codeph>.</p>
          <codeblock>ALTER TABLE sales RENAME PARTITION yr_1 TO  yr_1_ext ;</codeblock>
        </body>
      </topic>
    </topic>
  </topic>
</topic>
