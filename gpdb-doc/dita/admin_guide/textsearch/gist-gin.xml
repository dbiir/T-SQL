<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE topic PUBLIC "-//OASIS//DTD DITA Topic//EN" "topic.dtd">
<topic id="gist-gin">
  <title>GiST and GIN Indexes for Text Search </title>
  <shortdesc>This topic describes and compares the Greenplum Database index types that are used for
    full text searching.</shortdesc>
  <body>
    <p>There are two kinds of indexes that can be used to speed up full text searches. Indexes are
      not mandatory for full text searching, but in cases where a column is searched on a regular
      basis, an index is usually desirable.</p>
    <dl>
      <dlentry>
        <dt><codeph>CREATE INDEX <i>name</i> ON <i>table</i> USING
          gist(<i>column</i>);</codeph></dt>
        <dd>
          <p>Creates a GiST (Generalized Search Tree)-based index. The
              <codeph><i>column</i></codeph> can be of <codeph>tsvector</codeph> or
              <codeph>tsquery</codeph> type.</p>
        </dd>
      </dlentry>
      <dlentry>
        <dt><codeph>CREATE INDEX <i>name</i> ON <i>table</i> USING gin(<i>column</i>);</codeph></dt>
        <dd>
          <p>Creates a GIN (Generalized Inverted Index)-based index. The
              <codeph><i>column</i></codeph> must be of <codeph>tsvector</codeph> type.</p>
        </dd>
      </dlentry>
    </dl>
    <p>There are substantial performance differences between the two index types, so it is important
      to understand their characteristics.</p>
    <p>A GiST index is <i>lossy</i>, meaning that the index may produce false matches, and it is
      necessary to check the actual table row to eliminate such false matches. (Greenplum Database
      does this automatically when needed.) GiST indexes are lossy because each document is
      represented in the index by a fixed-length signature. The signature is generated by hashing
      each word into a single bit in an n-bit string, with all these bits OR-ed together to produce
      an n-bit document signature. When two words hash to the same bit position there will be a
      false match. If all words in the query have matches (real or false) then the table row must be
      retrieved to see if the match is correct.</p>
    <p>Lossiness causes performance degradation due to unnecessary fetches of table records that
      turn out to be false matches. Since random access to table records is slow, this limits the
      usefulness of GiST indexes. The likelihood of false matches depends on several factors, in
      particular the number of unique words, so using dictionaries to reduce this number is
      recommended.</p>
    <p>GIN indexes are not lossy for standard queries, but their performance depends logarithmically
      on the number of unique words. (However, GIN indexes store only the words (lexemes) of
        <codeph>tsvector</codeph> values, and not their weight labels. Thus a table row recheck is
      needed when using a query that involves weights.)</p>
    <p>In choosing which index type to use, GiST or GIN, consider these performance differences:</p>
    <ul id="ul_ys5_yj1_lfb">
      <li>GIN index lookups are about three times faster than GiST</li>
      <li>GIN indexes take about three times longer to build than GiST</li>
      <li>GIN indexes are moderately slower to update than GiST indexes, but about 10 times slower
        if fast-update support was disabled (see <xref
          href="https://www.postgresql.org/docs/9.4/gin-implementation.html#GIN-FAST-UPDATE"
          format="html" scope="external">GIN Fast Update Technique</xref> in the PostgreSQL
        documentation for details)</li>
      <li>GIN indexes are two-to-three times larger than GiST indexes</li>
    </ul>
    <p>As a rule of thumb, GIN indexes are best for static data because lookups are faster. For
      dynamic data, GiST indexes are faster to update. Specifically, GiST indexes are very good for
      dynamic data and fast if the number of unique words (lexemes) is under 100,000, while GIN
      indexes will handle 100,000+ lexemes better but are slower to update.</p>
    <p>Note that GIN index build time can often be improved by increasing <xref
        href="../../ref_guide/config_params/guc-list.xml#maintenance_work_mem"/>, while GiST index
      build time is not sensitive to that parameter.</p>
    <p>Partitioning of big collections and the proper use of GiST and GIN indexes allows the
      implementation of very fast searches with online update. Partitioning can be done at the
      database level using table inheritance, or by distributing documents over servers and
      collecting search results using <xref href="../../ref_guide/modules/dblink.xml#topic_lv4_czp_fz"
      />. The latter is possible because ranking functions use only local information.</p>
  </body>
</topic>
