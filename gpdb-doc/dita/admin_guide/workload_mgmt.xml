<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE topic
  PUBLIC "-//OASIS//DTD DITA Composite//EN" "ditabase.dtd">
<topic id="topic1" xml:lang="en">
  <title id="iz173472">Using Resource Queues</title>
  <body>
    <p>Use Greenplum Database resource queues to prioritize and allocate resources to queries
      according to business requirements and to prevent queries from starting when resources are
      unavailable.</p>
    <p>Resource queues are one tool to manage the degree of concurrency in a Greenplum Database
      system. Resource queues are database objects that you create with the <codeph>CREATE RESOURCE
        QUEUE</codeph> SQL statement. You can use them to manage the number of active queries that
      may execute concurrently, the amount of memory each type of query is allocated, and the
      relative priority of queries. Resource queues can also guard against queries that would
      consume too many resources and degrade overall system performance.</p>
    <p>Each database role is associated with a single resource queue; multiple roles can share the
      same resource queue. Roles are assigned to resource queues using the <codeph>RESOURCE
        QUEUE</codeph> phrase of the <codeph>CREATE ROLE</codeph> or <codeph>ALTER ROLE</codeph>
      statements. If a resource queue is not specified, the role is associated with the default
      resource queue, <codeph>pg_default</codeph>. </p>
    <p>When the user submits a query for execution, the query is evaluated against the resource
      queue's limits. If the query does not cause the queue to exceed its resource limits, then that
      query will run immediately. If the query causes the queue to exceed its limits (for example,
      if the maximum number of active statement slots are currently in use), then the query must
      wait until queue resources are free before it can run. Queries are evaluated on a first in,
      first out basis. If query prioritization is enabled, the active workload on the system is
      periodically assessed and processing resources are reallocated according to query priority
      (see <xref href="#priorities" format="dita"/>). Roles with the <codeph>SUPERUSER</codeph>
      attribute are exempt from resource queue limits. Superuser queries always run immediately
      regardless of limits imposed by their assigned resource queue. </p>
    <fig id="iz153477">
      <title>Resource Queue Process</title>
      <image href="graphics/resource_queues.jpg" placement="break" width="443px" height="173px"
        id="image_u4c_qxw_wq"/>
    </fig>
    <p>Resource queues define classes of queries with similar resource requirements. Administratrors
      should create resource queues for the various types of workloads in their organization. For
      example, you could create resource queues for the following classes of queries, corresponding
      to different service level agreements: <ul id="ul_h3q_5qz_zp">
        <li>ETL queries</li>
        <li>Reporting queries</li>
        <li>Executive queries</li>
      </ul></p>
    <p>A resource queue has the following characteristics:<parml>
        <plentry>
          <pt>MEMORY_LIMIT</pt>
          <pd>The amount of memory used by all the queries in the queue (per segment). For example,
            setting <varname>MEMORY_LIMIT</varname> to 2GB on the ETL queue allows ETL queries to
            use up to 2GB of memory in each segment. </pd>
        </plentry>
        <plentry>
          <pt>ACTIVE_STATEMENTS</pt>
          <pd>The number of <i>slots</i> for a queue; the maximum concurrency level for a queue.
            When all slots are used, new queries must wait. Each query uses an equal amount of
            memory by default. </pd>
          <pd>For example, the <codeph>pg_default</codeph> resource queue has
              <varname>ACTIVE_STATEMENTS</varname> = 20.</pd>
        </plentry>
        <plentry>
          <pt>PRIORITY</pt>
          <pd>The relative CPU usage for queries. This may be one of the following levels:
              <codeph>LOW</codeph>, <codeph>MEDIUM</codeph>, <codeph>HIGH</codeph>,
              <codeph>MAX</codeph>. The default level is <codeph>MEDIUM</codeph>. The query
            prioritization mechanism monitors the CPU usage of all the queries running in the
            system, and adjusts the CPU usage for each to conform to its priority level. For
            example, you could set <codeph>MAX</codeph> priority to the <codeph>executive</codeph>
            resource queue and <codeph>MEDIUM</codeph> to other queues to ensure that executive
            queries receive a greater share of CPU.</pd>
        </plentry>
        <plentry>
          <pt>MAX_COST</pt>
          <pd>Query plan cost limit. </pd>
          <pd>The Greenplum Database optimizer assigns a numeric cost to each query. If the cost
            exceeds the <codeph>MAX_COST</codeph> value set for the resource queue, the query is
            rejected as too expensive.</pd>
          <pd>
            <note>GPORCA and the Postgres Planner utilize different
              query costing models and may compute different costs for the same query.
              The Greenplum Database resource queue resource management scheme neither
              differentiates nor aligns costs between GPORCA and the Postgres Planner; it
              uses the literal cost value returned from the optimizer to throttle
              queries.<p> When resource queue-based resource management is active, use the
              <codeph>MEMORY_LIMIT</codeph> and <codeph>ACTIVE_STATEMENTS</codeph> limits for
              resource queues rather than configuring cost-based limits. Even when using GPORCA,
              Greenplum Database may fall back to using the Postgres Planner for certain
              queries, so using cost-based limits can lead to unexpected results.</p></note>
          </pd>
        </plentry>
      </parml></p>
    <p>The default configuration for a Greenplum Database system has a single default resource queue
      named <codeph>pg_default</codeph>. The <codeph>pg_default</codeph> resource queue has an
        <codeph>ACTIVE_STATEMENTS</codeph> setting of 20, no <codeph>MEMORY_LIMIT</codeph>, medium
        <codeph>PRIORITY</codeph>, and no set <codeph>MAX_COST</codeph>. This means that all queries
      are accepted and run immediately, at the same priority and with no memory limitations;
      however, only twenty queries may execute concurrently. </p>
    <p>The number of concurrent queries a resource queue allows depends on whether the
        <codeph>MEMORY_LIMIT</codeph> parameter is set:</p>
    <ul id="ul_p5p_jxp_wq">
      <li>If no <codeph>MEMORY_LIMIT</codeph> is set for a resource queue, the amount of memory
        allocated per query is the value of the <codeph><xref
            href="../ref_guide/config_params/guc-list.xml#statement_mem" type="section"
            >statement_mem</xref></codeph> server configuration parameter. The maximum memory the
        resource queue can use is the product of <codeph>statement_mem</codeph> and
          <codeph>ACTIVE_STATEMENTS</codeph>. </li>
      <li>When a <codeph>MEMORY_LIMIT</codeph> is set on a resource queue, the number of queries
        that the queue can execute concurrently is limited by the queue's available memory. </li>
    </ul>
    <p>A query admitted to the system is allocated an amount of memory and a query plan tree is
      generated for it. Each node of the tree is an operator, such as a sort or hash join. Each
      operator is a separate execution thread and is allocated a fraction of the overall statement
      memory, at minimum 100KB. If the plan has a large number of operators, the minimum memory
      required for operators can exceed the available memory and the query will be rejected with an
      insufficient memory error. Operators determine if they can complete their tasks in the memory
      allocated, or if they must spill data to disk, in work files. The mechanism that allocates and
      controls the amount of memory used by each operator is called <i>memory quota</i>. </p>
    <p>Not all SQL statements submitted through a resource queue are evaluated against the queue
      limits. By default only <codeph>SELECT</codeph>, <codeph>SELECT INTO</codeph>, <codeph>CREATE
        TABLE AS SELECT</codeph>, and <codeph>DECLARE CURSOR</codeph> statements are evaluated. If
      the server configuration parameter <codeph>resource_select_only</codeph> is set to <i>off</i>,
      then <codeph>INSERT</codeph><ph>, <codeph>UPDATE</codeph>, and <codeph>DELETE</codeph></ph>
      statements will be evaluated as well.</p>
    <p>Also, an SQL statement that is run during the execution of an <codeph>EXPLAIN
        ANALYZE</codeph> command is excluded from resource queues.</p>
  </body>
  <topic id="topic111" xml:lang="en">
    <title>Resource Queue Example</title>
    <body>
      <p>The default resource queue, <codeph>pg_default</codeph>, allows a maximum of 20 active
        queries and allocates the same amount of memory to each. This is generally not adequate
        resource control for production systems. To ensure that the system meets performance
        expectations, you can define classes of queries and assign them to resource queues
        configured to execute them with the concurrency, memory, and CPU resources best suited for
        that class of query.</p>
      <p>The following illustration shows an example resource queue configuration for a Greenplum
        Database system with <codeph>gp_vmem_protect_limit</codeph> set to 8GB:<fig
          id="fig_p3y_mg5_1q">
          <title>Resource Queue Configuration Example</title>
          <image href="graphics/resource_queue_examp.png" id="image_wnh_wpc_dq" width="6in"/>
        </fig></p>
      <p>This example has three classes of queries with different characteristics and service level
        agreements (SLAs). Three resource queues are configured for them. A portion of the segment
        memory is reserved as a safety margin. <table frame="all" id="table_kns_wg5_1q">
          <tgroup cols="4">
            <colspec colname="c1" colnum="1" colwidth="1.0*"/>
            <colspec colname="c2" colnum="2" colwidth="1.0*"/>
            <colspec colname="c3" colnum="3" colwidth="1.0*"/>
            <colspec colname="c4" colnum="4" colwidth="1.0*"/>
            <thead>
              <row>
                <entry>Resource Queue Name</entry>
                <entry>Active Statements</entry>
                <entry>Memory Limit</entry>
                <entry>Memory per Query</entry>
              </row>
            </thead>
            <tbody>
              <row>
                <entry>ETL</entry>
                <entry>3</entry>
                <entry>2GB</entry>
                <entry>667MB</entry>
              </row>
              <row>
                <entry>Reporting</entry>
                <entry>7</entry>
                <entry>3GB</entry>
                <entry>429MB</entry>
              </row>
              <row>
                <entry>Executive</entry>
                <entry>1</entry>
                <entry>1.4GB</entry>
                <entry>1.4GB</entry>
              </row>
            </tbody>
          </tgroup>
        </table></p>
      <p>The total memory allocated to the queues is 6.4GB, or 80% of the total segment memory
        defined by the <codeph>gp_vmem_protect_limit</codeph> server configuration parameter.
        Allowing a safety margin of 20% accommodates some operators and queries that are known to
        use more memory than they are allocated by the resource queue. </p>
      <p>See the <codeph>CREATE RESOURCE QUEUE</codeph> and <codeph>CREATE/ALTER ROLE</codeph>
        statements in the <cite>Greenplum Database Reference Guide</cite> for help with command
        syntax and detailed reference information.</p>
    </body>
  </topic>
  <topic id="topic113" xml:lang="en">
    <title>How Memory Limits Work</title>
    <body>
      <p>Setting <codeph>MEMORY_LIMIT</codeph> on a resource queue sets the maximum amount of memory
        that all active queries submitted through the queue can consume for a segment instance. The
        amount of memory allotted to a query is the queue memory limit divided by the active
        statement limit. (Use the memory limits in conjunction with statement-based queues rather
        than cost-based queues.) For example, if a queue has a memory limit of 2000MB and an active
        statement limit of 10, each query submitted through the queue is allotted 200MB of memory by
        default. The default memory allotment can be overridden on a per-query basis using the
          <codeph>statement_mem</codeph> server configuration parameter (up to the queue memory
        limit). Once a query has started executing, it holds its allotted memory in the queue until
        it completes, even if during execution it actually consumes less than its allotted amount of
        memory.</p>
      <p>You can use the <codeph>statement_mem</codeph> server configuration parameter to override
        memory limits set by the current resource queue. At the session level, you can increae
          <codeph>statement_mem</codeph> up to the resource queue's <codeph>MEMORY_LIMIT</codeph>.
        This will allow an individual query to use all of the memory allocated for the entire queue
        without affecting other resource queues.</p>
      <p>The value of <codeph>statement_mem</codeph> is capped using the
          <codeph>max_statement_mem</codeph> configuration parameter (a superuser parameter). For a
        query in a resource queue with <codeph>MEMORY_LIMIT</codeph> set, the maximum value for
          <codeph>statement_mem</codeph> is <codeph>min(MEMORY_LIMIT, max_statement_mem)</codeph>.
        When a query is admitted, the memory allocated to it is subtracted from
          <codeph>MEMORY_LIMIT</codeph>. If <codeph>MEMORY_LIMIT</codeph> is exhausted, new queries
        in the same resource queue must wait. This happens even if
          <codeph>ACTIVE_STATEMENTS</codeph> has not yet been reached. Note that this can happen
        only when <codeph>statement_mem</codeph> is used to override the memory allocated by the
        resource queue.</p>
      <p>For example, consider a resource queue named <codeph>adhoc</codeph> with the following
          settings:<ul id="ul_dpr_vnd_dq">
          <li><codeph>MEMORY_LIMIT</codeph> is 1.5GB </li>
          <li><codeph>ACTIVE_STATEMENTS</codeph> is 3</li>
        </ul>
      </p>
      <p>By default each statement submitted to the queue is allocated 500MB of memory. Now consider
        the following series of events:<ol id="ol_hjq_14d_dq">
          <li>User <codeph>ADHOC_1</codeph> submits query <codeph>Q1</codeph>,
              overriding<codeph>STATEMENT_MEM</codeph> to 800MB. The <codeph>Q1</codeph> statement
            is admitted into the system. </li>
          <li>User <codeph>ADHOC_2</codeph> submits query <codeph>Q2</codeph>, using the default
            500MB.</li>
          <li>With <codeph>Q1</codeph> and <codeph>Q2</codeph> still running, user
              <codeph>ADHOC3</codeph> submits query <codeph>Q3</codeph>, using the default
            500MB.</li>
        </ol></p>
      <p>Queries <codeph>Q1</codeph> and <codeph>Q2</codeph> have used 1300MB of the queue's 1500MB.
        Therefore, <codeph>Q3</codeph> must wait for <codeph>Q1</codeph> or <codeph>Q2</codeph> to
        complete before it can run. </p>
      <p>If <codeph>MEMORY_LIMIT</codeph> is not set on a queue, queries are admitted until all of
        the <codeph>ACTIVE_STATEMENTS</codeph> slots are in use, and each query can set an
        arbitrarily high <codeph>statement_mem</codeph>. This could lead to a resource queue using
        unbounded amounts of memory.</p>
      <p>For more information on configuring memory limits on a resource queue, and other memory
        utilization controls, see <xref href="#topic12" type="topic" format="dita"/>.</p>
    <section id="topic113x" xml:lang="en">
      <title>statement_mem and Low Memory Queries</title>
        <p>A low <codeph>statement_mem</codeph> setting (for example, in the 
          1-3MB range) has been shown
          to increase the performance of queries with low memory requirements. Use
          the <codeph>statement_mem</codeph> server configuration parameter to
          override the setting on a per-query basis. For example:
          <codeblock>SET statement_mem='2MB';</codeblock></p>
    </section>
    </body>
  </topic>
  <topic id="priorities">
    <title>How Priorities Work</title>
    <body>
      <p>The <codeph>PRIORITY</codeph> setting for a resource queue differs from the
          <codeph>MEMORY_LIMIT</codeph> and <codeph>ACTIVE_STATEMENTS</codeph> settings, which
        determine whether a query will be admitted to the queue and eventually executed. The
          <codeph>PRIORITY</codeph> setting applies to queries after they become active. Active
        queries share available CPU resources as determined by the priority settings for its
        resource queue. When a statement from a high-priority queue enters the group of actively
        running statements, it may claim a greater share of the available CPU, reducing the share
        allocated to already-running statements in queues with a lesser priority setting.</p>
      <p>The comparative size or complexity of the queries does not affect the allotment of CPU. If
        a simple, low-cost query is running simultaneously with a large, complex query, and their
        priority settings are the same, they will be allocated the same share of available CPU
        resources. When a new query becomes active, the CPU shares will be recalculated, but queries
        of equal priority will still have equal amounts of CPU. </p>
      <p>For example, an administrator creates three resource queues: <i>adhoc</i> for ongoing
        queries submitted by business analysts, <i>reporting</i> for scheduled reporting jobs, and
          <i>executive</i> for queries submitted by executive user roles. The administrator wants to
        ensure that scheduled reporting jobs are not heavily affected by unpredictable resource
        demands from ad-hoc analyst queries. Also, the administrator wants to make sure that queries
        submitted by executive roles are allotted a significant share of CPU. Accordingly, the
        resource queue priorities are set as shown:<ul id="ul_ppy_3cy_wq">
          <li id="iz160250"><i>adhoc</i> — Low priority</li>
          <li id="iz161065"><i>reporting</i> — High priority</li>
          <li id="iz161070"><i>executive</i> — Maximum priority</li>
        </ul></p>
      <p>At runtime, the CPU share of active statements is determined by these priority settings. If
        queries 1 and 2 from the reporting queue are running simultaneously, they have equal shares
        of CPU. When an ad-hoc query becomes active, it claims a smaller share of CPU. The exact
        share used by the reporting queries is adjusted, but remains equal due to their equal
        priority setting:</p>
      <fig id="iz173993">
        <title>CPU share readjusted according to priority</title>
        <image href="graphics/gp_query_priority1.png" placement="break" width="432px" height="298px"
          id="image_lgv_lcy_wq"/>
      </fig>
      <note type="note">
        <p>The percentages shown in these illustrations are approximate. CPU usage between high, low
          and maximum priority queues is not always calculated in precisely these proportions.</p>
      </note>
      <p>When an executive query enters the group of running statements, CPU usage is adjusted to
        account for its maximum priority setting. It may be a simple query compared to the analyst
        and reporting queries, but until it is completed, it will claim the largest share of
        CPU.</p>
      <fig id="iz160829">
        <title>CPU share readjusted for maximum priority query</title>
        <image href="graphics/gp_query_priority2.png" placement="break" width="194px" height="305px"
          id="image_lrr_ddy_wq"/>
      </fig>
      <p>For more information about commands to set priorities, see <xref href="#topic16"
          type="topic" format="dita"/>.</p>
    </body>
  </topic>

  <topic id="topic8" xml:lang="en">
    <title id="iz153124">Steps to Enable Resource Management</title>
    <body>
      <p>Enabling and using resource management in Greenplum Database involves the following
        high-level tasks:</p>
      <ol id="ol_ec5_4dy_wq">
        <li>Configure resource management. See <xref href="#topic9" format="dita"/>.</li>
        <li id="iz153167">Create the resource queues and set limits on them. See <xref
            href="#topic10" type="topic" format="dita"/> and <xref href="#topic19" format="dita"
          />.</li>
        <li id="iz153172">Assign a queue to one or more user roles. See <xref href="#topic17"
            type="topic" format="dita"/>.</li>
        <li id="iz153188">Use the resource management system views to monitor and manage the
          resource queues. See <xref href="#topic22" type="topic" format="dita"/>.</li>
      </ol>
    </body>
  </topic>
  <topic id="topic9" xml:lang="en">
    <title id="iz139711">Configuring Resource Management</title>
    <body>
      <p>Resource scheduling is enabled by default when you install Greenplum Database, and is
        required for all roles. The default resource queue, <codeph>pg_default</codeph>, has an
        active statement limit of 20, no memory limit, and a medium priority setting. Create
        resource queues for the various types of workloads.</p>
      <section id="iz169600">
        <title>To configure resource management</title>
        <ol>
          <li id="iz169263">The following parameters are for the general configuration of resource
              queues:<ul id="ul_gln_v3c_34">
              <li id="iz152506"><codeph>max_resource_queues</codeph> - Sets the maximum number of
                resource queues.</li>
              <li id="iz153405"><codeph>max_resource_portals_per_transaction</codeph> - Sets the
                maximum number of simultaneously open cursors allowed per transaction. Note that an
                open cursor will hold an active query slot in a resource queue.</li>
              <li id="iz154513"><codeph>resource_select_only</codeph> - If set to <i>on</i>, then
                  <codeph>SELECT</codeph>, <codeph>SELECT INTO</codeph>, <codeph>CREATE TABLE
                  AS</codeph><codeph>SELECT</codeph>, and <codeph>DECLARE CURSOR</codeph> commands
                are evaluated. If set to <i>off</i><codeph>INSERT</codeph><ph>,
                    <codeph>UPDATE</codeph>, and <codeph>DELETE</codeph></ph> commands will be
                evaluated as well.</li>
              <li id="iz157925"><codeph>resource_cleanup_gangs_on_wait</codeph> - Cleans up idle
                segment worker processes before taking a slot in the resource queue.</li>
              <li id="iz156657"><codeph>stats_queue_level</codeph> - Enables statistics collection
                on resource queue usage, which can then be viewed by querying the pg_stat_resqueues
                system view.</li>
            </ul></li>
          <li id="iz169478">The following parameters are related to memory utilization:<ul
              id="ul_ehc_w3c_34">
              <li id="iz172344"><codeph>gp_resqueue_memory_policy</codeph> - Enables Greenplum
                Database memory management features. <p>In Greenplum Database<ph> 4.2 and
                  later</ph>, the distribution algorithm <codeph>eager_free</codeph> takes advantage
                  of the fact that not all operators execute at the same time. The query plan is
                  divided into stages and Greenplum Database eagerly frees memory allocated to a
                  previous stage at the end of that stage's execution, then allocates the eagerly
                  freed memory to the new stage.</p><p><ph>When set to <codeph>none</codeph>, memory
                    management is the same as in Greenplum Database releases prior to 4.1. </ph>When
                  set to <codeph>auto</codeph>, query memory usage is controlled by
                    <codeph>statement_mem</codeph> and resource queue memory limits. </p></li>
              <li id="iz172366"><codeph>statement_mem</codeph> and
                  <codeph>max_statement_mem</codeph> - Used to allocate memory to a particular query
                at runtime (override the default allocation assigned by the resource queue).
                  <codeph>max_statement_mem</codeph> is set by database superusers to prevent
                regular database users from over-allocation.</li>
              <li id="iz169494"><codeph>gp_vmem_protect_limit</codeph> - Sets the upper boundary
                that all query processes can consume and should not exceed the amount of physical
                memory of a segment host. When a segment host reaches this limit during query
                execution, the queries that cause the limit to be exceeded will be cancelled. </li>
              <li id="iz169556"><codeph>gp_vmem_idle_resource_timeout</codeph> and
                  <codeph>gp_vmem_protect_segworker_cache_limit</codeph> - used to free memory on
                segment hosts held by idle database processes. Administrators may want to adjust
                these settings on systems with lots of concurrency.</li>
              <li><codeph>shared_buffers</codeph> - Sets the amount of memory a Greenplum server
                instance uses for shared memory buffers. This setting must be at least 128 kilobytes
                and at least 16 kilobytes times <codeph>max_connections</codeph>. The value must not
                exceed the operating system shared memory maximum allocation request size,
                  <codeph>shmmax</codeph> on Linux. See the <i>Greenplum Database Installation
                  Guide</i> for recommended OS memory settings for your platform.</li>
            </ul></li>
          <li id="iz169487">The following parameters are related to query prioritization. Note that
            the following parameters are all <i>local</i> parameters, meaning they must be set in
            the <codeph>postgresql.conf</codeph> files of the master and all segments:<ul
              id="ul_lm2_x3c_34">
              <li id="iz158643"><codeph>gp_resqueue_priority</codeph> - The query prioritization
                feature is enabled by default.</li>
              <li id="iz158644"><codeph>gp_resqueue_priority_sweeper_interval</codeph> - Sets the
                interval at which CPU usage is recalculated for all active statements. The default
                value for this parameter should be sufficient for typical database operations. </li>
              <li id="iz174445"><codeph>gp_resqueue_priority_cpucores_per_segment</codeph> -
                Specifies the number of CPU cores allocated per segment instance. The default value
                is 4 for the master and segments. <p>Each host checks its
                  own <codeph>postgresql.conf</codeph> file for the value of this parameter. This
                  parameter also affects the master node, where it should be set to a value
                  reflecting the higher ratio of CPU cores. For example, on a cluster that has 10
                  CPU cores per host and 4 segments per host, you would specify these values for
                    <codeph>gp_resqueue_priority_cpucores_per_segment</codeph>:</p><p>10 for the
                  master and standby master. Typically, only the master instance is on the master
                  host.</p><p>2.5 for segment instances on the segment hosts. </p><p>If the
                  parameter value is not set correctly, either the CPU might not be fully utilized,
                  or query prioritization might not work as expected. For example, if the Greenplum
                  Database cluster has fewer than one segment instance per CPU core on your segment
                  hosts, make sure you adjust this value accordingly. </p><p>Actual CPU core
                  utilization is based on the ability of Greenplum Database to parallelize a query
                  and the resources required to execute the query. </p><p>Note: Any CPU core that is
                  available to the operating system is included in the number of CPU cores. For
                  example, virtual CPU cores are included in the number of CPU cores.</p></li>
            </ul></li>
          <li id="iz171977">If you wish to view or change any of the resource management parameter
            values, you can use the <codeph>gpconfig</codeph> utility. </li>
          <li id="iz169849">For example, to see the setting of a particular parameter:<p>
              <codeblock>$ gpconfig --show gp_vmem_protect_limit
</codeblock>
            </p></li>
          <li id="iz169838">For example, to set one value on all segment instances and a different
            value on the master:<p>
              <codeblock>$ gpconfig -c gp_resqueue_priority_cpucores_per_segment -v 2 -m 8
</codeblock>
            </p></li>
          <li id="iz169522">Restart Greenplum Database to make the configuration changes effective:<p>
              <codeblock>$ gpstop -r
</codeblock>
            </p></li>
        </ol>
      </section>
    </body>
  </topic>
  <topic id="topic10" xml:lang="en">
    <title id="iz139857">Creating Resource Queues</title>
    <body>
      <p>Creating a resource queue involves giving it a name, setting an active query limit, and
        optionally a query priority on the resource queue. Use the <codeph>CREATE RESOURCE
          QUEUE</codeph> command to create new resource queues. </p>
    </body>
    <topic id="topic11" xml:lang="en">
      <title>Creating Queues with an Active Query Limit</title>
      <body>
        <p id="iz152723">Resource queues with an <codeph>ACTIVE_STATEMENTS</codeph> setting limit
          the number of queries that can be executed by roles assigned to that queue. For example,
          to create a resource queue named <i>adhoc</i> with an active query limit of three:</p>
        <p>
          <codeblock>=# CREATE RESOURCE QUEUE adhoc WITH (ACTIVE_STATEMENTS=3);
</codeblock>
        </p>
        <p>This means that for all roles assigned to the <i>adhoc</i> resource queue, only three
          active queries can be running on the system at any given time. If this queue has three
          queries running, and a fourth query is submitted by a role in that queue, that query must
          wait until a slot is free before it can run.</p>
      </body>
    </topic>
    <topic id="topic12" xml:lang="en">
      <title id="iz162725">Creating Queues with Memory Limits</title>
      <body>
        <p>Resource queues with a <codeph>MEMORY_LIMIT</codeph><ph> setting control the amount of
            memory for all the queries submitted through the queue. The total memory should not
            exceed the physical memory available per-segment. Set </ph><codeph>MEMORY_LIMIT</codeph>
          to 90% of memory available on a per-segment basis. For example, if a host has 48 GB of
          physical memory and 6 segment instances, then the memory available per segment instance is
          8 GB. You can calculate the recommended <codeph>MEMORY_LIMIT</codeph> for a single queue
          as 0.90*8=7.2 GB. If there are multiple queues created on the system, their total memory
          limits must also add up to 7.2 GB.</p>
        <p>When used in conjunction with <codeph>ACTIVE_STATEMENTS</codeph>, the default amount of
          memory allotted per query is: <codeph>MEMORY_LIMIT</codeph><codeph> /
            </codeph><codeph>ACTIVE_STATEMENTS</codeph>. When used in conjunction with
            <codeph>MAX_COST</codeph>, the default amount of memory allotted per query is:
            <codeph>MEMORY_LIMIT * (query_cost <codeph>/ </codeph>MAX_COST)</codeph>. Use
            <codeph>MEMORY_LIMIT</codeph> in conjunction with <codeph>ACTIVE_STATEMENTS</codeph>
          rather than with <codeph>MAX_COST</codeph>.</p>
        <p>For example, to create a resource queue with an active query limit of 10 and a total
          memory limit of 2000MB (each query will be allocated 200MB of segment host memory at
          execution time): </p>
        <p>
          <codeblock>=# CREATE RESOURCE QUEUE myqueue WITH (ACTIVE_STATEMENTS=20, 
MEMORY_LIMIT='2000MB');
</codeblock>
        </p>
        <p>The default memory allotment can be overridden on a per-query basis using the
            <codeph>statement_mem</codeph> server configuration parameter, provided that
            <codeph>MEMORY_LIMIT</codeph> or <codeph>max_statement_mem</codeph> is not exceeded. For
          example, to allocate more memory to a particular query:</p>
        <codeblock>=&gt; SET statement_mem='2GB';
=&gt; SELECT * FROM my_big_table WHERE column='value' ORDER BY id;
=&gt; RESET statement_mem;
</codeblock>
        <p>As a general guideline, <codeph>MEMORY_LIMIT</codeph> for all of your resource queues
          should not exceed the amount of physical memory of a segment host. If workloads are
          staggered over multiple queues, it may be OK to oversubscribe memory allocations, keeping
          in mind that queries may be cancelled during execution if the segment host memory limit
            (<codeph>gp_vmem_protect_limit</codeph>) is exceeded.</p>
      </body>
    </topic>
    <topic id="topic16" xml:lang="en">
      <title id="iz158491">Setting Priority Levels</title>
      <body>
        <p>To control a resource queue's consumption of available CPU resources, an administrator
          can assign an appropriate priority level. When high concurrency causes contention for CPU
          resources, queries and statements associated with a high-priority resource queue will
          claim a larger share of available CPU than lower priority queries and statements. </p>
        <p>Priority settings are created or altered using the <codeph>WITH</codeph> parameter of the
          commands <codeph>CREATE RESOURCE QUEUE</codeph> and <codeph>ALTER RESOURCE QUEUE</codeph>.
          For example, to specify priority settings for the <i>adhoc</i> and <i>reporting</i>
          queues, an administrator would use the following commands: </p>
        <codeblock>=# ALTER RESOURCE QUEUE adhoc WITH (PRIORITY=LOW);
=# ALTER RESOURCE QUEUE reporting WITH (PRIORITY=HIGH);</codeblock>
        <p>To create the <i>executive</i> queue with maximum priority, an administrator would use
          the following command:</p>
        <codeblock>=# CREATE RESOURCE QUEUE executive WITH (ACTIVE_STATEMENTS=3, PRIORITY=MAX);</codeblock>
        <p>When the query prioritization feature is enabled, resource queues are given a
            <codeph>MEDIUM</codeph> priority by default if not explicitly assigned. For more
          information on how priority settings are evaluated at runtime, see <xref
            href="#priorities" type="topic" format="dita"/>.</p>
        <note type="important">In order for resource queue priority levels to be enforced on the
          active query workload, you must enable the query prioritization feature by setting the
          associated server configuration parameters. See <xref href="#topic9" type="topic"
            format="dita"/>.</note>
      </body>
    </topic>
  </topic>
  <topic id="topic17" xml:lang="en">
    <title id="iz172210">Assigning Roles (Users) to a Resource Queue</title>
    <body>
      <p id="iz172211">Once a resource queue is created, you must assign roles (users) to their
        appropriate resource queue. If roles are not explicitly assigned to a resource queue, they
        will go to the default resource queue, <codeph>pg_default</codeph>. The default resource
        queue has an active statement limit of 20, no cost limit, and a medium priority setting.</p>
      <p>Use the <codeph>ALTER ROLE</codeph> or <codeph>CREATE ROLE</codeph> commands to assign a
        role to a resource queue. For example:</p>
      <p>
        <codeblock>=# ALTER ROLE <codeph>name</codeph> RESOURCE QUEUE <codeph>queue_name</codeph>;
=# CREATE ROLE <codeph>name</codeph> WITH LOGIN RESOURCE QUEUE <codeph>queue_name</codeph>;
</codeblock>
      </p>
      <p>A role can only be assigned to one resource queue at any given time, so you can use the
          <codeph>ALTER ROLE</codeph> command to initially assign or change a role's resource queue. </p>
      <p>Resource queues must be assigned on a user-by-user basis. If you have a role hierarchy (for
        example, a group-level role) then assigning a resource queue to the group does not propagate
        down to the users in that group.</p>
      <p id="iz153606">Superusers are always exempt from resource queue limits. Superuser queries
        will always run regardless of the limits set on their assigned queue.</p>
    </body>
    <topic id="topic18" xml:lang="en">
      <title id="iz153619">Removing a Role from a Resource Queue</title>
      <body>
        <p>All users <i>must</i> be assigned to a resource queue. If not explicitly assigned to a
          particular queue, users will go into the default resource queue,
            <codeph>pg_default</codeph>. If you wish to remove a role from a resource queue and put
          them in the default queue, change the role's queue assignment to <codeph>none</codeph>.
          For example:</p>
        <p>
          <codeblock>=# ALTER ROLE <codeph>role_name</codeph> RESOURCE QUEUE none;
</codeblock>
        </p>
      </body>
    </topic>
  </topic>
  <topic id="topic19" xml:lang="en">
    <title id="iz151541">Modifying Resource Queues</title>
    <body>
      <p>After a resource queue has been created, you can change or reset the queue limits using the
          <codeph>ALTER RESOURCE QUEUE</codeph> command. You can remove a resource queue using the
          <codeph>DROP RESOURCE QUEUE</codeph> command. To change the roles (users) assigned to a
        resource queue, <xref href="#topic17" type="topic" format="dita"/>.</p>
    </body>
    <topic id="topic20" xml:lang="en">
      <title>Altering a Resource Queue</title>
      <body>
        <p>The <codeph>ALTER RESOURCE QUEUE</codeph> command changes the limits of a resource queue.
          To change the limits of a resource queue, specify the new values you want for the queue.
          For example:</p>
        <p>
          <codeblock>=# ALTER RESOURCE QUEUE <i>adhoc</i> WITH (ACTIVE_STATEMENTS=5);
=# ALTER RESOURCE QUEUE <i>exec</i> WITH (PRIORITY=MAX);
</codeblock>
        </p>
        <p>To reset active statements or memory limit to no limit, enter a value of
            <codeph>-1</codeph>. To reset the maximum query cost to no limit, enter a value of
            <codeph>-1.0</codeph>. For example:</p>
        <p>
          <codeblock>=# ALTER RESOURCE QUEUE <i>adhoc</i> WITH (MAX_COST=-1.0, MEMORY_LIMIT='2GB');
</codeblock>
        </p>
        <p>You can use the <codeph>ALTER RESOURCE QUEUE</codeph> command to change the priority of
          queries associated with a resource queue. For example, to set a queue to the minimum
          priority level:</p>
        <p>
          <codeblock>ALTER RESOURCE QUEUE <i>webuser</i> WITH (PRIORITY=MIN);
</codeblock>
        </p>
      </body>
    </topic>
    <topic id="topic21" xml:lang="en">
      <title>Dropping a Resource Queue</title>
      <body>
        <p>The <codeph>DROP RESOURCE QUEUE</codeph> command drops a resource queue. To drop a
          resource queue, the queue cannot have any roles assigned to it, nor can it have any
          statements waiting in the queue. See <xref href="#topic18" type="topic" format="dita"/>
          and <xref href="#topic27" type="topic" format="dita"/> for instructions on emptying a
          resource queue. To drop a resource queue:</p>
        <p>
          <codeblock>=# DROP RESOURCE QUEUE <i>name</i>;
</codeblock>
        </p>
      </body>
    </topic>
  </topic>
  <topic id="topic22" xml:lang="en">
    <title id="iz151530">Checking Resource Queue Status</title>
    <body>
      <p>Checking resource queue status involves the following tasks:</p>
      <ul>
        <li id="iz153671">
          <xref href="#topic23" type="topic" format="dita"/>
        </li>
        <li id="iz156749">
          <xref href="#topic24" type="topic" format="dita"/>
        </li>
        <li id="iz153679">
          <xref href="#topic25" type="topic" format="dita"/>
        </li>
        <li id="iz153684">
          <xref href="#topic26" type="topic" format="dita"/>
        </li>
        <li id="iz153700">
          <xref href="#topic27" type="topic" format="dita"/>
        </li>
        <li id="iz159212">
          <xref href="#topic28" type="topic" format="dita"/>
        </li>
        <li id="iz159217">
          <xref href="#topic29" type="topic" format="dita"/>
        </li>
      </ul>
    </body>

    <topic id="topic23" xml:lang="en">
      <title id="iz151568">Viewing Queued Statements and Resource Queue Status</title>
      <body>
        <p>The <codeph>gp_toolkit.gp_resqueue_status</codeph> view allows administrators to see
          status and activity for a resource queue. It shows how many queries
          are waiting to run and how many queries are currently active in the system from a
          particular resource queue. To see the resource queues created in the system, their limit
          attributes, and their current status:</p>
        <p>
          <codeblock>=# SELECT * FROM gp_toolkit.gp_resqueue_status;
</codeblock>
        </p>
      </body>
    </topic>
    <topic id="topic24" xml:lang="en">
      <title id="iz156744">Viewing Resource Queue Statistics</title>
      <body>
        <p>If you want to track statistics and performance of resource queues over time, you can
          enable statistics collecting for resource queues. This is done by setting the following
          server configuration parameter in your master <codeph>postgresql.conf</codeph> file:</p>
        <p>
          <codeblock>stats_queue_level = on
</codeblock>
        </p>
        <p>Once this is enabled, you can use the <codeph>pg_stat_resqueues</codeph> system view to
          see the statistics collected on resource queue usage. Note that enabling this feature does
          incur slight performance overhead, as each query submitted through a resource queue must
          be tracked. It may be useful to enable statistics collecting on resource queues for
          initial diagnostics and administrative planning, and then disable the feature for
          continued use.</p>
        <p>See the Statistics Collector section in the PostgreSQL documentation for more information
          about collecting statistics in Greenplum Database.</p>
      </body>
    </topic>
    <topic id="topic25" xml:lang="en">
      <title id="iz152239">Viewing the Roles Assigned to a Resource Queue</title>
      <body>
        <p>To see the roles assigned to a resource queue, perform the following query of the
            <codeph>pg_roles</codeph> and
            <codeph>gp_toolkit.</codeph><codeph>gp_resqueue_status</codeph> system catalog
          tables:</p>
        <p>
          <codeblock>=# SELECT rolname, rsqname FROM pg_roles, 
          gp_toolkit.gp_resqueue_status 
   WHERE pg_roles.rolresqueue=gp_toolkit.gp_resqueue_status.queueid;
</codeblock>
        </p>
        <p>You may want to create a view of this query to simplify future inquiries. For
          example:</p>
        <p>
          <codeblock>=# CREATE VIEW role2queue AS
   SELECT rolname, rsqname FROM pg_roles, pg_resqueue 
   WHERE pg_roles.rolresqueue=gp_toolkit.gp_resqueue_status.queueid;
</codeblock>
        </p>
        <p>Then you can just query the view:</p>
        <p>
          <codeblock>=# SELECT * FROM role2queue;
</codeblock>
        </p>
      </body>
    </topic>
    <topic id="topic26" xml:lang="en">
      <title id="iz151577">Viewing the Waiting Queries for a Resource Queue</title>
      <body>
        <p>When a slot is in use for a resource queue, it is recorded in the
            <codeph>pg_locks</codeph> system catalog table. This is where you can see all of the
          currently active and waiting queries for all resource queues. To check that statements are
          being queued (even statements that are not waiting), you can also use the
            <codeph>gp_toolkit</codeph>.gp_locks_on_resqueue view. For example:</p>
        <p>
          <codeblock>=# SELECT * FROM gp_toolkit.gp_locks_on_resqueue WHERE lorwaiting='true';
</codeblock>
        </p>
        <p>If this query returns no results, then that means there are currently no statements
          waiting in a resource queue.</p>
      </body>
    </topic>
    <topic id="topic27" xml:lang="en">
      <title id="iz153732">Clearing a Waiting Statement From a Resource Queue</title>
      <body>
        <p>In some cases, you may want to clear a waiting statement from a resource queue. For
          example, you may want to remove a query that is waiting in the queue but has not been
          executed yet. You may also want to stop a query that has been started if it is taking too
          long to execute, or if it is sitting idle in a transaction and taking up resource queue
          slots that are needed by other users. To do this, you must first identify the statement
          you want to clear, determine its process id (pid), and then, use
            <codeph>pg_cancel_backend</codeph> with the process id to end that process, as shown
          below. An optional message to the process can be passed as the second parameter, to
          indicate to the user why the process was cancelled.</p>
        <p>For example, to see process information about all statements currently active or waiting
          in all resource queues, run the following query:</p>
        <p>
          <codeblock>=# SELECT rolname, rsqname, pg_locks.pid as pid, granted, state,
          query, datname 
   FROM pg_roles, gp_toolkit.gp_resqueue_status, pg_locks,
        pg_stat_activity 
   WHERE pg_roles.rolresqueue=pg_locks.objid 
   AND pg_locks.objid=gp_toolkit.gp_resqueue_status.queueid
   AND pg_stat_activity.pid=pg_locks.pid
   AND pg_stat_activity.usename=pg_roles.rolname;
</codeblock>
        </p>
        <p>If this query returns no results, then that means there are currently no statements in a
          resource queue. A sample of a resource queue with two statements in it looks something
          like this:</p>
        <codeblock>rolname | rsqname |  pid  | granted | state  |         query          | datname 
--------+---------+-------+---------+--------+------------------------+--------- 
  sammy | webuser | 31861 | t       | idle   | SELECT * FROM testtbl; | namesdb
  daria | webuser | 31905 | f       | active | SELECT * FROM topten;  | namesdb</codeblock>
        <p>Use this output to identify the process id (pid) of the statement you want to clear from
          the resource queue. To clear the statement, you would then open a terminal window (as the
            <codeph>gpadmin</codeph> database superuser or as root) on the master host and cancel
          the corresponding process. For example:</p>
        <p>
          <codeblock>=# pg_cancel_backend(31905)
</codeblock>
        </p>
        <note type="important">Do not use the operating system <codeph>KILL</codeph> command.</note>
      </body>
    </topic>
    <topic id="topic28" xml:lang="en">
      <title id="iz164264">Viewing the Priority of Active Statements</title>
      <body>
        <p>The <i>gp_toolkit</i> administrative schema has a view called
            <i>gp_resq_priority_statement</i>, which lists all statements currently being executed
          and provides the priority, session ID, and other information.</p>
        <p>This view is only available through the <codeph>gp_toolkit</codeph> administrative
          schema. <ph>See the <i>Greenplum Database Reference Guide</i> for more
          information.</ph></p>
      </body>
    </topic>
    <topic id="topic29" xml:lang="en">
      <title id="iz166568">Resetting the Priority of an Active Statement</title>
      <body>
        <p>Superusers can adjust the priority of a statement currently being executed using the
          built-in function <codeph>gp_adjust_priority(session_id, statement_count,
            priority)</codeph>. Using this function, superusers can raise or lower the priority of
          any query. For example:</p>
        <p>
          <codeph>=# SELECT gp_adjust_priority(752, 24905, 'HIGH')</codeph>
        </p>
        <p>To obtain the session ID and statement count parameters required by this function,
          superusers can use the <codeph>gp_toolkit</codeph> administrative schema view,
            <i>gp_resq_priority_statement</i>. From the view, use these values for the function
          parameters.</p>
        <ul>
          <li id="iz174657">The value of the <codeph>rqpsession</codeph> column for the
              <codeph>session_id</codeph> parameter</li>
          <li id="iz174658">The value of the <codeph>rqpcommand</codeph> column for the
              <codeph>statement_count</codeph> parameter</li>
          <li id="iz174659">The value of <codeph>rqppriority</codeph> column is the current
            priority. You can specify a string value of <codeph>MAX</codeph>, <codeph>HIGH</codeph>,
              <codeph>MEDIUM</codeph>, or <codeph>LOW</codeph> as the <codeph>priority</codeph>.
          </li>
        </ul>
        <note type="note">The <codeph>gp_adjust_priority()</codeph> function affects only the
          specified statement. Subsequent statements in the same resource queue are executed using
          the queue's normally assigned priority.</note>
      </body>
    </topic>
  </topic>
</topic>
