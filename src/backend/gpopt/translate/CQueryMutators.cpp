//---------------------------------------------------------------------------
//	Greenplum Database
//	Copyright (C) 2012 EMC Corp.
//
//	@filename:
//		CQueryMutators.cpp
//
//	@doc:
//		Implementation of methods used during translating a GPDB Query object into a
//		DXL Tree
//
//	@test:
//
//---------------------------------------------------------------------------

#include "postgres.h"

#include "nodes/plannodes.h"
#include "nodes/parsenodes.h"
#include "nodes/makefuncs.h"
#include "optimizer/walkers.h"

#include "gpopt/base/CUtils.h"
#include "gpopt/mdcache/CMDAccessor.h"
#include "gpopt/mdcache/CMDAccessorUtils.h"
#include "gpopt/translate/CQueryMutators.h"
#include "gpopt/translate/CTranslatorDXLToPlStmt.h"

#include "naucrates/md/IMDScalarOp.h"
#include "naucrates/md/IMDAggregate.h"
#include "naucrates/md/IMDTypeBool.h"

#include "gpopt/gpdbwrappers.h"

using namespace gpdxl;
using namespace gpmd;

//---------------------------------------------------------------------------
//	@function:
//		CQueryMutators::NeedsProjListNormalization
//
//	@doc:
//		Is the group by project list flat (contains only aggregates
//		and grouping columns)
//---------------------------------------------------------------------------
BOOL
CQueryMutators::NeedsProjListNormalization
	(
	const Query *query
	)
{
	if (!query->hasAggs && NULL == query->groupClause)
	{
		return false;
	}

	SContextTLWalker context(query->targetList, query->groupClause);

	ListCell *lc = NULL;
	ForEach (lc, query->targetList)
	{
		TargetEntry *target_entry  = (TargetEntry*) lfirst(lc);

		if (ShouldFallback((Node *) target_entry->expr, &context))
		{
			// TODO: remove temporary fix (revert exception to assert) to avoid crash during algebrization
			GPOS_RAISE(gpdxl::ExmaDXL, gpdxl::ExmiQuery2DXLError, GPOS_WSZ_LIT("No attribute"));
		}

		// Normalize when there is an expression that is neither used for grouping
		// nor is an aggregate function
		if (!IsA(target_entry->expr, Aggref) && !IsA(target_entry->expr, GroupingFunc) && !CTranslatorUtils::IsGroupingColumn( (Node*) target_entry->expr, query->groupClause, query->targetList))
		{
			return true;
		}
	}

	return false;
}


//---------------------------------------------------------------------------
//	@function:
//		CQueryMutators::ShouldFallback
//
//	@doc:
//		Fall back when the target list refers to a attribute which algebrizer
//		at this point cannot resolve
//---------------------------------------------------------------------------
BOOL
CQueryMutators::ShouldFallback
	(
	Node *node,
	SContextTLWalker *context
	)
{
	if (NULL == node)
	{
		return false;
	}

	if (IsA(node, Const) || IsA(node, Aggref) || IsA(node, GroupingFunc) || IsA(node, SubLink))
	{
		return false;
	}

	TargetEntry *entry = gpdb::FindFirstMatchingMemberInTargetList(node, context->m_target_entries);
	if (NULL != entry && CTranslatorUtils::IsGroupingColumn( (Node *) entry->expr, context->m_group_clause, context->m_target_entries))
	{
		return false;
	}

	if (IsA(node, SubLink))
	{
		return false;
	}

	if (IsA(node, Var))
	{
		Var *var = (Var *) node;
		if (0 == var->varlevelsup)
		{
			// if we reach a Var that was not a grouping column then there is an equivalent column
			// which the algebrizer at this point cannot resolve
			// example: consider two table r(a,b) and s(c,d) and the following query
			// SELECT a from r LEFT JOIN s on (r.a = s.c) group by r.a
			// In the query object, generated by the parse, the output columns refer to the output of
			// the left outer join while the grouping column refers to the base table column.
			// While r.a and a are equivalent, the algebrizer at this point cannot detect this.
			// Therefore, we fall back.
			return true;
		}

		return false;
	}

	return gpdb::WalkExpressionTree(node, (FallbackWalkerFn) CQueryMutators::ShouldFallback, context);
}


//---------------------------------------------------------------------------
//	@function:
//		CQueryMutators::NormalizeGroupByProjList
//
//	@doc:
// 		Flatten expressions in project list to contain only aggregates and
//		grouping columns
//		ORGINAL QUERY:
//			SELECT * from r where r.a > (SELECT max(c) + min(d) FROM t where r.b = t.e)
// 		NEW QUERY:
//			SELECT * from r where r.a > (SELECT x1+x2 as x3
//										 FROM (SELECT max(c) as x2, min(d) as x2
//											   FROM t where r.b = t.e) t2)
//---------------------------------------------------------------------------
Query *
CQueryMutators::NormalizeGroupByProjList
	(
	CMemoryPool *mp,
	CMDAccessor *md_accessor,
	const Query *query
	)
{
	Query *query_copy = (Query *) gpdb::CopyObject(const_cast<Query*>(query));

	if (!NeedsProjListNormalization(query_copy))
	{
		return query_copy;
	}

	Query *new_query = ConvertToDerivedTable(query_copy, false /*should_fix_target_list*/, true /*should_fix_having_qual*/);
	gpdb::GPDBFree(query_copy);

	GPOS_ASSERT(1 == gpdb::ListLength(new_query->rtable));
	Query *derived_table_query = (Query *) ((RangeTblEntry *) gpdb::ListNth(new_query->rtable, 0))->subquery;
	SContextGrpbyPlMutator context(mp, md_accessor, derived_table_query, NULL);
	List *target_list_copy = (List*) gpdb::CopyObject(derived_table_query->targetList);
	ListCell *lc = NULL;

	// first normalize grouping columns
	ForEach (lc, target_list_copy)
	{
		TargetEntry *target_entry  = (TargetEntry*) lfirst(lc);
		GPOS_ASSERT(NULL != target_entry);

		if (CTranslatorUtils::IsGroupingColumn(target_entry, derived_table_query->groupClause))
		{
			target_entry->expr = (Expr*) FixGroupingCols( (Node*) target_entry->expr, target_entry, &context);
		}
	}

	lc = NULL;
	// normalize remaining project elements
	ForEach (lc, target_list_copy)
	{
		TargetEntry *target_entry  = (TargetEntry*) lfirst(lc);
		GPOS_ASSERT(NULL != target_entry);

		BOOL is_grouping_col = CTranslatorUtils::IsGroupingColumn(target_entry, derived_table_query->groupClause);
		if (!is_grouping_col)
		{
			target_entry->expr = (Expr*) RunExtractAggregatesMutator((Node*) target_entry->expr, &context);
			GPOS_ASSERT
				(
				!IsA(target_entry->expr, Aggref) && !IsA(target_entry->expr, GroupingFunc) &&
				"New target list entry should not contain any Aggrefs"
				);
		}
	}

	derived_table_query->targetList = context.m_groupby_tlist;
	new_query->targetList = target_list_copy;

	ReassignSortClause(new_query, derived_table_query);

	return new_query;
}

//---------------------------------------------------------------------------
//	@function:
//		CQueryMutators::RunIncrLevelsUpMutator
//
//	@doc:
//		Increment any the query levels up of any outer reference by one
//---------------------------------------------------------------------------
Node *
CQueryMutators::RunIncrLevelsUpMutator
	(
	Node *node,
	SContextIncLevelsupMutator *context
	)
{
	if (NULL == node)
	{
		return NULL;
	}

	if (IsA(node, Var))
	{
		Var *var = (Var *) gpdb::CopyObject(node);

		// Consider the following use case:
		//	ORGINAL QUERY:
		//		SELECT * from r where r.a > (SELECT max(c) + min(d)
		//									 FROM t where r.b = t.e)
		// NEW QUERY:
		//		SELECT * from r where r.a > (SELECT x1+x2 as x3
		//									 FROM (SELECT max(c) as x2, min(d) as x2
		//										   FROM t where r.b = t.e) t2)
		//
		// In such a scenario, we need increment the levels up for the
		// correlation variable r.b in the subquery by 1.

		if (var->varlevelsup > context->m_current_query_level)
		{
			var->varlevelsup++;
			return (Node *) var;
		}
		return (Node *) var;
	}

	if (IsA(node, CommonTableExpr))
	{
		CommonTableExpr *cte = (CommonTableExpr *) gpdb::CopyObject(node);
		GPOS_ASSERT(IsA(cte->ctequery, Query));

		Query *cte_query = (Query *) cte->ctequery;

		context->m_current_query_level++;
		cte->ctequery = RunIncrLevelsUpMutator((Node *) cte_query, context);
		context->m_current_query_level--;

		gpdb::GPDBFree(cte_query);

		return (Node *) cte;
	}

	if (IsA(node, SubLink))
	{
		SubLink *sublink = (SubLink *) gpdb::CopyObject(node);
		GPOS_ASSERT(IsA(sublink->subselect, Query));

		Query *sublink_query = (Query *) sublink->subselect;

		context->m_current_query_level++;
		sublink->subselect = RunIncrLevelsUpMutator( (Node *) sublink_query, context);
		context->m_current_query_level--;
		gpdb::GPDBFree(sublink_query);

		return (Node *) sublink;
	}

	if (IsA(node, TargetEntry) && 0 == context->m_current_query_level && !context->m_should_fix_top_level_target_list)
	{
		return (Node *) gpdb::CopyObject(node);
	}

	// recurse into query structure
	if (IsA(node, Query))
	{
		Query *query = gpdb::MutateQueryTree
								(
								(Query *) node,
								(MutatorWalkerFn) CQueryMutators::RunIncrLevelsUpMutator,
								context,
								1 // flag -- do not mutate range table entries
								);

		// fix the outer reference in derived table entries
		List *rtable = query->rtable;
		ListCell *lc = NULL;
		ForEach (lc, rtable)
		{
			RangeTblEntry *rte = (RangeTblEntry *) lfirst(lc);

			if (RTE_SUBQUERY == rte->rtekind)
			{
				Query *subquery = rte->subquery;
				// since we did not walk inside derived tables
				context->m_current_query_level++;
				rte->subquery = (Query *) RunIncrLevelsUpMutator( (Node *) subquery, context);
				context->m_current_query_level--;
				gpdb::GPDBFree(subquery);
			}
		}

		return (Node *) query;
	}

	return gpdb::MutateExpressionTree(node, (MutatorWalkerFn) CQueryMutators::RunIncrLevelsUpMutator, context);
}


//---------------------------------------------------------------------------
//	@function:
//		CQueryMutators::RunFixCTELevelsUpMutator
//
//	@doc:
//		Increment any the query levels up of any CTE range table reference by one
//---------------------------------------------------------------------------
Node *
CQueryMutators::RunFixCTELevelsUpMutator
	(
	Node *node,
	SContextIncLevelsupMutator *context
	)
{
	if (NULL == node)
	{
		return NULL;
	}

	// recurse into query structure
	if (IsA(node, Query))
	{
		Query *query = gpdb::MutateQueryTree
								(
								(Query *) node,
								(MutatorWalkerFn) CQueryMutators::RunFixCTELevelsUpMutator,
								context,
								1 // flag -- do not mutate range table entries
								);

		List *rtable = query->rtable;
		ListCell *lc = NULL;
		ForEach (lc, rtable)
		{
			RangeTblEntry *rte = (RangeTblEntry *) lfirst(lc);
			if (RTE_CTE == rte->rtekind  && NeedsLevelsUpCorrection(context, rte->ctelevelsup))
			{
				// fix the levels up for CTE range table entry when needed
				// the walker in GPDB does not walk range table entries of type CTE
				rte->ctelevelsup++;
			}

			if (RTE_SUBQUERY == rte->rtekind)
			{
				Query *subquery = rte->subquery;
				// since we did not walk inside derived tables
				context->m_current_query_level++;
				rte->subquery = (Query *) RunFixCTELevelsUpMutator( (Node *) subquery, context);
				context->m_current_query_level--;
				gpdb::GPDBFree(subquery);
			}
		}

		return (Node *) query;
	}

	if (IsA(node, CommonTableExpr))
	{
		CommonTableExpr *cte = (CommonTableExpr *) gpdb::CopyObject(node);
		GPOS_ASSERT(IsA(cte->ctequery, Query));

		Query *cte_query = (Query *) cte->ctequery;
		cte->ctequery = NULL;

		context->m_current_query_level++;
		cte->ctequery = RunFixCTELevelsUpMutator((Node *) cte_query, context);
		context->m_current_query_level--;

		gpdb::GPDBFree(cte_query);

		return (Node *) cte;
	}

	// recurse into a query attached to sublink
	if (IsA(node, SubLink))
	{
		SubLink *sublink = (SubLink *) gpdb::CopyObject(node);
		GPOS_ASSERT(IsA(sublink->subselect, Query));

		Query *sublink_query = (Query *) sublink->subselect;
		sublink->subselect = NULL;

		context->m_current_query_level++;
		sublink->subselect = RunFixCTELevelsUpMutator((Node *) sublink_query, context);
		context->m_current_query_level--;

		gpdb::GPDBFree(sublink_query);

		return (Node *) sublink;
	}

	return gpdb::MutateExpressionTree(node, (MutatorWalkerFn) CQueryMutators::RunFixCTELevelsUpMutator, context);
}

//---------------------------------------------------------------------------
//	@function:
//		CQueryMutators::FCorrectCTELevelsup
//
//	@doc:
//		Check if the cte levels up is the expected query level
//---------------------------------------------------------------------------
BOOL
CQueryMutators::NeedsLevelsUpCorrection
	(
	SContextIncLevelsupMutator *context,
	Index cte_levels_up
	)
{
	// when converting the query to derived table, all references to cte defined at the current level
	// or above needs to be incremented
	return cte_levels_up >= context->m_current_query_level;
}

//---------------------------------------------------------------------------
//	@function:
//		CQueryMutators::RunGroupingColMutator
//
//	@doc:
// 		Mutate the grouping columns, fix levels up when necessary
//
//---------------------------------------------------------------------------
Node *
CQueryMutators::RunGroupingColMutator
	(
	Node *node,
	SContextGrpbyPlMutator *context
	)
{
	if (NULL == node)
	{
		return NULL;
	}

	if (IsA(node, Const))
	{
		return (Node *) gpdb::CopyObject(node);
	}

	if (IsA(node, Var))
	{
		Var *var_copy = (Var *) gpdb::CopyObject(node);

		if (var_copy->varlevelsup > context->m_current_query_level)
		{
			var_copy->varlevelsup++;
		}

		return (Node *) var_copy;
	}

	if (IsA(node, Aggref))
	{
		// merely fix the arguments of an aggregate
		Aggref *old_aggref = (Aggref*) node;
		Aggref *aggref = FlatCopyAggref(old_aggref);
		aggref->agglevelsup = old_aggref->agglevelsup;

		List *new_args = NIL;
		ListCell *lc = NULL;

		BOOL is_agg = context->m_is_mutating_agg_arg;
		context->m_is_mutating_agg_arg = true;

		ForEach (lc, old_aggref->args)
		{
			Node *arg = (Node *) gpdb::CopyObject((Node*) lfirst(lc));
			GPOS_ASSERT(NULL != arg);
			// traverse each argument and fix levels up when needed
			new_args = gpdb::LAppend
						(
						new_args,
						gpdb::MutateQueryOrExpressionTree
							(
							arg,
							(MutatorWalkerFn) CQueryMutators::RunGroupingColMutator,
							(void *) context,
							0 // flags -- mutate into cte-lists
							)
						);
		}
		context->m_is_mutating_agg_arg = is_agg;
		aggref->args = new_args;

		return (Node*) aggref;
	}

	if (IsA(node, GroupingFunc))
	{
		return (Node *) gpdb::CopyObject(node);
	}

	if (IsA(node, SubLink))
	{
		SubLink *old_sublink = (SubLink *) node;

		SubLink *new_sublink = MakeNode(SubLink);
		new_sublink->subLinkType = old_sublink->subLinkType;
		new_sublink->location = old_sublink->location;
		new_sublink->operName = (List *) gpdb::CopyObject(old_sublink->operName);

		new_sublink->testexpr =	gpdb::MutateQueryOrExpressionTree
										(
										old_sublink->testexpr,
										(MutatorWalkerFn) CQueryMutators::RunGroupingColMutator,
										(void *) context,
										0 // flags -- mutate into cte-lists
										);
		context->m_current_query_level++;

		GPOS_ASSERT(IsA(old_sublink->subselect, Query));

		new_sublink->subselect = gpdb::MutateQueryOrExpressionTree
										(
										old_sublink->subselect,
										(MutatorWalkerFn) CQueryMutators::RunGroupingColMutator,
										context,
										0 // flags -- mutate into cte-lists
										);

		context->m_current_query_level--;

		return (Node *) new_sublink;
	}

	if (IsA(node, CommonTableExpr))
	{
		CommonTableExpr *cte = (CommonTableExpr *) gpdb::CopyObject(node);
		context->m_current_query_level++;

		GPOS_ASSERT(IsA(cte->ctequery, Query));

		cte->ctequery = gpdb::MutateQueryOrExpressionTree
									(
									cte->ctequery,
									(MutatorWalkerFn) CQueryMutators::RunGroupingColMutator,
									(void *) context,
									0 // flags --- mutate into cte-lists
									);

		context->m_current_query_level--;
		return (Node *) cte;
	}

	// recurse into query structure
	if (IsA(node, Query))
	{
		Query *query = gpdb::MutateQueryTree
								(
								(Query *) node,
								(MutatorWalkerFn) CQueryMutators::RunGroupingColMutator,
								context,
								1 // flag -- do not mutate range table entries
								);

		// fix the outer reference in derived table entries
		List *rtable = query->rtable;
		ListCell *lc = NULL;
		ForEach (lc, rtable)
		{
			RangeTblEntry *rte = (RangeTblEntry *) lfirst(lc);

			if (RTE_SUBQUERY == rte->rtekind)
			{
				Query *subquery = rte->subquery;
				// since we did not walk inside derived tables
				context->m_current_query_level++;
				rte->subquery = (Query *) RunGroupingColMutator( (Node *) subquery, context);
				context->m_current_query_level--;
				gpdb::GPDBFree(subquery);
			}
		}

		return (Node *) query;
	}

	return gpdb::MutateExpressionTree(node, (MutatorWalkerFn) CQueryMutators::RunGroupingColMutator, context);
}


//---------------------------------------------------------------------------
//	@function:
//		CQueryMutators::FixGroupingCols
//
//	@doc:
// 		Mutate the grouping columns, fix levels up when necessary
//---------------------------------------------------------------------------
Node *
CQueryMutators::FixGroupingCols
	(
	Node *node,
	TargetEntry *orginal_target_entry,
	SContextGrpbyPlMutator *context
	)
{
	GPOS_ASSERT(NULL != node);

	ULONG arity = gpdb::ListLength(context->m_groupby_tlist) + 1;

	// fix any outer references in the grouping column expression
	Node *expr = (Node *) RunGroupingColMutator(node, context);

	CHAR* name = CQueryMutators::GetTargetEntryColName(orginal_target_entry,context->m_query);
	TargetEntry *new_target_entry = gpdb::MakeTargetEntry((Expr*) expr, (AttrNumber) arity, name, false /*resjunk */);

	new_target_entry->ressortgroupref = orginal_target_entry->ressortgroupref;
	new_target_entry->resjunk = false;

	context->m_groupby_tlist = gpdb::LAppend(context->m_groupby_tlist, new_target_entry);

	Var *new_var = gpdb::MakeVar
			(
					1, // varno
					(AttrNumber) arity,
					gpdb::ExprType( (Node*) orginal_target_entry->expr),
					gpdb::ExprTypeMod( (Node*) orginal_target_entry->expr),
					0 // query levelsup
			);

	return (Node*) new_var;
}


//---------------------------------------------------------------------------
//	@function:
//		CQueryMutators::GetTargetEntryForAggExpr
//
//	@doc:
// 		Return a target entry for an aggregate expression
//---------------------------------------------------------------------------
TargetEntry *
CQueryMutators::GetTargetEntryForAggExpr
	(
	CMemoryPool *mp,
	CMDAccessor *md_accessor,
	Node *node,
	ULONG attno
	)
{
	GPOS_ASSERT(IsA(node, Aggref) || IsA(node, GroupingFunc));

	// get the function/aggregate name
	CHAR *name = NULL;
	if (IsA(node, GroupingFunc))
	{
		name = CTranslatorUtils::CreateMultiByteCharStringFromWCString(GPOS_WSZ_LIT("grouping"));
	}
	else
	{
		Aggref *aggref = (Aggref*) node;

		CMDIdGPDB *agg_mdid = GPOS_NEW(mp) CMDIdGPDB(aggref->aggfnoid);
		const IMDAggregate *md_agg = md_accessor->RetrieveAgg(agg_mdid);
		agg_mdid->Release();

		const CWStringConst *str = md_agg->Mdname().GetMDName();
		name = CTranslatorUtils::CreateMultiByteCharStringFromWCString(str->GetBuffer());
	}
	GPOS_ASSERT(NULL != name);

	return gpdb::MakeTargetEntry((Expr*) node, (AttrNumber) attno, name, false);
}

// Traverse the entire tree under an arbitrarily complex project element (node)
// to extract all aggregate functions out into the derived query's target list
//
// This mutator should be called after creating a derived query (a subquery in
// the FROM clause), on each element in the old query's target list or qual to
// update any AggRef & Var to refer to the output from the derived query.
//
// See comments below & in the callers for specific use cases.
Node *
CQueryMutators::RunExtractAggregatesMutator
	(
	Node *node,
	SContextGrpbyPlMutator *context
	)
{
	if (NULL == node)
	{
		return NULL;
	}

	if (IsA(node, Const))
	{
		return (Node *) gpdb::CopyObject(node);
	}

	if (IsA(node, Aggref))
	{
		Aggref *old_aggref = (Aggref *) node;

		// If the agglevelsup matches the current query level, this Aggref only
		// uses vars from the top level query. This needs to be moved to the
		// derived query, and the entire AggRef replaced with a Var referencing the
		// derived table's target list.
		if (old_aggref->agglevelsup == context->m_current_query_level)
		{
			Aggref *new_aggref = FlatCopyAggref(old_aggref);
			
			BOOL is_agg_old = context->m_is_mutating_agg_arg;
			ULONG agg_levels_up = context->m_agg_levels_up;

			context->m_is_mutating_agg_arg = true;
			context->m_agg_levels_up = old_aggref->agglevelsup;

			List *new_args = NIL;
			ListCell *lc = NULL;

			ForEach (lc, old_aggref->args)
			{
				Node *arg = (Node*) lfirst(lc);
				GPOS_ASSERT(NULL != arg);
				// traverse each argument and fix levels up when needed
				new_args = gpdb::LAppend
									(
									new_args,
									gpdb::MutateQueryOrExpressionTree
											(
											arg,
											(MutatorWalkerFn) RunExtractAggregatesMutator,
											(void *) context,
											0 // mutate into cte-lists
											)
									);
			}
			new_aggref->args = new_args;
			context->m_is_mutating_agg_arg = is_agg_old;
			context->m_agg_levels_up = agg_levels_up;

			// create a new entry in the derived table and return its corresponding var
			return (Node *) MakeVarInDerivedTable((Node *) new_aggref, context);
		}
	}

	if (0 == context->m_current_query_level)
	{
		if (IsA(node, Var) && context->m_is_mutating_agg_arg)
		{
			// This mutator may be run on a nested query object with aggregates on
			// outer references. It pulls out any aggregates and moves it into the
			// derived query (which is subquery), in effect, increasing the levels up
			// any Var in the aggregate must now reference
			//
			// e.g SELECT (SELECT sum(o.o) + 1 FROM i GRP BY i.i) FROM o;
			// becomes SELECT (SELECT x + 1 FROM (SELECT sum(o.o) GRP BY i.i)) FROM o;
			// which means Var::varlevelup must be increased for o.o
			return (Node *) IncrLevelsUpIfOuterRef((Var*) node);
		}

		if (IsA(node, GroupingFunc))
		{
			// create a new entry in the derived table and return its corresponding var
			Node *node_copy = (Node*) gpdb::CopyObject(node);
			return (Node *) MakeVarInDerivedTable(node_copy, context);
		}

		if (!context->m_is_mutating_agg_arg)
		{
			// check if an entry already exists, if so no need for duplicate
			Node *found_node = FindNodeInGroupByTargetList(node, context);
			if (NULL != found_node)
			{
				return found_node;
			}
		}
	}

	if (IsA(node, Var))
	{
		Var *var = (Var *) gpdb::CopyObject(node);

		// Handle other top-level outer references in the project element.
		if (var->varlevelsup == context->m_current_query_level)
		{
			if (var->varlevelsup == context->m_agg_levels_up)
			{
				// If Var references the top level query inside an Aggref that also
				// references top level query, the Aggref is moved to the derived query
				// (see comments in Aggref if-case above). Thus, these Var references
				// are brought up to the top-query level.
				// e.g:
				// explain select (select sum(foo.a) from jazz) from foo group by a, b;
				// is transformed into
				// select (select fnew.sum_t from jazz)
				// from (select foo.a, foo.b, sum(foo.a) sum_t
				//       from foo group by foo.a, foo.b) fnew;
				//
				// Note the foo.a var which is in sum() in a subquery must now become a
				// var referencing the current query level.
				var->varlevelsup = 0;
				return (Node *) var;
			}

			// Skip vars inside Aggrefs, since they have already been fixed when they
			// were moved into the derived query in ConvertToDerivedTable(), and thus,
			// the relative varno, varattno & varlevelsup should still be valid.
			// e.g:
			// SELECT foo.b+1, avg(( SELECT bar.f FROM bar
			//                       WHERE bar.d = foo.b)) AS t
			// FROM foo GROUP BY foo.b;
			// is transformed into
			// SELECT fnew.b+1, fnew.avg_t
			// FROM (SELECT foo.b,`avg(( SELECT bar.f FROM bar
			//                           WHERE bar.d = foo.b)) AS t
			//       FROM foo) fnew;
			//
			// Note the foo.b outerref in subquery inside the avg() aggregation.
			// Because it is inside the aggregation, it was pushed down along with
			// the aggregate function, and thus does not need to be fixed.
			if (context->m_is_mutating_agg_arg)
			{
				return (Node *) var;
			}

			// For other top-level references, correct their varno & varattno, since
			// they now must refer to the target list of the derived query - whose
			// target list may be different from the original query.

			// Set varlevelsup to 0 temporarily while searching in the target list
			var->varlevelsup = 0;
			TargetEntry *found_tle =
				gpdb::FindFirstMatchingMemberInTargetList((Node*) var,
													  context->m_groupby_tlist);

			if (NULL == found_tle)
			{
				// Consider two table r(a,b) and s(c,d) and the following query
				// SELECT 1 from r LEFT JOIN s on (r.a = s.c) group by r.a having count(*) > a
				// The having clause refers to the output of the left outer join while the
				// grouping column refers to the base table column.
				// While r.a and a are equivalent, the algebrizer at this point cannot detect this.
				// Therefore, found_target_entry will be NULL and we fall back.

				// TODO: Oct 14 2013, remove temporary fix (revert exception to assert) to avoid crash during algebrization
				GPOS_RAISE(gpdxl::ExmaDXL, gpdxl::ExmiQuery2DXLError, GPOS_WSZ_LIT("No attribute"));
				return NULL;
			}

			var->varno = 1;  // derived query is the only table in FROM expression
			var->varattno = found_tle->resno;
			var->varlevelsup = context->m_current_query_level;  // reset varlevels up
			found_tle->resjunk = false;

			return (Node*) var;
		}
		return (Node *) var;
	}

	if (IsA(node, CommonTableExpr))
	{
		CommonTableExpr *cte = (CommonTableExpr *) gpdb::CopyObject(node);
		context->m_current_query_level++;

		GPOS_ASSERT(IsA(cte->ctequery, Query));

		cte->ctequery = gpdb::MutateQueryOrExpressionTree
									(
									cte->ctequery,
									(MutatorWalkerFn) RunExtractAggregatesMutator,
									(void *) context,
									0 // mutate into cte-lists
									);

		context->m_current_query_level--;
		return (Node *) cte;
	}

	if (IsA(node, SubLink))
	{
		SubLink *old_sublink = (SubLink *) node;

		SubLink *new_sublink = MakeNode(SubLink);
		new_sublink->subLinkType = old_sublink->subLinkType;
		new_sublink->location = old_sublink->location;
		new_sublink->operName = (List *) gpdb::CopyObject(old_sublink->operName);

		new_sublink->testexpr =	gpdb::MutateQueryOrExpressionTree
										(
										old_sublink->testexpr,
										(MutatorWalkerFn) RunExtractAggregatesMutator,
										(void *) context,
										0 // mutate into cte-lists
										);
		context->m_current_query_level++;

		GPOS_ASSERT(IsA(old_sublink->subselect, Query));

		new_sublink->subselect = gpdb::MutateQueryOrExpressionTree
										(
										old_sublink->subselect,
										(MutatorWalkerFn) RunExtractAggregatesMutator,
										(void *) context,
										0 // mutate into cte-lists
										);

		context->m_current_query_level--;

		return (Node *) new_sublink;
	}
	
	return gpdb::MutateExpressionTree(node, (MutatorWalkerFn) RunExtractAggregatesMutator, context);
}


// Create a new entry in the derived table and return its corresponding var
Var *
CQueryMutators::MakeVarInDerivedTable
	(
	Node *node,
	SContextGrpbyPlMutator *context
	)
{
	GPOS_ASSERT(NULL != node);
	GPOS_ASSERT(NULL != context);
	GPOS_ASSERT(IsA(node, Aggref) || IsA(node, GroupingFunc));

	// Append a new target entry for the node to the derived target list ...
	const ULONG attno = gpdb::ListLength(context->m_groupby_tlist) + 1;
	TargetEntry *tle = GetTargetEntryForAggExpr(context->m_mp, context->m_mda, node, attno);
	context->m_groupby_tlist = gpdb::LAppend(context->m_groupby_tlist, tle);

	// ... and return a Var referring to it in its stead
	// NB: Since the new tle is appended at the top query level, Var::varlevelsup
	// should equal the current nested level. This will take care of any outer references
	// to the original tlist.
	Var *new_var = gpdb::MakeVar(1 /* varno */,
								 attno,
								 gpdb::ExprType((Node*) node),
								 gpdb::ExprTypeMod((Node*) node),
								 context->m_current_query_level /* varlevelsup */);

	return new_var;
}


// Check if a matching entry already exists in the list of target
// entries, if yes return its corresponding var, otherwise return NULL
Node *
CQueryMutators::FindNodeInGroupByTargetList
	(
	Node *node,
	SContextGrpbyPlMutator *context
	)
{
	GPOS_ASSERT(NULL != node);
	GPOS_ASSERT(NULL != context);
	
	TargetEntry *found_tle =
		gpdb::FindFirstMatchingMemberInTargetList(node, context->m_groupby_tlist);

	if (NULL != found_tle)
	{
		gpdb::GPDBFree(node);
		// NB: Var::varlevelsup is set to the current query level since the created
		// Var must reference the group by targetlist at the top level.
		Var *new_var = gpdb::MakeVar(1 /* varno */,
									 found_tle->resno,
									 gpdb::ExprType( (Node*) found_tle->expr),
									 gpdb::ExprTypeMod( (Node*) found_tle->expr),
									 context->m_current_query_level /* varlevelsup */);

		found_tle->resjunk = false;
		return (Node*) new_var;
	}

	return NULL;
}

//---------------------------------------------------------------------------
//	@function:
//		CQueryMutators::FlatCopyAggref
//
//	@doc:
//		Make a copy of the aggref (minus the arguments)
//---------------------------------------------------------------------------
Aggref *
CQueryMutators::FlatCopyAggref
	(
	Aggref *old_aggref
	)
{
	Aggref *new_aggref = MakeNode(Aggref);

	*new_aggref = *old_aggref;

	new_aggref->agglevelsup = 0;
	// This is not strictly necessary: we seem to ALWAYS assgin to args from
	// the callers
	// Explicitly setting this both to be safe and to be clear that we are
	// intentionally NOT copying the args
	new_aggref->args = NIL;

	return new_aggref;
}


// Increment the levels up of outer references
Var *
CQueryMutators::IncrLevelsUpIfOuterRef
	(
	Var *var
	)
{
	GPOS_ASSERT(NULL != var);

	Var *var_copy = (Var *) gpdb::CopyObject(var);
	if (0 != var_copy->varlevelsup)
	{
		var_copy->varlevelsup++;
	}

	return var_copy;
}

//---------------------------------------------------------------------------
//	@function:
//		CQueryMutators::NormalizeHaving
//
//	@doc:
//		Pull up having qual into a select and fix correlated references
//		to the top-level query
//---------------------------------------------------------------------------
Query *
CQueryMutators::NormalizeHaving
	(
	CMemoryPool *mp,
	CMDAccessor *md_accessor,
	const Query *query
	)
{
	Query *query_copy = (Query *) gpdb::CopyObject(const_cast<Query*>(query));

	if (NULL == query->havingQual)
	{
		return query_copy;
	}

	Query *new_query = ConvertToDerivedTable(query_copy, true /*should_fix_target_list*/, false /*should_fix_having_qual*/);
	gpdb::GPDBFree(query_copy);

	RangeTblEntry *rte = ((RangeTblEntry *) gpdb::ListNth(new_query->rtable, 0));
	Query *derived_table_query = (Query *) rte->subquery;

	// Add all necessary target list entries of subquery
	// into the target list of the RTE as well as the new top most query
	ListCell *lc = NULL;
	ULONG num_target_entries = 1;
	ForEach (lc, derived_table_query->targetList)
	{
		TargetEntry *target_entry  = (TargetEntry*) lfirst(lc);
		GPOS_ASSERT(NULL != target_entry);

		// Add to the target lists:
		// 	(1) All grouping / sorting columns even if they do not appear in the subquery output (resjunked)
		//	(2) All non-resjunked target list entries
		if (CTranslatorUtils::IsGroupingColumn(target_entry, derived_table_query->groupClause) ||
			CTranslatorUtils::IsSortingColumn(target_entry, derived_table_query->sortClause) || !target_entry->resjunk)
		{
			TargetEntry *new_target_entry = MakeTopLevelTargetEntry(target_entry, num_target_entries);
			new_query->targetList = gpdb::LAppend(new_query->targetList, new_target_entry);
			// Ensure that such target entries is not suppressed in the target list of the RTE
			// and has a name
			target_entry->resname = GetTargetEntryColName(target_entry, derived_table_query);
			target_entry->resjunk = false;
			new_target_entry->ressortgroupref = target_entry->ressortgroupref;

			num_target_entries++;
		}
	}

	SContextGrpbyPlMutator context(mp, md_accessor, derived_table_query, derived_table_query->targetList);

	// fix outer references in the qual
	new_query->jointree->quals = RunExtractAggregatesMutator(derived_table_query->havingQual, &context);
	derived_table_query->havingQual = NULL;

	ReassignSortClause(new_query, rte->subquery);

	if (!rte->subquery->hasAggs && NIL == rte->subquery->groupClause)
	{
		// if the derived table has no grouping columns or aggregates then the
		// subquery is equivalent to select XXXX FROM CONST-TABLE 
		// (where XXXX is the original subquery's target list)

		Query *new_subquery = MakeNode(Query);

		new_subquery->commandType = CMD_SELECT;
		new_subquery->targetList = NIL;

		new_subquery->hasAggs = false;
		new_subquery->hasWindowFuncs = false;
		new_subquery->hasSubLinks = false;

		ListCell *lc = NULL;
		ForEach (lc, rte->subquery->targetList)
		{
			TargetEntry *target_entry  = (TargetEntry*) lfirst(lc);
			GPOS_ASSERT(NULL != target_entry);

			GPOS_ASSERT(!target_entry->resjunk);
			
			new_subquery->targetList =  gpdb::LAppend
													(
													new_subquery->targetList,
													(TargetEntry *) gpdb::CopyObject(const_cast<TargetEntry*>(target_entry))
													);
		}

		gpdb::GPDBFree(rte->subquery);

		rte->subquery = new_subquery;
		rte->subquery->jointree = MakeNode(FromExpr);
		rte->subquery->groupClause = NIL;
		rte->subquery->sortClause = NIL;
		rte->subquery->windowClause = NIL;
	}

	return new_query;
}

//---------------------------------------------------------------------------
//	@function:
//		CQueryMutators::NormalizeQuery
//
//	@doc:
//		Normalize queries with having and group by clauses
//---------------------------------------------------------------------------
Query *
CQueryMutators::NormalizeQuery
	(
	CMemoryPool *mp,
	CMDAccessor *md_accessor,
	const Query *query,
	ULONG query_level
	)
{
	// flatten join alias vars defined at the current level of the query
	Query *pqueryResolveJoinVarReferences = gpdb::FlattenJoinAliasVar(const_cast<Query*>(query), query_level);

	// eliminate distinct clause
	Query *pqueryEliminateDistinct = CQueryMutators::EliminateDistinctClause(pqueryResolveJoinVarReferences);
	GPOS_ASSERT(NULL == pqueryEliminateDistinct->distinctClause);
	gpdb::GPDBFree(pqueryResolveJoinVarReferences);

	// normalize window operator's project list
	Query *pqueryWindowPlNormalized = CQueryMutators::NormalizeWindowProjList(mp, md_accessor, pqueryEliminateDistinct);
	gpdb::GPDBFree(pqueryEliminateDistinct);

	// pull-up having quals into a select
	Query *pqueryHavingNormalized = CQueryMutators::NormalizeHaving(mp, md_accessor, pqueryWindowPlNormalized);
	GPOS_ASSERT(NULL == pqueryHavingNormalized->havingQual);
	gpdb::GPDBFree(pqueryWindowPlNormalized);

	// normalize the group by project list
	Query *new_query = CQueryMutators::NormalizeGroupByProjList(mp, md_accessor, pqueryHavingNormalized);
	gpdb::GPDBFree(pqueryHavingNormalized);

	return new_query;
}

//---------------------------------------------------------------------------
//	@function:
//		CQueryMutators::GetTargetEntry
//
//	@doc:
//		Given an Target list entry in the derived table, create a new
//		TargetEntry to be added to the top level query. This function allocates
//		memory
//---------------------------------------------------------------------------
TargetEntry *
CQueryMutators::MakeTopLevelTargetEntry
	(
	TargetEntry *old_target_entry,
	ULONG attno
	)
{
	Var *new_var = gpdb::MakeVar
							(
							1,
							(AttrNumber) attno,
							gpdb::ExprType( (Node*) old_target_entry->expr),
							gpdb::ExprTypeMod( (Node*) old_target_entry->expr),
							0 // query levelsup
							);

	TargetEntry *new_target_entry = gpdb::MakeTargetEntry((Expr*) new_var, (AttrNumber) attno, old_target_entry->resname, old_target_entry->resjunk);

	return new_target_entry;
}

//---------------------------------------------------------------------------
//	@function:
//		CQueryMutators::GetTargetEntryColName
//
//	@doc:
//		Return the column name of the target list entry
//---------------------------------------------------------------------------
CHAR *
CQueryMutators::GetTargetEntryColName
	(
	TargetEntry *target_entry,
	Query *query
	)
{
	if (NULL != target_entry->resname)
	{
		return target_entry->resname;
	}

	// Since a resjunked target list entry will not have a column name create a dummy column name
	CWStringConst dummy_colname(GPOS_WSZ_LIT("?column?"));

	return CTranslatorUtils::CreateMultiByteCharStringFromWCString(dummy_colname.GetBuffer());
}

//---------------------------------------------------------------------------
//	@function:
//		CQueryMutators::ConvertToDerivedTable
//
//	@doc:
//		Converts query into a derived table and return the new top-level query
//---------------------------------------------------------------------------
Query *
CQueryMutators::ConvertToDerivedTable
	(
	const Query *query,
	BOOL should_fix_target_list,
	BOOL should_fix_having_qual
	)
{
	Query *query_copy = (Query *) gpdb::CopyObject(const_cast<Query*>(query));

	Node *having_qual = NULL;
	if (!should_fix_having_qual)
	{
		having_qual = query_copy->havingQual;
		query_copy->havingQual = NULL;
	}

	// fix outer references
	Query *derived_table_query;
	{
		SContextIncLevelsupMutator context(0, should_fix_target_list);
		derived_table_query = (Query *) RunIncrLevelsUpMutator((Node*) query_copy, &context);
	}
	gpdb::GPDBFree(query_copy);

	// fix the CTE levels up -- while the old query is converted into a derived table, its cte list
	// is re-assigned to the new top-level query. The references to the ctes listed in the old query
	// as well as those listed before the current query level are accordingly adjusted in the new
	// derived table.
	List *original_cte_list = derived_table_query->cteList;
	derived_table_query->cteList = NIL;

	Query *new_derived_table_query;
	{
		SContextIncLevelsupMutator context(0 /*starting level */, should_fix_target_list);
		new_derived_table_query  = (Query *) RunFixCTELevelsUpMutator( (Node *) derived_table_query, &context);
	}
	gpdb::GPDBFree(derived_table_query);
	derived_table_query = new_derived_table_query;

	// create a range table entry for the query node
	RangeTblEntry *rte = MakeNode(RangeTblEntry);
	rte->rtekind = RTE_SUBQUERY;

	rte->subquery = derived_table_query;
	rte->inFromCl = true;
	rte->subquery->cteList = NIL;

	if (NULL != having_qual)
	{
		derived_table_query->havingQual = having_qual;
	}

	// create a new range table reference for the new RTE
	RangeTblRef *rtref = MakeNode(RangeTblRef);
	rtref->rtindex = 1;

	// GPDB_92_MERGE_FIXME: other than holding the intoClause and intoPolicy,
	// what purpose does this normalization step do? Upstream commit 9dbf2b7d
	// removed Query::intoClause

//	// intoClause, if not null, must be set on the top query, not on the derived table
//	IntoClause *origIntoClause = pqueryDrvd->intoClause;
//	pqueryDrvd->intoClause = NULL;
	// intoClause, if not null, must be set on the top query, not on the derived table
	struct GpPolicy* into_policy = derived_table_query->intoPolicy;
	derived_table_query->intoPolicy = NULL;

	// create a new top-level query with the new RTE in its from clause
	Query *new_query = MakeNode(Query);
	new_query->cteList = original_cte_list;
	new_query->hasAggs = false;
	new_query->rtable = gpdb::LAppend(new_query->rtable, rte);
//	new_query->intoClause = origIntoClause;
	new_query->intoPolicy = into_policy;
	new_query->parentStmtType = derived_table_query->parentStmtType;
	derived_table_query->parentStmtType = PARENTSTMTTYPE_NONE;

	FromExpr *fromexpr = MakeNode(FromExpr);
	fromexpr->quals = NULL;
	fromexpr->fromlist = gpdb::LAppend(fromexpr->fromlist, rtref);

	new_query->jointree = fromexpr;
	new_query->commandType = CMD_SELECT;

	GPOS_ASSERT(1 == gpdb::ListLength(new_query->rtable));
	return new_query;
}

//---------------------------------------------------------------------------
//	@function:
//		CQueryMutators::EliminateDistinctClause
//
//	@doc:
//		Eliminate distinct columns by translating it into a grouping columns
//---------------------------------------------------------------------------
Query *
CQueryMutators::EliminateDistinctClause
	(
	const Query *query
	)
{
	if (0 == gpdb::ListLength(query->distinctClause))
	{
		return (Query*) gpdb::CopyObject(const_cast<Query*>(query));
	}

	// create a derived table out of the previous query
	Query *new_query = ConvertToDerivedTable(query, true /*should_fix_target_list*/, true /*should_fix_having_qual*/);

	GPOS_ASSERT(1 == gpdb::ListLength(new_query->rtable));
	Query *derived_table_query = (Query *) ((RangeTblEntry *) gpdb::ListNth(new_query->rtable, 0))->subquery;

	ReassignSortClause(new_query, derived_table_query);

	new_query->targetList = NIL;
	List *target_entries = derived_table_query->targetList;
	ListCell *lc = NULL;

	// build the project list of the new top-level query
	ForEach (lc, target_entries)
	{
		ULONG resno = gpdb::ListLength(new_query->targetList) + 1;
		TargetEntry *target_entry  = (TargetEntry*) lfirst(lc);
		GPOS_ASSERT(NULL != target_entry);

		if (!target_entry->resjunk)
		{
			// create a new target entry that points to the corresponding entry in the derived table
			Var *new_var = gpdb::MakeVar
									(
									1,
									target_entry->resno,
									gpdb::ExprType((Node*) target_entry->expr),
									gpdb::ExprTypeMod((Node*) target_entry->expr),
									0 // query levels up
									);
			TargetEntry *new_target_entry= gpdb::MakeTargetEntry((Expr*) new_var, (AttrNumber) resno, target_entry->resname, false);

			new_target_entry->ressortgroupref =  target_entry->ressortgroupref;
			new_query->targetList = gpdb::LAppend(new_query->targetList, new_target_entry);
		}

		if (0 < target_entry->ressortgroupref &&
			!CTranslatorUtils::IsGroupingColumn(target_entry, derived_table_query->groupClause) &&
			!CTranslatorUtils::IsWindowSpec(target_entry, derived_table_query->windowClause))
		{
			// initialize the ressortgroupref of target entries not used in the grouping clause
			 target_entry->ressortgroupref = 0;
		}
	}

	if (gpdb::ListLength(new_query->targetList) != gpdb::ListLength(query->distinctClause))
	{
		GPOS_RAISE(gpdxl::ExmaDXL, gpdxl::ExmiQuery2DXLUnsupportedFeature, GPOS_WSZ_LIT("DISTINCT operation on a subset of target list columns"));
	}

	ListCell *pl = NULL;
	ForEach (pl, query->distinctClause)
	{
		SortGroupClause *sort_group_clause  = (SortGroupClause*) lfirst(pl);
		GPOS_ASSERT(NULL != sort_group_clause);

		SortGroupClause *new_sort_group_clause = MakeNode(SortGroupClause);
		new_sort_group_clause->tleSortGroupRef = sort_group_clause->tleSortGroupRef;
		new_sort_group_clause->eqop = sort_group_clause->eqop;
		new_sort_group_clause->sortop = sort_group_clause->sortop;
		new_sort_group_clause->nulls_first = sort_group_clause->nulls_first;
		new_query->groupClause = gpdb::LAppend(new_query->groupClause, new_sort_group_clause);
	}
	new_query->distinctClause = NIL;
	derived_table_query->distinctClause = NIL;

	return new_query;
}

//---------------------------------------------------------------------------
//	@function:
//		CQueryMutators::NeedsProjListWindowNormalization
//
//	@doc:
//		Check whether the window operator's project list only contains
//		window functions and columns used in the window specification
//---------------------------------------------------------------------------
BOOL
CQueryMutators::NeedsProjListWindowNormalization
	(
	const Query *query
	)
{
	if (!query->hasWindowFuncs)
	{
		return false;
	}

	ListCell *lc = NULL;
	ForEach (lc, query->targetList)
	{
		TargetEntry *target_entry  = (TargetEntry*) lfirst(lc);

		if (!CTranslatorUtils::IsWindowSpec( (Node *) target_entry->expr, query->windowClause, query->targetList) && !IsA(target_entry->expr, WindowFunc) && !IsA(target_entry->expr, Var))
		{
			// computed columns in the target list that is not
			// used in the order by or partition by of the window specification(s)
			return true;
		}
	}

	return false;
}

//---------------------------------------------------------------------------
//	@function:
//		CQueryMutators::NormalizeWindowProjList
//
//	@doc:
// 		Flatten expressions in project list to contain only window functions and
//		columns used in the window specification
//
//		ORGINAL QUERY:
//			SELECT row_number() over() + rank() over(partition by a+b order by a-b) from foo
//
// 		NEW QUERY:
//			SELECT rn+rk from (SELECT row_number() over() as rn rank() over(partition by a+b order by a-b) as rk FROM foo) foo_new
//---------------------------------------------------------------------------
Query *
CQueryMutators::NormalizeWindowProjList
	(
	CMemoryPool *mp,
	CMDAccessor *md_accessor,
	const Query *query
	)
{
	Query *query_copy = (Query *) gpdb::CopyObject(const_cast<Query*>(query));

	if (!NeedsProjListWindowNormalization(query))
	{
		return query_copy;
	}

	// we do not fix target list of the derived table since we will be mutating it below
	// to ensure that it does not have operations with window function
	Query *new_query = ConvertToDerivedTable(query_copy, false /*should_fix_target_list*/, true /*should_fix_having_qual*/);
	gpdb::GPDBFree(query_copy);

	GPOS_ASSERT(1 == gpdb::ListLength(new_query->rtable));
	Query *derived_table_query = (Query *) ((RangeTblEntry *) gpdb::ListNth(new_query->rtable, 0))->subquery;

	SContextGrpbyPlMutator context(mp, md_accessor, derived_table_query, NULL);
	ListCell *lc = NULL;
	List *target_entries = derived_table_query->targetList;
	ForEach (lc, target_entries)
	{
		TargetEntry *target_entry  = (TargetEntry*) lfirst(lc);
		const ULONG ulResNoNew = gpdb::ListLength(new_query->targetList) + 1;

		if (CTranslatorUtils::IsWindowSpec(target_entry, query->windowClause))
		{
			// insert the target list entry used in the window specification as is
			TargetEntry *new_target_entry = (TargetEntry *) gpdb::CopyObject(target_entry);
			new_target_entry->resno = gpdb::ListLength(context.m_groupby_tlist) + 1;
			context.m_groupby_tlist = gpdb::LAppend(context.m_groupby_tlist, new_target_entry);

			if (!target_entry->resjunk || CTranslatorUtils::IsSortingColumn(target_entry, query->sortClause))
			{
				// if the target list entry used in the window specification is present
				// in the query output then add it to the target list of the new top level query
				Var *new_var = gpdb::MakeVar
										(
										1,
										new_target_entry->resno,
										gpdb::ExprType((Node*) target_entry->expr),
										gpdb::ExprTypeMod((Node*) target_entry->expr),
										0 // query levels up
										);
				TargetEntry *new_target_entry_copy = gpdb::MakeTargetEntry((Expr*) new_var, ulResNoNew, target_entry->resname, target_entry->resjunk);

				// Copy the resortgroupref and resjunk information for the top-level target list entry
				// Set target list entry of the derived table to be non-resjunked
				new_target_entry_copy->resjunk = new_target_entry->resjunk;
				new_target_entry_copy->ressortgroupref = new_target_entry->ressortgroupref;
				new_target_entry->resjunk = false;

				new_query->targetList = gpdb::LAppend(new_query->targetList, new_target_entry_copy);
			}
		}
		else
		{
			// normalize target list entry
			Expr *pexprNew = (Expr*) RunWindowProjListMutator( (Node*) target_entry->expr, &context);
			TargetEntry *new_target_entry = gpdb::MakeTargetEntry(pexprNew, ulResNoNew, target_entry->resname, target_entry->resjunk);
			new_target_entry->ressortgroupref = target_entry->ressortgroupref;
			new_query->targetList = gpdb::LAppend(new_query->targetList, new_target_entry);
		}
	}
	derived_table_query->targetList = context.m_groupby_tlist;

	GPOS_ASSERT(gpdb::ListLength(new_query->targetList) <= gpdb::ListLength(query->targetList));

	new_query->hasWindowFuncs = false;
	ReassignSortClause(new_query, derived_table_query);

	return new_query;
}

//---------------------------------------------------------------------------
//	@function:
//		CQueryMutators::RunWindowProjListMutator
//
//	@doc:
// 		Traverse the project list of extract all window functions in an
//		arbitrarily complex project element
//---------------------------------------------------------------------------
Node *
CQueryMutators::RunWindowProjListMutator
	(
	Node *node,
	SContextGrpbyPlMutator *context
	)
{
	if (NULL == node)
	{
		return NULL;
	}

	// do not traverse into sub queries as they will be inserted are inserted into
	// top-level query as is
	if (IsA(node, SubLink))
	{
		return (Node *) gpdb::CopyObject(node);
	}

	const ULONG resno = gpdb::ListLength(context->m_groupby_tlist) + 1;

	if (IsA(node, WindowFunc))
	{
		// insert window operator into the derived table
        // and refer to it in the top-level query's target list
		WindowFunc *window_func = (WindowFunc *) gpdb::CopyObject(node);

		// get the function name and add it to the target list
		CMDIdGPDB *mdid_func = GPOS_NEW(context->m_mp) CMDIdGPDB(window_func->winfnoid);
		const CWStringConst *str = CMDAccessorUtils::PstrWindowFuncName(context->m_mda, mdid_func);
		mdid_func->Release();

		TargetEntry *target_entry = gpdb::MakeTargetEntry
								(
								(Expr*) gpdb::CopyObject(node),
								(AttrNumber) resno,
								CTranslatorUtils::CreateMultiByteCharStringFromWCString(str->GetBuffer()),
								false /* resjunk */
								);
		context->m_groupby_tlist = gpdb::LAppend(context->m_groupby_tlist, target_entry);

		// return a variable referring to the new derived table's corresponding target list entry
		Var *new_var = gpdb::MakeVar
								(
								1,
								(AttrNumber) resno,
								gpdb::ExprType(node),
								gpdb::ExprTypeMod(node),
								0 // query levelsup
								);

		return (Node*) new_var;
	}

	if (IsA(node, Var))
	{
		Var *new_var = NULL;

		TargetEntry *found_target_entry = gpdb::FindFirstMatchingMemberInTargetList(node, context->m_groupby_tlist);
		if (NULL == found_target_entry)
		{
			// insert target entry into the target list of the derived table
			CWStringConst str_unnamed_col(GPOS_WSZ_LIT("?column?"));
			TargetEntry *target_entry = gpdb::MakeTargetEntry
									(
									(Expr*) gpdb::CopyObject(node),
									(AttrNumber) resno,
									CTranslatorUtils::CreateMultiByteCharStringFromWCString(str_unnamed_col.GetBuffer()),
									false /* resjunk */
									);
			context->m_groupby_tlist = gpdb::LAppend(context->m_groupby_tlist, target_entry);

			new_var = gpdb::MakeVar
								(
								1,
								(AttrNumber) resno,
								gpdb::ExprType(node),
								gpdb::ExprTypeMod(node),
								0 // query levelsup
								);
		}
		else
		{
			found_target_entry->resjunk = false; // ensure that the derived target list is not resjunked
			new_var = gpdb::MakeVar
								(
								1,
								found_target_entry->resno,
								gpdb::ExprType(node),
								gpdb::ExprTypeMod(node),
								0 // query levelsup
								);
		}

		return (Node*) new_var;
	}

	return gpdb::MutateExpressionTree(node, (MutatorWalkerFn) CQueryMutators::RunWindowProjListMutator, context);
}

//---------------------------------------------------------------------------
//	@function:
//		CQueryMutators::ReassignSortClause
//
//	@doc:
//		Reassign the sorting clause from the derived table to the new top-level query
//---------------------------------------------------------------------------
void
CQueryMutators::ReassignSortClause
	(
	Query *top_level_query,
	Query *derived_table_query
	)
{
	top_level_query->sortClause = derived_table_query->sortClause;
	top_level_query->limitOffset = derived_table_query->limitOffset;
	top_level_query->limitCount = derived_table_query->limitCount;
	derived_table_query->sortClause = NULL;
	derived_table_query->limitOffset = NULL;
	derived_table_query->limitCount = NULL;
}

// EOF
