drop table if exists d;
drop table if exists c;
drop table if exists b;
drop table if exists a;
-- Check multi level partition COPY
create table region
(
	r_regionkey integer not null,
	r_name char(25),
	r_comment varchar(152)
)
distributed by (r_regionkey)
partition by range (r_regionkey)
subpartition by list (r_name) subpartition template
(
	subpartition africa values ('AFRICA'),
	subpartition america values ('AMERICA'),
	subpartition asia values ('ASIA'),
	subpartition europe values ('EUROPE'),
	subpartition mideast values ('MIDDLE EAST'),
	subpartition australia values ('AUSTRALIA'),
	subpartition antarctica values ('ANTARCTICA')
)
(
	partition region1 start (0),
	partition region2 start (3),
	partition region3 start (5) end (8)
);
NOTICE:  CREATE TABLE will create partition "region_1_prt_region1" for table "region"
NOTICE:  CREATE TABLE will create partition "region_1_prt_region1_2_prt_africa" for table "region_1_prt_region1"
NOTICE:  CREATE TABLE will create partition "region_1_prt_region1_2_prt_america" for table "region_1_prt_region1"
NOTICE:  CREATE TABLE will create partition "region_1_prt_region1_2_prt_asia" for table "region_1_prt_region1"
NOTICE:  CREATE TABLE will create partition "region_1_prt_region1_2_prt_europe" for table "region_1_prt_region1"
NOTICE:  CREATE TABLE will create partition "region_1_prt_region1_2_prt_mideast" for table "region_1_prt_region1"
NOTICE:  CREATE TABLE will create partition "region_1_prt_region1_2_prt_australia" for table "region_1_prt_region1"
NOTICE:  CREATE TABLE will create partition "region_1_prt_region1_2_prt_antarctica" for table "region_1_prt_region1"
NOTICE:  CREATE TABLE will create partition "region_1_prt_region2" for table "region"
NOTICE:  CREATE TABLE will create partition "region_1_prt_region2_2_prt_africa" for table "region_1_prt_region2"
NOTICE:  CREATE TABLE will create partition "region_1_prt_region2_2_prt_america" for table "region_1_prt_region2"
NOTICE:  CREATE TABLE will create partition "region_1_prt_region2_2_prt_asia" for table "region_1_prt_region2"
NOTICE:  CREATE TABLE will create partition "region_1_prt_region2_2_prt_europe" for table "region_1_prt_region2"
NOTICE:  CREATE TABLE will create partition "region_1_prt_region2_2_prt_mideast" for table "region_1_prt_region2"
NOTICE:  CREATE TABLE will create partition "region_1_prt_region2_2_prt_australia" for table "region_1_prt_region2"
NOTICE:  CREATE TABLE will create partition "region_1_prt_region2_2_prt_antarctica" for table "region_1_prt_region2"
NOTICE:  CREATE TABLE will create partition "region_1_prt_region3" for table "region"
NOTICE:  CREATE TABLE will create partition "region_1_prt_region3_2_prt_africa" for table "region_1_prt_region3"
NOTICE:  CREATE TABLE will create partition "region_1_prt_region3_2_prt_america" for table "region_1_prt_region3"
NOTICE:  CREATE TABLE will create partition "region_1_prt_region3_2_prt_asia" for table "region_1_prt_region3"
NOTICE:  CREATE TABLE will create partition "region_1_prt_region3_2_prt_europe" for table "region_1_prt_region3"
NOTICE:  CREATE TABLE will create partition "region_1_prt_region3_2_prt_mideast" for table "region_1_prt_region3"
NOTICE:  CREATE TABLE will create partition "region_1_prt_region3_2_prt_australia" for table "region_1_prt_region3"
NOTICE:  CREATE TABLE will create partition "region_1_prt_region3_2_prt_antarctica" for table "region_1_prt_region3"
-- root and internal parent partitions should have relfrozenxid as 0
select relname from pg_class where relkind = 'r' and relname like 'region%' and relfrozenxid=0;
       relname        
----------------------
 region
 region_1_prt_region1
 region_1_prt_region2
 region_1_prt_region3
(4 rows)

select gp_segment_id, relname from gp_dist_random('pg_class') where relkind = 'r' and relname like 'region%' and relfrozenxid=0;
 gp_segment_id |       relname        
---------------+----------------------
             1 | region
             1 | region_1_prt_region1
             1 | region_1_prt_region2
             1 | region_1_prt_region3
             2 | region
             2 | region_1_prt_region1
             2 | region_1_prt_region2
             2 | region_1_prt_region3
             0 | region
             0 | region_1_prt_region1
             0 | region_1_prt_region2
             0 | region_1_prt_region3
(12 rows)

create unique index region_pkey on region(r_regionkey);
NOTICE:  building index for child partition "region_1_prt_region1"
NOTICE:  building index for child partition "region_1_prt_region1_2_prt_africa"
NOTICE:  building index for child partition "region_1_prt_region1_2_prt_america"
NOTICE:  building index for child partition "region_1_prt_region1_2_prt_asia"
NOTICE:  building index for child partition "region_1_prt_region1_2_prt_europe"
NOTICE:  building index for child partition "region_1_prt_region1_2_prt_mideast"
NOTICE:  building index for child partition "region_1_prt_region1_2_prt_australia"
NOTICE:  building index for child partition "region_1_prt_region1_2_prt_antarctica"
NOTICE:  building index for child partition "region_1_prt_region2"
NOTICE:  building index for child partition "region_1_prt_region2_2_prt_africa"
NOTICE:  building index for child partition "region_1_prt_region2_2_prt_america"
NOTICE:  building index for child partition "region_1_prt_region2_2_prt_asia"
NOTICE:  building index for child partition "region_1_prt_region2_2_prt_europe"
NOTICE:  building index for child partition "region_1_prt_region2_2_prt_mideast"
NOTICE:  building index for child partition "region_1_prt_region2_2_prt_australia"
NOTICE:  building index for child partition "region_1_prt_region2_2_prt_antarctica"
NOTICE:  building index for child partition "region_1_prt_region3" for table "region"
NOTICE:  building index for child partition "region_1_prt_region3_2_prt_africa"
NOTICE:  building index for child partition "region_1_prt_region3_2_prt_america"
NOTICE:  building index for child partition "region_1_prt_region3_2_prt_asia"
NOTICE:  building index for child partition "region_1_prt_region3_2_prt_europe"
NOTICE:  building index for child partition "region_1_prt_region3_2_prt_mideast"
NOTICE:  building index for child partition "region_1_prt_region3_2_prt_australia"
NOTICE:  building index for child partition "region_1_prt_region3_2_prt_antarctica"
copy region from stdin with delimiter '|';
-- Test indexes
set enable_seqscan to off;
select * from region where r_regionkey = 1;
 r_regionkey |          r_name           |            r_comment            
-------------+---------------------------+---------------------------------
           1 | AMERICA                   | hs use ironic, even requests. s
(1 row)

select * from region where r_regionkey = 2;
 r_regionkey |          r_name           |            r_comment            
-------------+---------------------------+---------------------------------
           2 | ASIA                      | ges. thinly even pinto beans ca
(1 row)

select * from region where r_regionkey = 3;
 r_regionkey |          r_name           |                   r_comment                   
-------------+---------------------------+-----------------------------------------------
           3 | EUROPE                    | ly final courts cajole furiously final excuse
(1 row)

select * from region where r_regionkey = 4;
 r_regionkey |          r_name           |                        r_comment                         
-------------+---------------------------+----------------------------------------------------------
           4 | MIDDLE EAST               | uickly special accounts cajole carefully blithely close 
(1 row)

select * from region where r_regionkey = 5;
 r_regionkey |          r_name           | r_comment 
-------------+---------------------------+-----------
           5 | AUSTRALIA                 | sdf
(1 row)

select * from region where r_regionkey = 6;
 r_regionkey |          r_name           | r_comment 
-------------+---------------------------+-----------
           6 | ANTARCTICA                | dsfdfg
(1 row)

-- Test indexes with insert
insert into region values(7, 'AUSTRALIA', 'def');
select * from region where r_regionkey = '7';
 r_regionkey |          r_name           | r_comment 
-------------+---------------------------+-----------
           7 | AUSTRALIA                 | def
(1 row)

-- test duplicate key. We shouldn't really allow primary keys on partitioned
-- tables since we cannot enforce them. But since this insert maps to a
-- single definitive partition, we can detect it.
insert into region values(7, 'AUSTRALIA', 'def');
ERROR:  duplicate key value violates unique constraint "region_1_prt_region3_2_prt_australia_r_regionkey_idx"  (seg0 127.0.1.1:25432 pid=1617)
DETAIL:  Key (r_regionkey)=(7) already exists.
drop table region;
-- exchange
-- 1) test all sanity checking
create table foo_p (i int, j int) distributed by (i)
partition by range(j)
(start(1) end(10) every(1));
NOTICE:  CREATE TABLE will create partition "foo_p_1_prt_1" for table "foo_p"
NOTICE:  CREATE TABLE will create partition "foo_p_1_prt_2" for table "foo_p"
NOTICE:  CREATE TABLE will create partition "foo_p_1_prt_3" for table "foo_p"
NOTICE:  CREATE TABLE will create partition "foo_p_1_prt_4" for table "foo_p"
NOTICE:  CREATE TABLE will create partition "foo_p_1_prt_5" for table "foo_p"
NOTICE:  CREATE TABLE will create partition "foo_p_1_prt_6" for table "foo_p"
NOTICE:  CREATE TABLE will create partition "foo_p_1_prt_7" for table "foo_p"
NOTICE:  CREATE TABLE will create partition "foo_p_1_prt_8" for table "foo_p"
NOTICE:  CREATE TABLE will create partition "foo_p_1_prt_9" for table "foo_p"
-- policies are different
create table bar_p_diff_pol (i int, j int) distributed by (j);
-- should fail
alter table foo_p exchange partition for(rank(6)) with table bar_p_diff_pol;
ERROR:  distribution policy for "bar_p_diff_pol" must be the same as that for "foo_p"
-- random policy vs. hash policy
create table bar_p_rand_pol (i int, j int) distributed randomly;
-- should fail
alter table foo_p exchange partition for(rank(6)) with table bar_p_rand_pol;
ERROR:  distribution policy for "bar_p_rand_pol" must be the same as that for "foo_p"
-- different number of columns
create table bar_p_diff_col (i int, j int, k int) distributed by (i);
-- should fail
alter table foo_p exchange partition for(rank(6)) with table bar_p_diff_col;
ERROR:  relation "bar_p_diff_col" must have the same number columns as relation "foo_p"
-- different types
create table bar_p_diff_typ (i int, j int8) distributed by (i);
-- should fail
alter table foo_p exchange partition for(rank(6)) with table bar_p_diff_typ;
ERROR:  type mismatch for attribute "j"
-- different column names
create table bar_p_diff_colnam (i int, m int) distributed by (i);
-- should fail
alter table foo_p exchange partition for(rank(6)) with table bar_p_diff_colnam;
ERROR:  relation "bar_p_diff_colnam" must have the same column names and column order as "foo_p"
-- still different schema, but more than one level partitioning
CREATE TABLE two_level_pt(a int, b int, c int)
DISTRIBUTED BY (a)
PARTITION BY RANGE (b)
      SUBPARTITION BY RANGE (c)
      SUBPARTITION TEMPLATE (
      START (11) END (12) EVERY (1))
      ( START (1) END (2) EVERY (1));
NOTICE:  CREATE TABLE will create partition "two_level_pt_1_prt_1" for table "two_level_pt"
NOTICE:  CREATE TABLE will create partition "two_level_pt_1_prt_1_2_prt_1" for table "two_level_pt_1_prt_1"
CREATE TABLE candidate_for_leaf(a int, c int);
NOTICE:  Table doesn't have 'DISTRIBUTED BY' clause -- Using column named 'a' as the Greenplum Database data distribution key for this table.
HINT:  The 'DISTRIBUTED BY' clause determines the distribution of data. Make sure column(s) chosen are the optimal data distribution key to minimize skew.
-- should fail
ALTER TABLE two_level_pt ALTER PARTITION FOR (1)
      EXCHANGE PARTITION FOR (11) WITH TABLE candidate_for_leaf;
ERROR:  relation "candidate_for_leaf" must have the same column names and column order as "two_level_pt"
-- different owner 
create role part_role;
NOTICE:  resource queue required -- using default resource queue "pg_default"
create table bar_p (i int, j int) distributed by (i);
set session authorization part_role;
-- should fail
alter table foo_p exchange partition for(rank(6)) with table bar_p;
ERROR:  must be owner of relation foo_p
-- back to superuser
\c -
alter table bar_p owner to part_role;
set session authorization part_role;
-- should fail
alter table foo_p exchange partition for(rank(6)) with table bar_p;
ERROR:  must be owner of relation foo_p
\c -
-- owners should be the same, error out 
alter table foo_p exchange partition for(rank(6)) with table bar_p;
ERROR:  owner of "bar_p" must be the same as that of "foo_p"
drop table foo_p;
drop table bar_p;
-- should work, and new partition should inherit ownership (mpp-6538)
set role part_role;
create table foo_p (i int, j int) distributed by (i)
partition by range(j)
(start(1) end(6) every(3));
reset role;
alter table foo_p split partition for(rank(1)) at (2) into (partition prt_11, partition prt_12);
\dt foo_*
                     List of relations
 Schema |        Name        | Type  |   Owner   | Storage 
--------+--------------------+-------+-----------+---------
 public | foo_p              | table | part_role | heap
 public | foo_p_1_prt_2      | table | part_role | heap
 public | foo_p_1_prt_prt_11 | table | part_role | heap
 public | foo_p_1_prt_prt_12 | table | part_role | heap
(4 rows)

drop table foo_p;
drop role part_role;
-- with and without OIDs
-- MPP-8405: disallow OIDS on partitioned tables 
create table foo_p (i int, j int) with (oids = true) distributed by (i)
partition by range(j)
(start(1) end(10) every(1));
NOTICE:  CREATE TABLE will create partition "foo_p_1_prt_1" for table "foo_p"
NOTICE:  CREATE TABLE will create partition "foo_p_1_prt_2" for table "foo_p"
NOTICE:  CREATE TABLE will create partition "foo_p_1_prt_3" for table "foo_p"
NOTICE:  CREATE TABLE will create partition "foo_p_1_prt_4" for table "foo_p"
NOTICE:  CREATE TABLE will create partition "foo_p_1_prt_5" for table "foo_p"
NOTICE:  CREATE TABLE will create partition "foo_p_1_prt_6" for table "foo_p"
NOTICE:  CREATE TABLE will create partition "foo_p_1_prt_7" for table "foo_p"
NOTICE:  CREATE TABLE will create partition "foo_p_1_prt_8" for table "foo_p"
NOTICE:  CREATE TABLE will create partition "foo_p_1_prt_9" for table "foo_p"
ERROR:  OIDS=TRUE is not allowed on partitioned tables
HINT:  Use OIDS=FALSE.
-- but disallow exchange if different oid settings
create table foo_p (i int, j int) with (oids = false) distributed by (i)
partition by range(j)
(start(1) end(10) every(1));
NOTICE:  CREATE TABLE will create partition "foo_p_1_prt_1" for table "foo_p"
NOTICE:  CREATE TABLE will create partition "foo_p_1_prt_2" for table "foo_p"
NOTICE:  CREATE TABLE will create partition "foo_p_1_prt_3" for table "foo_p"
NOTICE:  CREATE TABLE will create partition "foo_p_1_prt_4" for table "foo_p"
NOTICE:  CREATE TABLE will create partition "foo_p_1_prt_5" for table "foo_p"
NOTICE:  CREATE TABLE will create partition "foo_p_1_prt_6" for table "foo_p"
NOTICE:  CREATE TABLE will create partition "foo_p_1_prt_7" for table "foo_p"
NOTICE:  CREATE TABLE will create partition "foo_p_1_prt_8" for table "foo_p"
NOTICE:  CREATE TABLE will create partition "foo_p_1_prt_9" for table "foo_p"
create table bar_p (i int, j int) with (oids = true) distributed by (i);
NOTICE:  OIDS=TRUE is not recommended for user-created tables
HINT:  Use OIDS=FALSE to prevent wrap-around of the OID counter.
-- should fail
alter table foo_p exchange partition for(rank(6)) with table bar_p;
ERROR:  "foo_p" and "bar_p" must have same OIDs setting
drop table foo_p;
drop table bar_p;
-- non-partition table involved in inheritance
create table foo_p (i int, j int) distributed by (i)
partition by range(j)
(start(1) end(10) every(1));
NOTICE:  CREATE TABLE will create partition "foo_p_1_prt_1" for table "foo_p"
NOTICE:  CREATE TABLE will create partition "foo_p_1_prt_2" for table "foo_p"
NOTICE:  CREATE TABLE will create partition "foo_p_1_prt_3" for table "foo_p"
NOTICE:  CREATE TABLE will create partition "foo_p_1_prt_4" for table "foo_p"
NOTICE:  CREATE TABLE will create partition "foo_p_1_prt_5" for table "foo_p"
NOTICE:  CREATE TABLE will create partition "foo_p_1_prt_6" for table "foo_p"
NOTICE:  CREATE TABLE will create partition "foo_p_1_prt_7" for table "foo_p"
NOTICE:  CREATE TABLE will create partition "foo_p_1_prt_8" for table "foo_p"
NOTICE:  CREATE TABLE will create partition "foo_p_1_prt_9" for table "foo_p"
create table barparent(i int, j int) distributed by (i);
create table bar_p () inherits(barparent);
NOTICE:  table has parent, setting distribution columns to match parent table
-- should fail
alter table foo_p exchange partition for(rank(6)) with table bar_p;
ERROR:  cannot exchange table "bar_p" as it inherits other table(s)
drop table bar_p;
drop table barparent;
-- non-partition table involved in inheritance
create table bar_p(i int, j int) distributed by (i);
create table barchild () inherits(bar_p);
NOTICE:  table has parent, setting distribution columns to match parent table
-- should fail
alter table foo_p exchange partition for(rank(6)) with table bar_p;
ERROR:  cannot EXCHANGE table "bar_p" as it has child table(s)
drop table barchild;
drop table bar_p;
-- rules on non-partition table
create table bar_p(i int, j int) distributed by (i);
create table baz_p(i int, j int) distributed by (i);
create rule bar_baz as on insert to bar_p do instead insert into baz_p
  values(NEW.i, NEW.j);
alter table foo_p exchange partition for(rank(2)) with table bar_p;
ERROR:  cannot exchange table which has rules defined on it
drop table foo_p, bar_p, baz_p;
-- Should fail: A constraint on bar_p isn't shared by all the parts.  
-- Allowing this would make an inconsistent partitioned table.  Note
-- that it is possible to have a constraint that prevents rows from 
-- going into one or more parts.  This isn't a conflict, though prior
-- versions would fail because "a constraint on bar_p conflicts with
-- partitioning rule". 
create table foo_p (i int, j int) distributed by (i)
partition by range(j)
(start(1) end(5) every(1));
NOTICE:  CREATE TABLE will create partition "foo_p_1_prt_1" for table "foo_p"
NOTICE:  CREATE TABLE will create partition "foo_p_1_prt_2" for table "foo_p"
NOTICE:  CREATE TABLE will create partition "foo_p_1_prt_3" for table "foo_p"
NOTICE:  CREATE TABLE will create partition "foo_p_1_prt_4" for table "foo_p"
create table bar_a(i int, j int check (j > 1000)) distributed by (i);
alter table foo_p exchange partition for(rank(2)) with table bar_a;
ERROR:  invalid constraint(s) found on "bar_a": "bar_a_j_check"
HINT:  drop the invalid constraints and retry
-- Should fail: A constraint on bar_p isn't shared by all the parts.
-- Allowing this would make an inconsistent partitioned table. 
-- Prior versions allowed this, so parts could have differing constraints
-- as long as they avoided the partition columns.
create table bar_b(i int check (i > 1000), j int) distributed by (i);
alter table foo_p exchange partition for(rank(2)) with table bar_b;
ERROR:  invalid constraint(s) found on "bar_b": "bar_b_i_check"
HINT:  drop the invalid constraints and retry
-- like above, but with two contraints, just to check that the error
-- message can print that correctly.
create table bar_c(i int check (i > 1000), j int check (j > 1000)) distributed by (i);
alter table foo_p exchange partition for(rank(2)) with table bar_c;
ERROR:  invalid constraint(s) found on "bar_c": "bar_c_j_check", "bar_c_i_check"
HINT:  drop the invalid constraints and retry
-- Shouldn't fail: check constraint matches partition rule.
-- Note this test is slightly different from prior versions to get
-- in line with constraint consistency requirement.
create table bar_d(i int, j int check (j >= 2 and j < 3 ))
distributed by (i);
insert into bar_d values(100000, 2);
alter table foo_p exchange partition for(rank(2)) with table bar_d;
insert into bar_d values(200000, 2);
select * from bar_d;
   i    | j 
--------+---
 200000 | 2
(1 row)

drop table foo_p, bar_a, bar_b, bar_c, bar_d;
-- permissions
create role part_role;
NOTICE:  resource queue required -- using default resource queue "pg_default"
create table foo_p (i int) partition by range(i)
(start(1) end(10) every(1));
NOTICE:  Table doesn't have 'DISTRIBUTED BY' clause -- Using column named 'i' as the Greenplum Database data distribution key for this table.
HINT:  The 'DISTRIBUTED BY' clause determines the distribution of data. Make sure column(s) chosen are the optimal data distribution key to minimize skew.
NOTICE:  CREATE TABLE will create partition "foo_p_1_prt_1" for table "foo_p"
NOTICE:  CREATE TABLE will create partition "foo_p_1_prt_2" for table "foo_p"
NOTICE:  CREATE TABLE will create partition "foo_p_1_prt_3" for table "foo_p"
NOTICE:  CREATE TABLE will create partition "foo_p_1_prt_4" for table "foo_p"
NOTICE:  CREATE TABLE will create partition "foo_p_1_prt_5" for table "foo_p"
NOTICE:  CREATE TABLE will create partition "foo_p_1_prt_6" for table "foo_p"
NOTICE:  CREATE TABLE will create partition "foo_p_1_prt_7" for table "foo_p"
NOTICE:  CREATE TABLE will create partition "foo_p_1_prt_8" for table "foo_p"
NOTICE:  CREATE TABLE will create partition "foo_p_1_prt_9" for table "foo_p"
create table bar_p (i int);
NOTICE:  Table doesn't have 'DISTRIBUTED BY' clause -- Using column named 'i' as the Greenplum Database data distribution key for this table.
HINT:  The 'DISTRIBUTED BY' clause determines the distribution of data. Make sure column(s) chosen are the optimal data distribution key to minimize skew.
grant select on foo_p to part_role;
revoke all on bar_p from part_role;
NOTICE:  no privileges could be revoked
select has_table_privilege('part_role', 'foo_p_1_prt_6'::regclass, 'select');
 has_table_privilege 
---------------------
 t
(1 row)

select has_table_privilege('part_role', 'bar_p'::regclass, 'select');
 has_table_privilege 
---------------------
 f
(1 row)

alter table foo_p exchange partition for(rank(6)) with table bar_p;
select has_table_privilege('part_role', 'foo_p_1_prt_6'::regclass, 'select');
 has_table_privilege 
---------------------
 t
(1 row)

select has_table_privilege('part_role', 'bar_p'::regclass, 'select');
 has_table_privilege 
---------------------
 f
(1 row)

drop table foo_p;
drop table bar_p;
drop role part_role;
-- validation
create table foo_p (i int) partition by range(i)
(start(1) end(10) every(1));
NOTICE:  Table doesn't have 'DISTRIBUTED BY' clause -- Using column named 'i' as the Greenplum Database data distribution key for this table.
HINT:  The 'DISTRIBUTED BY' clause determines the distribution of data. Make sure column(s) chosen are the optimal data distribution key to minimize skew.
NOTICE:  CREATE TABLE will create partition "foo_p_1_prt_1" for table "foo_p"
NOTICE:  CREATE TABLE will create partition "foo_p_1_prt_2" for table "foo_p"
NOTICE:  CREATE TABLE will create partition "foo_p_1_prt_3" for table "foo_p"
NOTICE:  CREATE TABLE will create partition "foo_p_1_prt_4" for table "foo_p"
NOTICE:  CREATE TABLE will create partition "foo_p_1_prt_5" for table "foo_p"
NOTICE:  CREATE TABLE will create partition "foo_p_1_prt_6" for table "foo_p"
NOTICE:  CREATE TABLE will create partition "foo_p_1_prt_7" for table "foo_p"
NOTICE:  CREATE TABLE will create partition "foo_p_1_prt_8" for table "foo_p"
NOTICE:  CREATE TABLE will create partition "foo_p_1_prt_9" for table "foo_p"
create table bar_p (i int);
NOTICE:  Table doesn't have 'DISTRIBUTED BY' clause -- Using column named 'i' as the Greenplum Database data distribution key for this table.
HINT:  The 'DISTRIBUTED BY' clause determines the distribution of data. Make sure column(s) chosen are the optimal data distribution key to minimize skew.
insert into bar_p values(6);
insert into bar_p values(100);
-- should fail
alter table foo_p exchange partition for(rank(6)) with table bar_p;
ERROR:  exchange table contains a row which violates the partitioning specification of "foo_p"  (seg1 slarimac:40001 pid=97876)
alter table foo_p exchange partition for(rank(6)) with table bar_p without
validation;
select * from foo_p;
  i  
-----
   6
 100
(2 rows)

drop table foo_p, bar_p;
-- basic test
create table foo_p (i int, j int) distributed by (i)
partition by range(j)
(start(1) end(10) every(1));
NOTICE:  CREATE TABLE will create partition "foo_p_1_prt_1" for table "foo_p"
NOTICE:  CREATE TABLE will create partition "foo_p_1_prt_2" for table "foo_p"
NOTICE:  CREATE TABLE will create partition "foo_p_1_prt_3" for table "foo_p"
NOTICE:  CREATE TABLE will create partition "foo_p_1_prt_4" for table "foo_p"
NOTICE:  CREATE TABLE will create partition "foo_p_1_prt_5" for table "foo_p"
NOTICE:  CREATE TABLE will create partition "foo_p_1_prt_6" for table "foo_p"
NOTICE:  CREATE TABLE will create partition "foo_p_1_prt_7" for table "foo_p"
NOTICE:  CREATE TABLE will create partition "foo_p_1_prt_8" for table "foo_p"
NOTICE:  CREATE TABLE will create partition "foo_p_1_prt_9" for table "foo_p"
create table bar_p(i int, j int) distributed by (i);
insert into bar_p values(6);
alter table foo_p exchange partition for(rank(6)) with table bar_p;
select * from foo_p;
 i | j 
---+---
 6 |  
(1 row)

select * from bar_p;
 i | j 
---+---
(0 rows)

-- test that we got the dependencies right
drop table bar_p;
select * from foo_p;
 i | j 
---+---
 6 |  
(1 row)

drop table foo_p;
create table foo_p (i int, j int) distributed by (i)
partition by range(j)
(start(1) end(10) every(1));
NOTICE:  CREATE TABLE will create partition "foo_p_1_prt_1" for table "foo_p"
NOTICE:  CREATE TABLE will create partition "foo_p_1_prt_2" for table "foo_p"
NOTICE:  CREATE TABLE will create partition "foo_p_1_prt_3" for table "foo_p"
NOTICE:  CREATE TABLE will create partition "foo_p_1_prt_4" for table "foo_p"
NOTICE:  CREATE TABLE will create partition "foo_p_1_prt_5" for table "foo_p"
NOTICE:  CREATE TABLE will create partition "foo_p_1_prt_6" for table "foo_p"
NOTICE:  CREATE TABLE will create partition "foo_p_1_prt_7" for table "foo_p"
NOTICE:  CREATE TABLE will create partition "foo_p_1_prt_8" for table "foo_p"
NOTICE:  CREATE TABLE will create partition "foo_p_1_prt_9" for table "foo_p"
create table bar_p(i int, j int) distributed by (i);
insert into bar_p values(6, 6);
alter table foo_p exchange partition for(rank(6)) with table bar_p;
-- Should fail.  Prior releases didn't convey constraints out via exchange
-- but we do now, so the following tries to insert a value that can't go
-- in part 6.
insert into bar_p values(10, 10);
ERROR:  new row for relation "bar_p" violates check constraint "foo_p_1_prt_6_check"  (seg2 127.0.0.1:25434 pid=10977)
DETAIL:  Failing row contains (10, 10).
drop table foo_p;
select * from bar_p;
 i | j 
---+---
(0 rows)

-- Should succeed.  Conveyed constraint matches.
insert into bar_p values(6, 6);
select * from bar_p;
 i | j 
---+---
 6 | 6
(1 row)

drop table bar_p;
-- AO exchange with heap
create table foo_p (i int, j int) with(appendonly = true) distributed by (i)
partition by range(j)
(start(1) end(10) every(1));
NOTICE:  CREATE TABLE will create partition "foo_p_1_prt_1" for table "foo_p"
NOTICE:  CREATE TABLE will create partition "foo_p_1_prt_2" for table "foo_p"
NOTICE:  CREATE TABLE will create partition "foo_p_1_prt_3" for table "foo_p"
NOTICE:  CREATE TABLE will create partition "foo_p_1_prt_4" for table "foo_p"
NOTICE:  CREATE TABLE will create partition "foo_p_1_prt_5" for table "foo_p"
NOTICE:  CREATE TABLE will create partition "foo_p_1_prt_6" for table "foo_p"
NOTICE:  CREATE TABLE will create partition "foo_p_1_prt_7" for table "foo_p"
NOTICE:  CREATE TABLE will create partition "foo_p_1_prt_8" for table "foo_p"
NOTICE:  CREATE TABLE will create partition "foo_p_1_prt_9" for table "foo_p"
create table bar_p(i int, j int) distributed by (i);
insert into foo_p values(1, 1), (2, 1), (3, 1);
insert into bar_p values(6, 6);
alter table foo_p exchange partition for(rank(6)) with table bar_p;
select * from foo_p;
 i | j 
---+---
 2 | 1
 6 | 6
 1 | 1
 3 | 1
(4 rows)

drop table bar_p;
drop table foo_p;
-- other way around
create table foo_p (i int, j int) with(appendonly = false) distributed by (i)
partition by range(j)
(start(1) end(10) every(1));
NOTICE:  CREATE TABLE will create partition "foo_p_1_prt_1" for table "foo_p"
NOTICE:  CREATE TABLE will create partition "foo_p_1_prt_2" for table "foo_p"
NOTICE:  CREATE TABLE will create partition "foo_p_1_prt_3" for table "foo_p"
NOTICE:  CREATE TABLE will create partition "foo_p_1_prt_4" for table "foo_p"
NOTICE:  CREATE TABLE will create partition "foo_p_1_prt_5" for table "foo_p"
NOTICE:  CREATE TABLE will create partition "foo_p_1_prt_6" for table "foo_p"
NOTICE:  CREATE TABLE will create partition "foo_p_1_prt_7" for table "foo_p"
NOTICE:  CREATE TABLE will create partition "foo_p_1_prt_8" for table "foo_p"
NOTICE:  CREATE TABLE will create partition "foo_p_1_prt_9" for table "foo_p"
create table bar_p(i int, j int) with(appendonly = true) distributed by (i);
insert into foo_p values(1, 1), (2, 1), (3, 2);
insert into bar_p values(6, 6);
alter table foo_p exchange partition for(rank(6)) with table bar_p;
select * from foo_p;
 i | j 
---+---
 1 | 1
 3 | 2
 2 | 1
 6 | 6
(4 rows)

drop table bar_p;
drop table foo_p;
-- exchange AO with AO
create table foo_p (i int, j int) with(appendonly = true) distributed by (i)
partition by range(j)
(start(1) end(10) every(1));
NOTICE:  CREATE TABLE will create partition "foo_p_1_prt_1" for table "foo_p"
NOTICE:  CREATE TABLE will create partition "foo_p_1_prt_2" for table "foo_p"
NOTICE:  CREATE TABLE will create partition "foo_p_1_prt_3" for table "foo_p"
NOTICE:  CREATE TABLE will create partition "foo_p_1_prt_4" for table "foo_p"
NOTICE:  CREATE TABLE will create partition "foo_p_1_prt_5" for table "foo_p"
NOTICE:  CREATE TABLE will create partition "foo_p_1_prt_6" for table "foo_p"
NOTICE:  CREATE TABLE will create partition "foo_p_1_prt_7" for table "foo_p"
NOTICE:  CREATE TABLE will create partition "foo_p_1_prt_8" for table "foo_p"
NOTICE:  CREATE TABLE will create partition "foo_p_1_prt_9" for table "foo_p"
create table bar_p(i int, j int) with(appendonly = true) distributed by (i);
insert into foo_p values(1, 2), (2, 3), (3, 4);
insert into bar_p values(6, 6);
alter table foo_p exchange partition for(rank(6)) with table bar_p;
select * from foo_p;
 i | j 
---+---
 2 | 3
 6 | 6
 1 | 2
 3 | 4
(4 rows)

drop table bar_p;
drop table foo_p;
-- exchange same table more than once
create table foo_p (i int, j int) distributed by (i)
partition by range(j)
(start(1) end(10) every(1));
NOTICE:  CREATE TABLE will create partition "foo_p_1_prt_1" for table "foo_p"
NOTICE:  CREATE TABLE will create partition "foo_p_1_prt_2" for table "foo_p"
NOTICE:  CREATE TABLE will create partition "foo_p_1_prt_3" for table "foo_p"
NOTICE:  CREATE TABLE will create partition "foo_p_1_prt_4" for table "foo_p"
NOTICE:  CREATE TABLE will create partition "foo_p_1_prt_5" for table "foo_p"
NOTICE:  CREATE TABLE will create partition "foo_p_1_prt_6" for table "foo_p"
NOTICE:  CREATE TABLE will create partition "foo_p_1_prt_7" for table "foo_p"
NOTICE:  CREATE TABLE will create partition "foo_p_1_prt_8" for table "foo_p"
NOTICE:  CREATE TABLE will create partition "foo_p_1_prt_9" for table "foo_p"
create table bar_p(i int, j int) distributed by (i);
insert into bar_p values(6, 6);
alter table foo_p exchange partition for(rank(6)) with table bar_p;
select * from foo_p;
 i | j 
---+---
 6 | 6
(1 row)

select * from bar_p;
 i | j 
---+---
(0 rows)

alter table foo_p exchange partition for(rank(6)) with table bar_p;
select * from foo_p;
 i | j 
---+---
(0 rows)

select * from bar_p;
 i | j 
---+---
 6 | 6
(1 row)

alter table foo_p exchange partition for(rank(6)) with table bar_p;
select * from foo_p;
 i | j 
---+---
 6 | 6
(1 row)

select * from bar_p;
 i | j 
---+---
(0 rows)

drop table foo_p;
drop table bar_p;
-- exchange default partition is not allowed (single level)
drop table if exists dex;
NOTICE:  table "dex" does not exist, skipping
drop table if exists exh_abc;
NOTICE:  table "exh_abc" does not exist, skipping
create table dex (i int,  j int) partition by range(j)
(partition a start (1) end(10), partition b start(11) end(20),
default partition abc);
NOTICE:  table doesn't have 'DISTRIBUTED BY' clause -- Using column named 'i' as the Greenplum Database data distribution key for this table.
HINT:  The 'DISTRIBUTED BY' clause determines the distribution of data. Make sure column(s) chosen are the optimal data distribution key to minimize skew.
NOTICE:  CREATE TABLE will create partition "dex_1_prt_abc" for table "dex"
NOTICE:  CREATE TABLE will create partition "dex_1_prt_a" for table "dex"
NOTICE:  CREATE TABLE will create partition "dex_1_prt_b" for table "dex"
create table exh_abc (like dex);
NOTICE:  table doesn't have 'DISTRIBUTED BY' clause, defaulting to distribution columns from LIKE table
alter table dex exchange default partition with table exh_abc;
ERROR:  cannot exchange DEFAULT partition
set gp_enable_exchange_default_partition = on;
alter table dex exchange default partition with table exh_abc;
WARNING:  Exchanging default partition may result in unexpected query results if the data being exchanged should have been inserted into a different partition
NOTICE:  exchanged partition "abc" of relation "dex" with relation "exh_abc"
reset gp_enable_exchange_default_partition;
drop table dex;
drop table exh_abc;
-- exchange default partition is not allowed (multi level)
Drop table if exists sto_ao_ao;
NOTICE:  table "sto_ao_ao" does not exist, skipping
drop table if exists exh_ao_ao;
NOTICE:  table "exh_ao_ao" does not exist, skipping
Create table sto_ao_ao
 (
 col1 bigint, col2 date, col3 text, col4 int) with(appendonly=true)
 distributed randomly  partition by range(col2)
 subpartition by list (col3)
 subpartition template ( default subpartition subothers, subpartition sub1 values ('one'), subpartition sub2 values ('two'))
 (default partition others, start(date '2008-01-01') end(date '2008-04-30') every(interval '1 month'));
NOTICE:  CREATE TABLE will create partition "sto_ao_ao_1_prt_others" for table "sto_ao_ao"
NOTICE:  CREATE TABLE will create partition "sto_ao_ao_1_prt_others_2_prt_subothers" for table "sto_ao_ao_1_prt_others"
NOTICE:  CREATE TABLE will create partition "sto_ao_ao_1_prt_others_2_prt_sub1" for table "sto_ao_ao_1_prt_others"
NOTICE:  CREATE TABLE will create partition "sto_ao_ao_1_prt_others_2_prt_sub2" for table "sto_ao_ao_1_prt_others"
NOTICE:  CREATE TABLE will create partition "sto_ao_ao_1_prt_2" for table "sto_ao_ao"
NOTICE:  CREATE TABLE will create partition "sto_ao_ao_1_prt_2_2_prt_subothers" for table "sto_ao_ao_1_prt_2"
NOTICE:  CREATE TABLE will create partition "sto_ao_ao_1_prt_2_2_prt_sub1" for table "sto_ao_ao_1_prt_2"
NOTICE:  CREATE TABLE will create partition "sto_ao_ao_1_prt_2_2_prt_sub2" for table "sto_ao_ao_1_prt_2"
NOTICE:  CREATE TABLE will create partition "sto_ao_ao_1_prt_3" for table "sto_ao_ao"
NOTICE:  CREATE TABLE will create partition "sto_ao_ao_1_prt_3_2_prt_subothers" for table "sto_ao_ao_1_prt_3"
NOTICE:  CREATE TABLE will create partition "sto_ao_ao_1_prt_3_2_prt_sub1" for table "sto_ao_ao_1_prt_3"
NOTICE:  CREATE TABLE will create partition "sto_ao_ao_1_prt_3_2_prt_sub2" for table "sto_ao_ao_1_prt_3"
NOTICE:  CREATE TABLE will create partition "sto_ao_ao_1_prt_4" for table "sto_ao_ao"
NOTICE:  CREATE TABLE will create partition "sto_ao_ao_1_prt_4_2_prt_subothers" for table "sto_ao_ao_1_prt_4"
NOTICE:  CREATE TABLE will create partition "sto_ao_ao_1_prt_4_2_prt_sub1" for table "sto_ao_ao_1_prt_4"
NOTICE:  CREATE TABLE will create partition "sto_ao_ao_1_prt_4_2_prt_sub2" for table "sto_ao_ao_1_prt_4"
NOTICE:  CREATE TABLE will create partition "sto_ao_ao_1_prt_5" for table "sto_ao_ao"
NOTICE:  CREATE TABLE will create partition "sto_ao_ao_1_prt_5_2_prt_subothers" for table "sto_ao_ao_1_prt_5"
NOTICE:  CREATE TABLE will create partition "sto_ao_ao_1_prt_5_2_prt_sub1" for table "sto_ao_ao_1_prt_5"
NOTICE:  CREATE TABLE will create partition "sto_ao_ao_1_prt_5_2_prt_sub2" for table "sto_ao_ao_1_prt_5"
-- Non-leaf (empty) partitions along with their auxiliary tables
-- should have relfrozenxid = 0.  Select the names of those tables
-- within this partition hierarchy whose aoseg auxiliary tables have
-- relfrozenxid = 0.
select c1.relname from pg_appendonly a, pg_class c1, pg_class c2 where
c1.oid = a.relid and c1.relname like 'sto_ao_ao%' and c2.relfrozenxid = 0 and a.segrelid = c2.oid;
        relname         
------------------------
 sto_ao_ao_1_prt_2
 sto_ao_ao
 sto_ao_ao_1_prt_others
 sto_ao_ao_1_prt_3
 sto_ao_ao_1_prt_4
 sto_ao_ao_1_prt_5
(6 rows)

-- Same query as above but obtain relnames from segments.
select c2.gp_segment_id, c1.relname from pg_appendonly a, pg_class c1,
gp_dist_random('pg_class') c2 where
c1.oid = a.relid and c1.relname like 'sto_ao_ao%' and c2.relfrozenxid = 0 and a.segrelid = c2.oid;
 gp_segment_id |        relname         
---------------+------------------------
             1 | sto_ao_ao_1_prt_2
             1 | sto_ao_ao
             1 | sto_ao_ao_1_prt_others
             1 | sto_ao_ao_1_prt_3
             1 | sto_ao_ao_1_prt_4
             1 | sto_ao_ao_1_prt_5
             2 | sto_ao_ao_1_prt_2
             2 | sto_ao_ao
             2 | sto_ao_ao_1_prt_others
             2 | sto_ao_ao_1_prt_3
             2 | sto_ao_ao_1_prt_4
             2 | sto_ao_ao_1_prt_5
             0 | sto_ao_ao_1_prt_2
             0 | sto_ao_ao
             0 | sto_ao_ao_1_prt_others
             0 | sto_ao_ao_1_prt_3
             0 | sto_ao_ao_1_prt_4
             0 | sto_ao_ao_1_prt_5
(18 rows)

-- Same two queries as above but for visimap auxiliary table.
select c1.relname from pg_appendonly a, pg_class c1, pg_class c2 where
c1.oid = a.relid and c1.relname like 'sto_ao_ao%' and c2.relfrozenxid = 0 and a.visimaprelid = c2.oid;
        relname         
------------------------
 sto_ao_ao_1_prt_2
 sto_ao_ao
 sto_ao_ao_1_prt_others
 sto_ao_ao_1_prt_3
 sto_ao_ao_1_prt_4
 sto_ao_ao_1_prt_5
(6 rows)

-- Obtain relnames from segments whose visimap tables have relfrozenxid = 0.
select c2.gp_segment_id, c1.relname from pg_appendonly a, pg_class c1,
gp_dist_random('pg_class') c2 where
c1.oid = a.relid and c1.relname like 'sto_ao_ao%' and c2.relfrozenxid = 0 and a.visimaprelid = c2.oid;
 gp_segment_id |        relname         
---------------+------------------------
             0 | sto_ao_ao_1_prt_2
             0 | sto_ao_ao
             0 | sto_ao_ao_1_prt_others
             0 | sto_ao_ao_1_prt_3
             0 | sto_ao_ao_1_prt_4
             0 | sto_ao_ao_1_prt_5
             2 | sto_ao_ao_1_prt_2
             2 | sto_ao_ao
             2 | sto_ao_ao_1_prt_others
             2 | sto_ao_ao_1_prt_3
             2 | sto_ao_ao_1_prt_4
             2 | sto_ao_ao_1_prt_5
             1 | sto_ao_ao_1_prt_2
             1 | sto_ao_ao
             1 | sto_ao_ao_1_prt_others
             1 | sto_ao_ao_1_prt_3
             1 | sto_ao_ao_1_prt_4
             1 | sto_ao_ao_1_prt_5
(18 rows)

-- Same validation toast - select all relnames whose toast tables have relfrozenxid = 0.
select c1.relname from pg_class c1, pg_class c2 where c1.relname like 'sto_ao_ao%' and
c2.relfrozenxid = 0 and c1.reltoastrelid = c2.oid;
        relname         
------------------------
 sto_ao_ao_1_prt_2
 sto_ao_ao
 sto_ao_ao_1_prt_others
 sto_ao_ao_1_prt_3
 sto_ao_ao_1_prt_4
 sto_ao_ao_1_prt_5
(6 rows)

-- Obtain relnames from segments whose toast tables have relfrozenxid = 0.
select c2.gp_segment_id, c1.relname from pg_class c1, gp_dist_random('pg_class') c2 where
c1.relname like 'sto_ao_ao%' and c2.relfrozenxid = 0 and c1.reltoastrelid = c2.oid;
 gp_segment_id |        relname         
---------------+------------------------
             2 | sto_ao_ao_1_prt_2
             2 | sto_ao_ao
             2 | sto_ao_ao_1_prt_others
             2 | sto_ao_ao_1_prt_3
             2 | sto_ao_ao_1_prt_4
             2 | sto_ao_ao_1_prt_5
             1 | sto_ao_ao_1_prt_2
             1 | sto_ao_ao
             1 | sto_ao_ao_1_prt_others
             1 | sto_ao_ao_1_prt_3
             1 | sto_ao_ao_1_prt_4
             1 | sto_ao_ao_1_prt_5
             0 | sto_ao_ao_1_prt_2
             0 | sto_ao_ao
             0 | sto_ao_ao_1_prt_others
             0 | sto_ao_ao_1_prt_3
             0 | sto_ao_ao_1_prt_4
             0 | sto_ao_ao_1_prt_5
(18 rows)

create table exh_ao_ao (like sto_ao_ao) with (appendonly=true);
NOTICE:  table doesn't have 'DISTRIBUTED BY' clause, defaulting to distribution columns from LIKE table
-- Exchange default sub-partition, should fail
alter table sto_ao_ao alter partition for (rank(3)) exchange default partition with table exh_ao_ao;
ERROR:  cannot exchange DEFAULT partition
set gp_enable_exchange_default_partition = on;
alter table sto_ao_ao alter partition for (rank(3)) exchange default partition with table exh_ao_ao;
WARNING:  Exchanging default partition may result in unexpected query results if the data being exchanged should have been inserted into a different partition
NOTICE:  exchanged partition "subothers" of partition for rank 3 of relation "sto_ao_ao" with relation "exh_ao_ao"
reset gp_enable_exchange_default_partition;
-- Exchange a non-default sub-partition of a default partition, should fail
alter table sto_ao_ao alter default partition exchange partition for ('one') with table exh_ao_ao;
ERROR:  cannot specify a name, rank, or value for a DEFAULT partition in this context
-- Exchange a partition that has sub partitions, should fail.
alter table sto_ao_ao exchange partition for ('2008-01-01') with table exh_ao_ao;
ERROR:  cannot EXCHANGE PARTITION for relation "sto_ao_ao" -- partition has children
-- Alter table that causes rewrite.  Then validate that auxiliary
-- tables of non-leaf partitions still have relfrozenxid = 0.
alter table sto_ao_ao alter column col4 type bigint;
-- aoseg
select c1.relname from pg_appendonly a, pg_class c1, pg_class c2 where
c1.oid = a.relid and c1.relname like 'sto_ao_ao%' and c2.relfrozenxid = 0 and a.segrelid = c2.oid;
        relname         
------------------------
 sto_ao_ao
 sto_ao_ao_1_prt_others
 sto_ao_ao_1_prt_2
 sto_ao_ao_1_prt_3
 sto_ao_ao_1_prt_4
 sto_ao_ao_1_prt_5
(6 rows)

select c2.gp_segment_id, c1.relname from pg_appendonly a, pg_class c1,
gp_dist_random('pg_class') c2 where
c1.oid = a.relid and c1.relname like 'sto_ao_ao%' and c2.relfrozenxid = 0 and a.segrelid = c2.oid;
 gp_segment_id |        relname         
---------------+------------------------
             1 | sto_ao_ao
             1 | sto_ao_ao_1_prt_others
             1 | sto_ao_ao_1_prt_2
             1 | sto_ao_ao_1_prt_3
             1 | sto_ao_ao_1_prt_4
             1 | sto_ao_ao_1_prt_5
             2 | sto_ao_ao
             2 | sto_ao_ao_1_prt_others
             2 | sto_ao_ao_1_prt_2
             2 | sto_ao_ao_1_prt_3
             2 | sto_ao_ao_1_prt_4
             2 | sto_ao_ao_1_prt_5
             0 | sto_ao_ao
             0 | sto_ao_ao_1_prt_others
             0 | sto_ao_ao_1_prt_2
             0 | sto_ao_ao_1_prt_3
             0 | sto_ao_ao_1_prt_4
             0 | sto_ao_ao_1_prt_5
(18 rows)

-- toast
select c1.relname from pg_class c1, pg_class c2 where c1.relname like 'sto_ao_ao%' and
c2.relfrozenxid = 0 and c1.reltoastrelid = c2.oid;
        relname         
------------------------
 sto_ao_ao
 sto_ao_ao_1_prt_others
 sto_ao_ao_1_prt_2
 sto_ao_ao_1_prt_3
 sto_ao_ao_1_prt_4
 sto_ao_ao_1_prt_5
(6 rows)

select c2.gp_segment_id, c1.relname from pg_class c1, gp_dist_random('pg_class') c2 where
c1.relname like 'sto_ao_ao%' and c2.relfrozenxid = 0 and c1.reltoastrelid = c2.oid;
 gp_segment_id |        relname         
---------------+------------------------
             0 | sto_ao_ao
             0 | sto_ao_ao_1_prt_others
             0 | sto_ao_ao_1_prt_2
             0 | sto_ao_ao_1_prt_3
             0 | sto_ao_ao_1_prt_4
             0 | sto_ao_ao_1_prt_5
             1 | sto_ao_ao
             1 | sto_ao_ao_1_prt_others
             1 | sto_ao_ao_1_prt_2
             1 | sto_ao_ao_1_prt_3
             1 | sto_ao_ao_1_prt_4
             1 | sto_ao_ao_1_prt_5
             2 | sto_ao_ao
             2 | sto_ao_ao_1_prt_others
             2 | sto_ao_ao_1_prt_2
             2 | sto_ao_ao_1_prt_3
             2 | sto_ao_ao_1_prt_4
             2 | sto_ao_ao_1_prt_5
(18 rows)

-- XXX: not yet: VALIDATE parameter
-- Exchange a partition with an external table; ensure that we require to use
-- WITHOUT VALIDATION and that the new partition won't be included in TRUNCATE
create table foo_p (i int, j int) distributed by (i) partition by range(j) (start(1) end(10) every(2));
create readable external table bar_p(i int, j int) location ('gpfdist://host.invalid:8000/file') format 'text';
alter table foo_p exchange partition for(rank(3)) with table bar_p;
ERROR:  validation of external tables not supported
HINT:  Use WITHOUT VALIDATION.
alter table foo_p exchange partition for(rank(3)) with table bar_p without validation;
truncate foo_p;
ERROR:  "foo_p_1_prt_3" is an external relation and can't be truncated
drop table foo_p;
drop table bar_p;
-- Check for overflow of circular data types like time
-- Should fail
CREATE TABLE TIME_TBL_HOUR_2 (f1 time(2)) distributed by (f1)
partition by range (f1)
(
  start (time '00:00') end (time '24:00') EVERY (INTERVAL '1 hour')
);
ERROR:  END parameter not reached before type overflows
LINE 4:   start (time '00:00') end (time '24:00') EVERY (INTERVAL '1...
                                    ^
-- Should fail
CREATE TABLE TIME_TBL_HOUR_2 (f1 time(2)) distributed by (f1)
partition by range (f1)
(
  start (time '00:00') end (time '23:59') EVERY (INTERVAL '1 hour')
);
ERROR:  END parameter not reached before type overflows
LINE 4:   start (time '00:00') end (time '23:59') EVERY (INTERVAL '1...
                                    ^
-- Should work
CREATE TABLE TIME_TBL_HOUR_2 (f1 time(2)) distributed by (f1)
partition by range (f1)
(
  start (time '00:00') end (time '23:00') EVERY (INTERVAL '1 hour')
);
NOTICE:  CREATE TABLE will create partition "time_tbl_hour_2_1_prt_1" for table "time_tbl_hour_2"
NOTICE:  CREATE TABLE will create partition "time_tbl_hour_2_1_prt_2" for table "time_tbl_hour_2"
NOTICE:  CREATE TABLE will create partition "time_tbl_hour_2_1_prt_3" for table "time_tbl_hour_2"
NOTICE:  CREATE TABLE will create partition "time_tbl_hour_2_1_prt_4" for table "time_tbl_hour_2"
NOTICE:  CREATE TABLE will create partition "time_tbl_hour_2_1_prt_5" for table "time_tbl_hour_2"
NOTICE:  CREATE TABLE will create partition "time_tbl_hour_2_1_prt_6" for table "time_tbl_hour_2"
NOTICE:  CREATE TABLE will create partition "time_tbl_hour_2_1_prt_7" for table "time_tbl_hour_2"
NOTICE:  CREATE TABLE will create partition "time_tbl_hour_2_1_prt_8" for table "time_tbl_hour_2"
NOTICE:  CREATE TABLE will create partition "time_tbl_hour_2_1_prt_9" for table "time_tbl_hour_2"
NOTICE:  CREATE TABLE will create partition "time_tbl_hour_2_1_prt_10" for table "time_tbl_hour_2"
NOTICE:  CREATE TABLE will create partition "time_tbl_hour_2_1_prt_11" for table "time_tbl_hour_2"
NOTICE:  CREATE TABLE will create partition "time_tbl_hour_2_1_prt_12" for table "time_tbl_hour_2"
NOTICE:  CREATE TABLE will create partition "time_tbl_hour_2_1_prt_13" for table "time_tbl_hour_2"
NOTICE:  CREATE TABLE will create partition "time_tbl_hour_2_1_prt_14" for table "time_tbl_hour_2"
NOTICE:  CREATE TABLE will create partition "time_tbl_hour_2_1_prt_15" for table "time_tbl_hour_2"
NOTICE:  CREATE TABLE will create partition "time_tbl_hour_2_1_prt_16" for table "time_tbl_hour_2"
NOTICE:  CREATE TABLE will create partition "time_tbl_hour_2_1_prt_17" for table "time_tbl_hour_2"
NOTICE:  CREATE TABLE will create partition "time_tbl_hour_2_1_prt_18" for table "time_tbl_hour_2"
NOTICE:  CREATE TABLE will create partition "time_tbl_hour_2_1_prt_19" for table "time_tbl_hour_2"
NOTICE:  CREATE TABLE will create partition "time_tbl_hour_2_1_prt_20" for table "time_tbl_hour_2"
NOTICE:  CREATE TABLE will create partition "time_tbl_hour_2_1_prt_21" for table "time_tbl_hour_2"
NOTICE:  CREATE TABLE will create partition "time_tbl_hour_2_1_prt_22" for table "time_tbl_hour_2"
NOTICE:  CREATE TABLE will create partition "time_tbl_hour_2_1_prt_23" for table "time_tbl_hour_2"
drop table TIME_TBL_HOUR_2;
-- Check for every parameters that just don't make sense
create table hhh_r1 (a char(1), b date, d char(3)) 
distributed by (a) partition by range (b)
(                                                              
partition aa start (date '2007-01-01') end (date '2008-01-01') 
      every (interval '0 days')
);
ERROR:  EVERY parameter too small
LINE 5:       every (interval '0 days')
                     ^
create table foo_p (i int) distributed by(i)
partition by range(i)
(start (1) end (20) every(0));
ERROR:  EVERY parameter too small
LINE 3: (start (1) end (20) every(0));
                                  ^
-- Check for ambiguous EVERY parameters
-- should fail
create table foo_p (i int) distributed by (i)
partition by range(i)
(start (1) end (20) every (0.6));
ERROR:  EVERY parameter produces ambiguous partition rule
LINE 3: (start (1) end (20) every (0.6));
                                   ^
-- should fail
create table foo_p (i int) distributed by (i)
partition by range(i)
(start (1) end (20) every (0.3));
ERROR:  EVERY parameter produces ambiguous partition rule
LINE 3: (start (1) end (20) every (0.3));
                                   ^
-- should fail
create table foo_p (i int) distributed by (i)
partition by range(i)
(start (1) end (20) every (1.3));
ERROR:  EVERY parameter produces ambiguous partition rule
LINE 3: (start (1) end (20) every (1.3));
                                   ^
-- should fail
create table foo_p (i int) distributed by (i)
partition by range(i)
(start (1) end (20) every (10.9));
ERROR:  EVERY parameter produces ambiguous partition rule
LINE 3: (start (1) end (20) every (10.9));
                                   ^
-- should fail
create table foo_p (i int, j date) distributed by (i)
partition by range(j)
(start ('2007-01-01') end ('2008-01-01') every (interval '0.5 days'));
ERROR:  EVERY parameter produces ambiguous partition rule
LINE 3: (start ('2007-01-01') end ('2008-01-01') every (interval '0....
                                                        ^
-- should fail
create table foo_p (i int, j date) distributed by (i)
partition by range(j)
(start ('2007-01-01') end ('2008-01-01') every (interval '0.5 days'));
ERROR:  EVERY parameter produces ambiguous partition rule
LINE 3: (start ('2007-01-01') end ('2008-01-01') every (interval '0....
                                                        ^
-- should fail
create table foo_p (i int, j date) distributed by (i)
partition by range(j)
(start ('2007-01-01') end ('2008-01-01') every (interval '12 hours'));
ERROR:  EVERY parameter produces ambiguous partition rule
LINE 3: (start ('2007-01-01') end ('2008-01-01') every (interval '12...
                                                        ^
-- should fail
create table foo_p (i int, j date) distributed by (i)
partition by range(j)
(start ('2007-01-01') end ('2008-01-01') every (interval '1.2 days'));
ERROR:  EVERY parameter produces ambiguous partition rule
LINE 3: (start ('2007-01-01') end ('2008-01-01') every (interval '1....
                                                        ^
-- should work
create table foo_p (i int, j timestamp) distributed by (i)
partition by range(j)
(start ('2007-01-01') end ('2007-01-05') every (interval '1.2 days'));
NOTICE:  CREATE TABLE will create partition "foo_p_1_prt_1" for table "foo_p"
NOTICE:  CREATE TABLE will create partition "foo_p_1_prt_2" for table "foo_p"
NOTICE:  CREATE TABLE will create partition "foo_p_1_prt_3" for table "foo_p"
NOTICE:  CREATE TABLE will create partition "foo_p_1_prt_4" for table "foo_p"
drop table foo_p;
-- test inclusive/exclusive
CREATE TABLE supplier2(
                S_SUPPKEY INTEGER,
                S_NAME CHAR(25),
                S_ADDRESS VARCHAR(40),
                S_NATIONKEY INTEGER,
                S_PHONECHAR char(15),
                S_ACCTBAL decimal,
				S_COMMENT VARCHAR(100)
)
partition by range (s_nationkey)
(
partition p1 start(0) , 
partition p2 start(12) end(13), 
partition p3 end(20) inclusive, 
partition p4 start(20) exclusive , 
partition p5 start(22) end(25)
);
NOTICE:  Table doesn't have 'DISTRIBUTED BY' clause -- Using column named 's_suppkey' as the Greenplum Database data distribution key for this table.
HINT:  The 'DISTRIBUTED BY' clause determines the distribution of data. Make sure column(s) chosen are the optimal data distribution key to minimize skew.
NOTICE:  CREATE TABLE will create partition "supplier2_1_prt_p1" for table "supplier2"
NOTICE:  CREATE TABLE will create partition "supplier2_1_prt_p2" for table "supplier2"
NOTICE:  CREATE TABLE will create partition "supplier2_1_prt_p3" for table "supplier2"
NOTICE:  CREATE TABLE will create partition "supplier2_1_prt_p4" for table "supplier2"
NOTICE:  CREATE TABLE will create partition "supplier2_1_prt_p5" for table "supplier2"
-- Make sure they're correctly ordered
select parname, parruleord, pg_get_expr(parrangestart, parchildrelid, false),
parrangestartincl,
pg_get_expr(parrangeend, parchildrelid, false),parrangeendincl 
from pg_partition_rule  where
paroid in (select oid from pg_partition where parrelid = 'supplier2'::regclass)
order by parruleord;
 parname | parruleord | pg_get_expr | parrangestartincl | pg_get_expr | parrangeendincl 
---------+------------+-------------+-------------------+-------------+-----------------
 p1      |          1 | 0           | t                 | 12          | f
 p2      |          2 | 12          | t                 | 13          | f
 p3      |          3 | 13          | t                 | 20          | t
 p4      |          4 | 20          | f                 | 22          | f
 p5      |          5 | 22          | t                 | 25          | f
(5 rows)

insert into supplier2 (s_suppkey, s_nationkey) select i, i 
from generate_series(1, 24) i;
select * from supplier2_1_prt_p1 order by S_NATIONKEY;
 s_suppkey | s_name | s_address | s_nationkey | s_phonechar | s_acctbal | s_comment 
-----------+--------+-----------+-------------+-------------+-----------+-----------
         1 |        |           |           1 |             |           | 
         2 |        |           |           2 |             |           | 
         3 |        |           |           3 |             |           | 
         4 |        |           |           4 |             |           | 
         5 |        |           |           5 |             |           | 
         6 |        |           |           6 |             |           | 
         7 |        |           |           7 |             |           | 
         8 |        |           |           8 |             |           | 
         9 |        |           |           9 |             |           | 
        10 |        |           |          10 |             |           | 
        11 |        |           |          11 |             |           | 
(11 rows)

select * from supplier2_1_prt_p2 order by S_NATIONKEY;
 s_suppkey | s_name | s_address | s_nationkey | s_phonechar | s_acctbal | s_comment 
-----------+--------+-----------+-------------+-------------+-----------+-----------
        12 |        |           |          12 |             |           | 
(1 row)

select * from supplier2_1_prt_p3 order by S_NATIONKEY;
 s_suppkey | s_name | s_address | s_nationkey | s_phonechar | s_acctbal | s_comment 
-----------+--------+-----------+-------------+-------------+-----------+-----------
        13 |        |           |          13 |             |           | 
        14 |        |           |          14 |             |           | 
        15 |        |           |          15 |             |           | 
        16 |        |           |          16 |             |           | 
        17 |        |           |          17 |             |           | 
        18 |        |           |          18 |             |           | 
        19 |        |           |          19 |             |           | 
        20 |        |           |          20 |             |           | 
(8 rows)

select * from supplier2_1_prt_p4 order by S_NATIONKEY;
 s_suppkey | s_name | s_address | s_nationkey | s_phonechar | s_acctbal | s_comment 
-----------+--------+-----------+-------------+-------------+-----------+-----------
        21 |        |           |          21 |             |           | 
(1 row)

select * from supplier2_1_prt_p5 order by S_NATIONKEY;
 s_suppkey | s_name | s_address | s_nationkey | s_phonechar | s_acctbal | s_comment 
-----------+--------+-----------+-------------+-------------+-----------+-----------
        22 |        |           |          22 |             |           | 
        23 |        |           |          23 |             |           | 
        24 |        |           |          24 |             |           | 
(3 rows)

drop table supplier2;
-- mpp3238
create table foo_p (i int) partition by range (i)
(
 partition p1 start('1') ,
 partition p2 start('2639161') ,
 partition p3 start('5957166') ,
 partition p4 start('5981976') end('5994376') inclusive,
 partition p5 end('6000001')
);
NOTICE:  Table doesn't have 'DISTRIBUTED BY' clause -- Using column named 'i' as the Greenplum Database data distribution key for this table.
HINT:  The 'DISTRIBUTED BY' clause determines the distribution of data. Make sure column(s) chosen are the optimal data distribution key to minimize skew.
NOTICE:  CREATE TABLE will create partition "foo_p_1_prt_p1" for table "foo_p"
NOTICE:  CREATE TABLE will create partition "foo_p_1_prt_p2" for table "foo_p"
NOTICE:  CREATE TABLE will create partition "foo_p_1_prt_p3" for table "foo_p"
NOTICE:  CREATE TABLE will create partition "foo_p_1_prt_p4" for table "foo_p"
NOTICE:  CREATE TABLE will create partition "foo_p_1_prt_p5" for table "foo_p"
select parname, parruleord, pg_get_expr(parrangestart, parchildrelid, false) as
 start, pg_get_expr(parrangeend, parchildrelid, false) as end,
 pg_get_expr(parlistvalues, parchildrelid, false) as list from 
 pg_partition_rule
 r, pg_partition p where r.paroid = p.oid and p.parlevel = 0 and 
 p.parrelid = 'foo_p'::regclass order by 1;
 parname | parruleord |  start  |   end   | list 
---------+------------+---------+---------+------
 p1      |          1 | 1       | 2639161 | 
 p2      |          2 | 2639161 | 5957166 | 
 p3      |          3 | 5957166 | 5981976 | 
 p4      |          4 | 5981976 | 5994376 | 
 p5      |          5 | 5994376 | 6000001 | 
(5 rows)

insert into foo_p values(5994400);
insert into foo_p values(1);
insert into foo_p values(6000002);
ERROR:  no partition for partitioning key  (seg1 slarimac:40001 pid=97876)
insert into foo_p values(5994376);
drop table foo_p;
create table foo_p (i int) 
partition by range(i)
(partition p1 start(1) end(5),
 partition p2 start(10),
 partition p3 end(10) exclusive);
NOTICE:  Table doesn't have 'DISTRIBUTED BY' clause -- Using column named 'i' as the Greenplum Database data distribution key for this table.
HINT:  The 'DISTRIBUTED BY' clause determines the distribution of data. Make sure column(s) chosen are the optimal data distribution key to minimize skew.
NOTICE:  CREATE TABLE will create partition "foo_p_1_prt_p1" for table "foo_p"
NOTICE:  CREATE TABLE will create partition "foo_p_1_prt_p3" for table "foo_p"
NOTICE:  CREATE TABLE will create partition "foo_p_1_prt_p2" for table "foo_p"
select parname, parruleord, pg_get_expr(parrangestart, parchildrelid, false) as
 start, pg_get_expr(parrangeend, parchildrelid, false) as end,
  pg_get_expr(parlistvalues, parchildrelid, false) as list from
   pg_partition_rule
    r, pg_partition p where r.paroid = p.oid and p.parlevel = 0 and
	 p.parrelid = 'foo_p'::regclass order by 1;
 parname | parruleord | start | end | list 
---------+------------+-------+-----+------
 p1      |          1 | 1     | 5   | 
 p2      |          3 | 10    |     | 
 p3      |          2 | 5     | 10  | 
(3 rows)

drop table foo_p;
create table foo_p (i int) 
partition by range(i)
(partition p1 start(1) end(5),
 partition p2 start(10) exclusive,
 partition p3 end(10) inclusive);
NOTICE:  Table doesn't have 'DISTRIBUTED BY' clause -- Using column named 'i' as the Greenplum Database data distribution key for this table.
HINT:  The 'DISTRIBUTED BY' clause determines the distribution of data. Make sure column(s) chosen are the optimal data distribution key to minimize skew.
NOTICE:  CREATE TABLE will create partition "foo_p_1_prt_p1" for table "foo_p"
NOTICE:  CREATE TABLE will create partition "foo_p_1_prt_p3" for table "foo_p"
NOTICE:  CREATE TABLE will create partition "foo_p_1_prt_p2" for table "foo_p"
select parname, parruleord, pg_get_expr(parrangestart, parchildrelid, false) as
 start, parrangestartincl,
 pg_get_expr(parrangeend, parchildrelid, false) as end,
 parrangeendincl,
  pg_get_expr(parlistvalues, parchildrelid, false) as list from
   pg_partition_rule
    r, pg_partition p where r.paroid = p.oid and p.parlevel = 0 and
	 p.parrelid = 'foo_p'::regclass order by 1;
 parname | parruleord | start | parrangestartincl | end | parrangeendincl | list 
---------+------------+-------+-------------------+-----+-----------------+------
 p1      |          1 | 1     | t                 | 5   | f               | 
 p2      |          3 | 10    | f                 |     | f               | 
 p3      |          2 | 5     | t                 | 10  | t               | 
(3 rows)

insert into foo_p values(1), (5), (10);
drop table foo_p;
-- MPP-3264
-- mix AO with master HEAP and see if copy works
create table foo_p (i int)
partition by list(i)
(partition p1 values(1, 2, 3) with (appendonly = true),
 partition p2 values(4)
);
NOTICE:  Table doesn't have 'DISTRIBUTED BY' clause -- Using column named 'i' as the Greenplum Database data distribution key for this table.
HINT:  The 'DISTRIBUTED BY' clause determines the distribution of data. Make sure column(s) chosen are the optimal data distribution key to minimize skew.
NOTICE:  CREATE TABLE will create partition "foo_p_1_prt_p1" for table "foo_p"
NOTICE:  CREATE TABLE will create partition "foo_p_1_prt_p2" for table "foo_p"
copy foo_p from stdin;
select * from foo_p;
 i 
---
 1
 3
 2
 4
(4 rows)

select * from foo_p_1_prt_p1;
 i 
---
 1
 3
 2
(3 rows)

select * from foo_p_1_prt_p2;
 i 
---
 4
(1 row)

drop table foo_p;
-- other way around
create table foo_p (i int) with(appendonly = true)
partition by list(i)
(partition p1 values(1, 2, 3) with (appendonly = false),
 partition p2 values(4)
);
NOTICE:  Table doesn't have 'DISTRIBUTED BY' clause -- Using column named 'i' as the Greenplum Database data distribution key for this table.
HINT:  The 'DISTRIBUTED BY' clause determines the distribution of data. Make sure column(s) chosen are the optimal data distribution key to minimize skew.
NOTICE:  CREATE TABLE will create partition "foo_p_1_prt_p1" for table "foo_p"
NOTICE:  CREATE TABLE will create partition "foo_p_1_prt_p2" for table "foo_p"
copy foo_p from stdin;
select * from foo_p;
 i 
---
 1
 3
 2
 4
(4 rows)

select * from foo_p_1_prt_p1;
 i 
---
 2
 1
 3
(3 rows)

select * from foo_p_1_prt_p2;
 i 
---
 4
(1 row)

drop table foo_p;
-- Same as above, but the input is ordered so that the inserts to the heap
-- partition happen first. Had a bug related flushing the multi-insert
-- buffers in that scenario at one point.
-- (https://github.com/greenplum-db/gpdb/issues/6678
create table mixed_ao_part(distkey int, partkey int)
with (appendonly=true) distributed by(distkey)
partition by range(partkey) (
  partition p1 start(0) end(100) with (appendonly = false),
   partition p2 start(100) end(199)
);
copy mixed_ao_part from stdin;
select * from mixed_ao_part;
 distkey | partkey 
---------+---------
       1 |      95
       1 |     100
       2 |      96
       2 |     101
       3 |      97
       3 |     102
       4 |      98
       4 |     103
       5 |      99
       5 |     104
(10 rows)

-- Don't drop the table, so that we leave behind a mixed table in the
-- regression database for pg_dump/restore testing.
-- MPP-3283
CREATE TABLE PARTSUPP (
PS_PARTKEY INTEGER,
PS_SUPPKEY INTEGER,
PS_AVAILQTY integer,
PS_SUPPLYCOST decimal,
PS_COMMENT VARCHAR(199)
)
partition by range (ps_suppkey)
subpartition by range (ps_partkey)
subpartition by range (ps_supplycost) subpartition template (start('1')
end('1001') every(500))
(
partition p1 start('1') end('10001') every(5000)
(subpartition sp1 start('1') end('200001') every(66666)
)
);
NOTICE:  Table doesn't have 'DISTRIBUTED BY' clause -- Using column named 'ps_partkey' as the Greenplum Database data distribution key for this table.
HINT:  The 'DISTRIBUTED BY' clause determines the distribution of data. Make sure column(s) chosen are the optimal data distribution key to minimize skew.
NOTICE:  CREATE TABLE will create partition "partsupp_1_prt_p1_1" for table "partsupp"
NOTICE:  CREATE TABLE will create partition "partsupp_1_prt_p1_1_2_prt_sp1_1" for table "partsupp_1_prt_p1_1"
NOTICE:  CREATE TABLE will create partition "partsupp_1_prt_p1_1_2_prt_sp1_1_3_prt_1" for table "partsupp_1_prt_p1_1_2_prt_sp1_1"
NOTICE:  CREATE TABLE will create partition "partsupp_1_prt_p1_1_2_prt_sp1_1_3_prt_2" for table "partsupp_1_prt_p1_1_2_prt_sp1_1"
NOTICE:  CREATE TABLE will create partition "partsupp_1_prt_p1_1_2_prt_sp1_2" for table "partsupp_1_prt_p1_1"
NOTICE:  CREATE TABLE will create partition "partsupp_1_prt_p1_1_2_prt_sp1_2_3_prt_1" for table "partsupp_1_prt_p1_1_2_prt_sp1_2"
NOTICE:  CREATE TABLE will create partition "partsupp_1_prt_p1_1_2_prt_sp1_2_3_prt_2" for table "partsupp_1_prt_p1_1_2_prt_sp1_2"
NOTICE:  CREATE TABLE will create partition "partsupp_1_prt_p1_1_2_prt_sp1_3" for table "partsupp_1_prt_p1_1"
NOTICE:  CREATE TABLE will create partition "partsupp_1_prt_p1_1_2_prt_sp1_3_3_prt_1" for table "partsupp_1_prt_p1_1_2_prt_sp1_3"
NOTICE:  CREATE TABLE will create partition "partsupp_1_prt_p1_1_2_prt_sp1_3_3_prt_2" for table "partsupp_1_prt_p1_1_2_prt_sp1_3"
NOTICE:  CREATE TABLE will create partition "partsupp_1_prt_p1_1_2_prt_sp1_4" for table "partsupp_1_prt_p1_1"
NOTICE:  CREATE TABLE will create partition "partsupp_1_prt_p1_1_2_prt_sp1_4_3_prt_1" for table "partsupp_1_prt_p1_1_2_prt_sp1_4"
NOTICE:  CREATE TABLE will create partition "partsupp_1_prt_p1_1_2_prt_sp1_4_3_prt_2" for table "partsupp_1_prt_p1_1_2_prt_sp1_4"
NOTICE:  CREATE TABLE will create partition "partsupp_1_prt_p1_2" for table "partsupp"
NOTICE:  CREATE TABLE will create partition "partsupp_1_prt_p1_2_2_prt_sp1_1" for table "partsupp_1_prt_p1_2"
NOTICE:  CREATE TABLE will create partition "partsupp_1_prt_p1_2_2_prt_sp1_1_3_prt_1" for table "partsupp_1_prt_p1_2_2_prt_sp1_1"
NOTICE:  CREATE TABLE will create partition "partsupp_1_prt_p1_2_2_prt_sp1_1_3_prt_2" for table "partsupp_1_prt_p1_2_2_prt_sp1_1"
NOTICE:  CREATE TABLE will create partition "partsupp_1_prt_p1_2_2_prt_sp1_2" for table "partsupp_1_prt_p1_2"
NOTICE:  CREATE TABLE will create partition "partsupp_1_prt_p1_2_2_prt_sp1_2_3_prt_1" for table "partsupp_1_prt_p1_2_2_prt_sp1_2"
NOTICE:  CREATE TABLE will create partition "partsupp_1_prt_p1_2_2_prt_sp1_2_3_prt_2" for table "partsupp_1_prt_p1_2_2_prt_sp1_2"
NOTICE:  CREATE TABLE will create partition "partsupp_1_prt_p1_2_2_prt_sp1_3" for table "partsupp_1_prt_p1_2"
NOTICE:  CREATE TABLE will create partition "partsupp_1_prt_p1_2_2_prt_sp1_3_3_prt_1" for table "partsupp_1_prt_p1_2_2_prt_sp1_3"
NOTICE:  CREATE TABLE will create partition "partsupp_1_prt_p1_2_2_prt_sp1_3_3_prt_2" for table "partsupp_1_prt_p1_2_2_prt_sp1_3"
NOTICE:  CREATE TABLE will create partition "partsupp_1_prt_p1_2_2_prt_sp1_4" for table "partsupp_1_prt_p1_2"
NOTICE:  CREATE TABLE will create partition "partsupp_1_prt_p1_2_2_prt_sp1_4_3_prt_1" for table "partsupp_1_prt_p1_2_2_prt_sp1_4"
NOTICE:  CREATE TABLE will create partition "partsupp_1_prt_p1_2_2_prt_sp1_4_3_prt_2" for table "partsupp_1_prt_p1_2_2_prt_sp1_4"
insert into partsupp values(1,2,3325,771.64,', even theodolites. regular, final
theodolites eat after the carefully pending foxes. furiously regular deposits
sleep slyly. carefully bold realms above the ironic dependencies haggle
careful');
copy partsupp from stdin with delimiter '|';
drop table partsupp;
--MPP-3285
CREATE TABLE PARTLINEITEM (
                L_ORDERKEY INT8,
                L_PARTKEY INTEGER,
                L_SUPPKEY INTEGER,
                L_LINENUMBER integer,
                L_QUANTITY decimal,
                L_EXTENDEDPRICE decimal,
                L_DISCOUNT decimal,
                L_TAX decimal,
                L_RETURNFLAG CHAR(1),
                L_LINESTATUS CHAR(1),
                L_SHIPDATE date,
                L_COMMITDATE date,
                L_RECEIPTDATE date,
                L_SHIPINSTRUCT CHAR(25),
                L_SHIPMODE CHAR(10),
                L_COMMENT VARCHAR(44)
                )
partition by range (l_commitdate)
(
partition p1 start('1992-01-31') end('1998-11-01') every(interval '20 months')
);
NOTICE:  Table doesn't have 'DISTRIBUTED BY' clause -- Using column named 'l_orderkey' as the Greenplum Database data distribution key for this table.
HINT:  The 'DISTRIBUTED BY' clause determines the distribution of data. Make sure column(s) chosen are the optimal data distribution key to minimize skew.
NOTICE:  CREATE TABLE will create partition "partlineitem_1_prt_p1_1" for table "partlineitem"
NOTICE:  CREATE TABLE will create partition "partlineitem_1_prt_p1_2" for table "partlineitem"
NOTICE:  CREATE TABLE will create partition "partlineitem_1_prt_p1_3" for table "partlineitem"
NOTICE:  CREATE TABLE will create partition "partlineitem_1_prt_p1_4" for table "partlineitem"
NOTICE:  CREATE TABLE will create partition "partlineitem_1_prt_p1_5" for table "partlineitem"
copy partlineitem from stdin with delimiter '|';
select parname, parruleord, pg_get_expr(parrangestart, parchildrelid, false) as
 start, parrangestartincl,
 pg_get_expr(parrangeend, parchildrelid, false) as end,
 parrangeendincl,
  pg_get_expr(parlistvalues, parchildrelid, false) as list from
   pg_partition_rule
    r, pg_partition p where r.paroid = p.oid and p.parlevel = 0 and
	 p.parrelid = 'partlineitem'::regclass order by 1;
 parname | parruleord |       start        | parrangestartincl |        end         | parrangeendincl | list 
---------+------------+--------------------+-------------------+--------------------+-----------------+------
 p1_1    |          1 | '01-31-1992'::date | t                 | '09-30-1993'::date | f               | 
 p1_2    |          2 | '09-30-1993'::date | t                 | '05-31-1995'::date | f               | 
 p1_3    |          3 | '05-31-1995'::date | t                 | '01-31-1997'::date | f               | 
 p1_4    |          4 | '01-31-1997'::date | t                 | '09-30-1998'::date | f               | 
 p1_5    |          5 | '09-30-1998'::date | t                 | '11-01-1998'::date | f               | 
(5 rows)

drop table partlineitem;
-- Make sure ADD creates dependencies
create table i (i int) partition by range(i) (start (1) end(3) every(1));
NOTICE:  Table doesn't have 'DISTRIBUTED BY' clause -- Using column named 'i' as the Greenplum Database data distribution key for this table.
HINT:  The 'DISTRIBUTED BY' clause determines the distribution of data. Make sure column(s) chosen are the optimal data distribution key to minimize skew.
NOTICE:  CREATE TABLE will create partition "i_1_prt_1" for table "i"
NOTICE:  CREATE TABLE will create partition "i_1_prt_2" for table "i"
alter table i add partition foo2 start(40) end (50);
NOTICE:  CREATE TABLE will create partition "i_1_prt_foo2" for table "i"
drop table i;
create table i (i int) partition by range(i) (start (1) end(3) every(1));
NOTICE:  Table doesn't have 'DISTRIBUTED BY' clause -- Using column named 'i' as the Greenplum Database data distribution key for this table.
HINT:  The 'DISTRIBUTED BY' clause determines the distribution of data. Make sure column(s) chosen are the optimal data distribution key to minimize skew.
NOTICE:  CREATE TABLE will create partition "i_1_prt_1" for table "i"
NOTICE:  CREATE TABLE will create partition "i_1_prt_2" for table "i"
alter table i add partition foo2 start(40) end (50);
NOTICE:  CREATE TABLE will create partition "i_1_prt_foo2" for table "i"
alter table i drop partition foo2;
drop table i;
-- dumpability of partition info
create table i5 (i int) partition by RANGE(i) (start(1) exclusive end(10)
inclusive);
NOTICE:  Table doesn't have 'DISTRIBUTED BY' clause -- Using column named 'i' as the Greenplum Database data distribution key for this table.
HINT:  The 'DISTRIBUTED BY' clause determines the distribution of data. Make sure column(s) chosen are the optimal data distribution key to minimize skew.
NOTICE:  CREATE TABLE will create partition "i5_1_prt_1" for table "i5"
select tablename, partitiontablename,
partitionboundary from pg_partitions where
tablename = 'i5';
 tablename | partitiontablename |           partitionboundary            
-----------+--------------------+----------------------------------------
 i5        | i5_1_prt_1         | START (1) EXCLUSIVE END (10) INCLUSIVE
(1 row)

select pg_get_partition_def('i5'::regclass, true);
               pg_get_partition_def               
--------------------------------------------------
 PARTITION BY RANGE(i)                           +
           (                                     +
           START (1) EXCLUSIVE END (10) INCLUSIVE+
           )
(1 row)

drop table i5;
CREATE TABLE PARTSUPP (
PS_PARTKEY INTEGER,
PS_SUPPKEY INTEGER,
PS_AVAILQTY integer,
PS_SUPPLYCOST decimal,
PS_COMMENT VARCHAR(199)
)
partition by range (ps_suppkey)
subpartition by range (ps_partkey)
subpartition by range (ps_supplycost) subpartition template (start('1')
end('1001') every(500))
(
partition p1 start('1') end('10001') every(5000)
(subpartition sp1 start('1') end('200001') every(66666)
)
);
NOTICE:  Table doesn't have 'DISTRIBUTED BY' clause -- Using column named 'ps_partkey' as the Greenplum Database data distribution key for this table.
HINT:  The 'DISTRIBUTED BY' clause determines the distribution of data. Make sure column(s) chosen are the optimal data distribution key to minimize skew.
NOTICE:  CREATE TABLE will create partition "partsupp_1_prt_p1_1" for table "partsupp"
NOTICE:  CREATE TABLE will create partition "partsupp_1_prt_p1_1_2_prt_sp1_1" for table "partsupp_1_prt_p1_1"
NOTICE:  CREATE TABLE will create partition "partsupp_1_prt_p1_1_2_prt_sp1_1_3_prt_1" for table "partsupp_1_prt_p1_1_2_prt_sp1_1"
NOTICE:  CREATE TABLE will create partition "partsupp_1_prt_p1_1_2_prt_sp1_1_3_prt_2" for table "partsupp_1_prt_p1_1_2_prt_sp1_1"
NOTICE:  CREATE TABLE will create partition "partsupp_1_prt_p1_1_2_prt_sp1_2" for table "partsupp_1_prt_p1_1"
NOTICE:  CREATE TABLE will create partition "partsupp_1_prt_p1_1_2_prt_sp1_2_3_prt_1" for table "partsupp_1_prt_p1_1_2_prt_sp1_2"
NOTICE:  CREATE TABLE will create partition "partsupp_1_prt_p1_1_2_prt_sp1_2_3_prt_2" for table "partsupp_1_prt_p1_1_2_prt_sp1_2"
NOTICE:  CREATE TABLE will create partition "partsupp_1_prt_p1_1_2_prt_sp1_3" for table "partsupp_1_prt_p1_1"
NOTICE:  CREATE TABLE will create partition "partsupp_1_prt_p1_1_2_prt_sp1_3_3_prt_1" for table "partsupp_1_prt_p1_1_2_prt_sp1_3"
NOTICE:  CREATE TABLE will create partition "partsupp_1_prt_p1_1_2_prt_sp1_3_3_prt_2" for table "partsupp_1_prt_p1_1_2_prt_sp1_3"
NOTICE:  CREATE TABLE will create partition "partsupp_1_prt_p1_1_2_prt_sp1_4" for table "partsupp_1_prt_p1_1"
NOTICE:  CREATE TABLE will create partition "partsupp_1_prt_p1_1_2_prt_sp1_4_3_prt_1" for table "partsupp_1_prt_p1_1_2_prt_sp1_4"
NOTICE:  CREATE TABLE will create partition "partsupp_1_prt_p1_1_2_prt_sp1_4_3_prt_2" for table "partsupp_1_prt_p1_1_2_prt_sp1_4"
NOTICE:  CREATE TABLE will create partition "partsupp_1_prt_p1_2" for table "partsupp"
NOTICE:  CREATE TABLE will create partition "partsupp_1_prt_p1_2_2_prt_sp1_1" for table "partsupp_1_prt_p1_2"
NOTICE:  CREATE TABLE will create partition "partsupp_1_prt_p1_2_2_prt_sp1_1_3_prt_1" for table "partsupp_1_prt_p1_2_2_prt_sp1_1"
NOTICE:  CREATE TABLE will create partition "partsupp_1_prt_p1_2_2_prt_sp1_1_3_prt_2" for table "partsupp_1_prt_p1_2_2_prt_sp1_1"
NOTICE:  CREATE TABLE will create partition "partsupp_1_prt_p1_2_2_prt_sp1_2" for table "partsupp_1_prt_p1_2"
NOTICE:  CREATE TABLE will create partition "partsupp_1_prt_p1_2_2_prt_sp1_2_3_prt_1" for table "partsupp_1_prt_p1_2_2_prt_sp1_2"
NOTICE:  CREATE TABLE will create partition "partsupp_1_prt_p1_2_2_prt_sp1_2_3_prt_2" for table "partsupp_1_prt_p1_2_2_prt_sp1_2"
NOTICE:  CREATE TABLE will create partition "partsupp_1_prt_p1_2_2_prt_sp1_3" for table "partsupp_1_prt_p1_2"
NOTICE:  CREATE TABLE will create partition "partsupp_1_prt_p1_2_2_prt_sp1_3_3_prt_1" for table "partsupp_1_prt_p1_2_2_prt_sp1_3"
NOTICE:  CREATE TABLE will create partition "partsupp_1_prt_p1_2_2_prt_sp1_3_3_prt_2" for table "partsupp_1_prt_p1_2_2_prt_sp1_3"
NOTICE:  CREATE TABLE will create partition "partsupp_1_prt_p1_2_2_prt_sp1_4" for table "partsupp_1_prt_p1_2"
NOTICE:  CREATE TABLE will create partition "partsupp_1_prt_p1_2_2_prt_sp1_4_3_prt_1" for table "partsupp_1_prt_p1_2_2_prt_sp1_4"
NOTICE:  CREATE TABLE will create partition "partsupp_1_prt_p1_2_2_prt_sp1_4_3_prt_2" for table "partsupp_1_prt_p1_2_2_prt_sp1_4"
select tablename, partitiontablename,
partitionboundary from pg_partitions where
tablename = 'partsupp';
 tablename |           partitiontablename            |                       partitionboundary                       
-----------+-----------------------------------------+---------------------------------------------------------------
 partsupp  | partsupp_1_prt_p1_1                     | PARTITION p1_1 START (1) END (5001) EVERY (5000)
 partsupp  | partsupp_1_prt_p1_2                     | PARTITION p1_2 START (5001) END (10001) EVERY (5000)
 partsupp  | partsupp_1_prt_p1_1_2_prt_sp1_1         | SUBPARTITION sp1_1 START (1) END (66667) EVERY (66666)
 partsupp  | partsupp_1_prt_p1_1_2_prt_sp1_2         | SUBPARTITION sp1_2 START (66667) END (133333) EVERY (66666)
 partsupp  | partsupp_1_prt_p1_1_2_prt_sp1_3         | SUBPARTITION sp1_3 START (133333) END (199999) EVERY (66666)
 partsupp  | partsupp_1_prt_p1_1_2_prt_sp1_4         | SUBPARTITION sp1_4 START (199999) END (200001) EVERY (66666)
 partsupp  | partsupp_1_prt_p1_2_2_prt_sp1_1         | SUBPARTITION sp1_1 START (1) END (66667) EVERY (66666)
 partsupp  | partsupp_1_prt_p1_2_2_prt_sp1_2         | SUBPARTITION sp1_2 START (66667) END (133333) EVERY (66666)
 partsupp  | partsupp_1_prt_p1_2_2_prt_sp1_3         | SUBPARTITION sp1_3 START (133333) END (199999) EVERY (66666)
 partsupp  | partsupp_1_prt_p1_2_2_prt_sp1_4         | SUBPARTITION sp1_4 START (199999) END (200001) EVERY (66666)
 partsupp  | partsupp_1_prt_p1_1_2_prt_sp1_1_3_prt_1 | START (1::numeric) END (501::numeric) EVERY (500::numeric)
 partsupp  | partsupp_1_prt_p1_1_2_prt_sp1_1_3_prt_2 | START (501::numeric) END (1001::numeric) EVERY (500::numeric)
 partsupp  | partsupp_1_prt_p1_1_2_prt_sp1_2_3_prt_1 | START (1::numeric) END (501::numeric) EVERY (500::numeric)
 partsupp  | partsupp_1_prt_p1_1_2_prt_sp1_2_3_prt_2 | START (501::numeric) END (1001::numeric) EVERY (500::numeric)
 partsupp  | partsupp_1_prt_p1_1_2_prt_sp1_3_3_prt_1 | START (1::numeric) END (501::numeric) EVERY (500::numeric)
 partsupp  | partsupp_1_prt_p1_1_2_prt_sp1_3_3_prt_2 | START (501::numeric) END (1001::numeric) EVERY (500::numeric)
 partsupp  | partsupp_1_prt_p1_1_2_prt_sp1_4_3_prt_1 | START (1::numeric) END (501::numeric) EVERY (500::numeric)
 partsupp  | partsupp_1_prt_p1_1_2_prt_sp1_4_3_prt_2 | START (501::numeric) END (1001::numeric) EVERY (500::numeric)
 partsupp  | partsupp_1_prt_p1_2_2_prt_sp1_1_3_prt_1 | START (1::numeric) END (501::numeric) EVERY (500::numeric)
 partsupp  | partsupp_1_prt_p1_2_2_prt_sp1_1_3_prt_2 | START (501::numeric) END (1001::numeric) EVERY (500::numeric)
 partsupp  | partsupp_1_prt_p1_2_2_prt_sp1_2_3_prt_1 | START (1::numeric) END (501::numeric) EVERY (500::numeric)
 partsupp  | partsupp_1_prt_p1_2_2_prt_sp1_2_3_prt_2 | START (501::numeric) END (1001::numeric) EVERY (500::numeric)
 partsupp  | partsupp_1_prt_p1_2_2_prt_sp1_3_3_prt_1 | START (1::numeric) END (501::numeric) EVERY (500::numeric)
 partsupp  | partsupp_1_prt_p1_2_2_prt_sp1_3_3_prt_2 | START (501::numeric) END (1001::numeric) EVERY (500::numeric)
 partsupp  | partsupp_1_prt_p1_2_2_prt_sp1_4_3_prt_1 | START (1::numeric) END (501::numeric) EVERY (500::numeric)
 partsupp  | partsupp_1_prt_p1_2_2_prt_sp1_4_3_prt_2 | START (501::numeric) END (1001::numeric) EVERY (500::numeric)
(26 rows)

select pg_get_partition_def('partsupp'::regclass, true);
                                 pg_get_partition_def                                  
---------------------------------------------------------------------------------------
 PARTITION BY RANGE(ps_suppkey)                                                       +
           SUBPARTITION BY RANGE(ps_partkey)                                          +
                   SUBPARTITION BY RANGE(ps_supplycost)                               +
           (                                                                          +
           PARTITION p1 START (1) END (10001) EVERY (5000)                            +
                   (                                                                  +
                   SUBPARTITION sp1 START (1) END (200001) EVERY (66666)              +
                           (                                                          +
                           START (1::numeric) END (1001::numeric) EVERY (500::numeric)+
                           )                                                          +
                   )                                                                  +
           )
(1 row)

drop table partsupp;
-- ALTER TABLE ALTER PARTITION tests
CREATE TABLE ataprank (id int, rank int,
year date, gender char(1),
usstate char(2))
DISTRIBUTED BY (id, gender, year, usstate)
partition by list (gender)
subpartition by range (year)
subpartition template (
subpartition jan01 start (date '2001-01-01'),
subpartition jan02 start (date '2002-01-01'),
subpartition jan03 start (date '2003-01-01'),
subpartition jan04 start (date '2004-01-01'),
subpartition jan05 start (date '2005-01-01')
)
subpartition by list (usstate)
subpartition template (
subpartition mass values ('MA'),
subpartition cali values ('CA'),
subpartition ohio values ('OH')
)
(
  partition boys values ('M'),
  partition girls values ('F')
);
NOTICE:  CREATE TABLE will create partition "ataprank_1_prt_boys" for table "ataprank"
NOTICE:  CREATE TABLE will create partition "ataprank_1_prt_boys_2_prt_jan01" for table "ataprank_1_prt_boys"
NOTICE:  CREATE TABLE will create partition "ataprank_1_prt_boys_2_prt_jan01_3_prt_mass" for table "ataprank_1_prt_boys_2_prt_jan01"
NOTICE:  CREATE TABLE will create partition "ataprank_1_prt_boys_2_prt_jan01_3_prt_cali" for table "ataprank_1_prt_boys_2_prt_jan01"
NOTICE:  CREATE TABLE will create partition "ataprank_1_prt_boys_2_prt_jan01_3_prt_ohio" for table "ataprank_1_prt_boys_2_prt_jan01"
NOTICE:  CREATE TABLE will create partition "ataprank_1_prt_boys_2_prt_jan02" for table "ataprank_1_prt_boys"
NOTICE:  CREATE TABLE will create partition "ataprank_1_prt_boys_2_prt_jan02_3_prt_mass" for table "ataprank_1_prt_boys_2_prt_jan02"
NOTICE:  CREATE TABLE will create partition "ataprank_1_prt_boys_2_prt_jan02_3_prt_cali" for table "ataprank_1_prt_boys_2_prt_jan02"
NOTICE:  CREATE TABLE will create partition "ataprank_1_prt_boys_2_prt_jan02_3_prt_ohio" for table "ataprank_1_prt_boys_2_prt_jan02"
NOTICE:  CREATE TABLE will create partition "ataprank_1_prt_boys_2_prt_jan03" for table "ataprank_1_prt_boys"
NOTICE:  CREATE TABLE will create partition "ataprank_1_prt_boys_2_prt_jan03_3_prt_mass" for table "ataprank_1_prt_boys_2_prt_jan03"
NOTICE:  CREATE TABLE will create partition "ataprank_1_prt_boys_2_prt_jan03_3_prt_cali" for table "ataprank_1_prt_boys_2_prt_jan03"
NOTICE:  CREATE TABLE will create partition "ataprank_1_prt_boys_2_prt_jan03_3_prt_ohio" for table "ataprank_1_prt_boys_2_prt_jan03"
NOTICE:  CREATE TABLE will create partition "ataprank_1_prt_boys_2_prt_jan04" for table "ataprank_1_prt_boys"
NOTICE:  CREATE TABLE will create partition "ataprank_1_prt_boys_2_prt_jan04_3_prt_mass" for table "ataprank_1_prt_boys_2_prt_jan04"
NOTICE:  CREATE TABLE will create partition "ataprank_1_prt_boys_2_prt_jan04_3_prt_cali" for table "ataprank_1_prt_boys_2_prt_jan04"
NOTICE:  CREATE TABLE will create partition "ataprank_1_prt_boys_2_prt_jan04_3_prt_ohio" for table "ataprank_1_prt_boys_2_prt_jan04"
NOTICE:  CREATE TABLE will create partition "ataprank_1_prt_boys_2_prt_jan05" for table "ataprank_1_prt_boys"
NOTICE:  CREATE TABLE will create partition "ataprank_1_prt_boys_2_prt_jan05_3_prt_mass" for table "ataprank_1_prt_boys_2_prt_jan05"
NOTICE:  CREATE TABLE will create partition "ataprank_1_prt_boys_2_prt_jan05_3_prt_cali" for table "ataprank_1_prt_boys_2_prt_jan05"
NOTICE:  CREATE TABLE will create partition "ataprank_1_prt_boys_2_prt_jan05_3_prt_ohio" for table "ataprank_1_prt_boys_2_prt_jan05"
NOTICE:  CREATE TABLE will create partition "ataprank_1_prt_girls" for table "ataprank"
NOTICE:  CREATE TABLE will create partition "ataprank_1_prt_girls_2_prt_jan01" for table "ataprank_1_prt_girls"
NOTICE:  CREATE TABLE will create partition "ataprank_1_prt_girls_2_prt_jan01_3_prt_mass" for table "ataprank_1_prt_girls_2_prt_jan01"
NOTICE:  CREATE TABLE will create partition "ataprank_1_prt_girls_2_prt_jan01_3_prt_cali" for table "ataprank_1_prt_girls_2_prt_jan01"
NOTICE:  CREATE TABLE will create partition "ataprank_1_prt_girls_2_prt_jan01_3_prt_ohio" for table "ataprank_1_prt_girls_2_prt_jan01"
NOTICE:  CREATE TABLE will create partition "ataprank_1_prt_girls_2_prt_jan02" for table "ataprank_1_prt_girls"
NOTICE:  CREATE TABLE will create partition "ataprank_1_prt_girls_2_prt_jan02_3_prt_mass" for table "ataprank_1_prt_girls_2_prt_jan02"
NOTICE:  CREATE TABLE will create partition "ataprank_1_prt_girls_2_prt_jan02_3_prt_cali" for table "ataprank_1_prt_girls_2_prt_jan02"
NOTICE:  CREATE TABLE will create partition "ataprank_1_prt_girls_2_prt_jan02_3_prt_ohio" for table "ataprank_1_prt_girls_2_prt_jan02"
NOTICE:  CREATE TABLE will create partition "ataprank_1_prt_girls_2_prt_jan03" for table "ataprank_1_prt_girls"
NOTICE:  CREATE TABLE will create partition "ataprank_1_prt_girls_2_prt_jan03_3_prt_mass" for table "ataprank_1_prt_girls_2_prt_jan03"
NOTICE:  CREATE TABLE will create partition "ataprank_1_prt_girls_2_prt_jan03_3_prt_cali" for table "ataprank_1_prt_girls_2_prt_jan03"
NOTICE:  CREATE TABLE will create partition "ataprank_1_prt_girls_2_prt_jan03_3_prt_ohio" for table "ataprank_1_prt_girls_2_prt_jan03"
NOTICE:  CREATE TABLE will create partition "ataprank_1_prt_girls_2_prt_jan04" for table "ataprank_1_prt_girls"
NOTICE:  CREATE TABLE will create partition "ataprank_1_prt_girls_2_prt_jan04_3_prt_mass" for table "ataprank_1_prt_girls_2_prt_jan04"
NOTICE:  CREATE TABLE will create partition "ataprank_1_prt_girls_2_prt_jan04_3_prt_cali" for table "ataprank_1_prt_girls_2_prt_jan04"
NOTICE:  CREATE TABLE will create partition "ataprank_1_prt_girls_2_prt_jan04_3_prt_ohio" for table "ataprank_1_prt_girls_2_prt_jan04"
NOTICE:  CREATE TABLE will create partition "ataprank_1_prt_girls_2_prt_jan05" for table "ataprank_1_prt_girls"
NOTICE:  CREATE TABLE will create partition "ataprank_1_prt_girls_2_prt_jan05_3_prt_mass" for table "ataprank_1_prt_girls_2_prt_jan05"
NOTICE:  CREATE TABLE will create partition "ataprank_1_prt_girls_2_prt_jan05_3_prt_cali" for table "ataprank_1_prt_girls_2_prt_jan05"
NOTICE:  CREATE TABLE will create partition "ataprank_1_prt_girls_2_prt_jan05_3_prt_ohio" for table "ataprank_1_prt_girls_2_prt_jan05"
-- and without subpartition templates...
CREATE TABLE ataprank2 (id int, rank int,
year date, gender char(1),
usstate char(2))
DISTRIBUTED BY (id, gender, year, usstate)
partition by list (gender)
subpartition by range (year)
subpartition by list (usstate)
(
  partition boys values ('M') 
(
subpartition jan01 start (date '2001-01-01') 
(
subpartition mass values ('MA'),
subpartition cali values ('CA'),
subpartition ohio values ('OH')
),
subpartition jan02 start (date '2002-01-01')
(
subpartition mass values ('MA'),
subpartition cali values ('CA'),
subpartition ohio values ('OH')
),
subpartition jan03 start (date '2003-01-01')
(
subpartition mass values ('MA'),
subpartition cali values ('CA'),
subpartition ohio values ('OH')
),
subpartition jan04 start (date '2004-01-01')
(
subpartition mass values ('MA'),
subpartition cali values ('CA'),
subpartition ohio values ('OH')
),
subpartition jan05 start (date '2005-01-01')
(
subpartition mass values ('MA'),
subpartition cali values ('CA'),
subpartition ohio values ('OH')
)
),
  partition girls values ('F')
(
subpartition jan01 start (date '2001-01-01')
(
subpartition mass values ('MA'),
subpartition cali values ('CA'),
subpartition ohio values ('OH')
),
subpartition jan02 start (date '2002-01-01')
(
subpartition mass values ('MA'),
subpartition cali values ('CA'),
subpartition ohio values ('OH')
),
subpartition jan03 start (date '2003-01-01')
(
subpartition mass values ('MA'),
subpartition cali values ('CA'),
subpartition ohio values ('OH')
),
subpartition jan04 start (date '2004-01-01')
(
subpartition mass values ('MA'),
subpartition cali values ('CA'),
subpartition ohio values ('OH')
),
subpartition jan05 start (date '2005-01-01')
(
subpartition mass values ('MA'),
subpartition cali values ('CA'),
subpartition ohio values ('OH')
)
)
);
NOTICE:  CREATE TABLE will create partition "ataprank2_1_prt_boys" for table "ataprank2"
NOTICE:  CREATE TABLE will create partition "ataprank2_1_prt_boys_2_prt_jan01" for table "ataprank2_1_prt_boys"
NOTICE:  CREATE TABLE will create partition "ataprank2_1_prt_boys_2_prt_jan01_3_prt_mass" for table "ataprank2_1_prt_boys_2_prt_jan01"
NOTICE:  CREATE TABLE will create partition "ataprank2_1_prt_boys_2_prt_jan01_3_prt_cali" for table "ataprank2_1_prt_boys_2_prt_jan01"
NOTICE:  CREATE TABLE will create partition "ataprank2_1_prt_boys_2_prt_jan01_3_prt_ohio" for table "ataprank2_1_prt_boys_2_prt_jan01"
NOTICE:  CREATE TABLE will create partition "ataprank2_1_prt_boys_2_prt_jan02" for table "ataprank2_1_prt_boys"
NOTICE:  CREATE TABLE will create partition "ataprank2_1_prt_boys_2_prt_jan02_3_prt_mass" for table "ataprank2_1_prt_boys_2_prt_jan02"
NOTICE:  CREATE TABLE will create partition "ataprank2_1_prt_boys_2_prt_jan02_3_prt_cali" for table "ataprank2_1_prt_boys_2_prt_jan02"
NOTICE:  CREATE TABLE will create partition "ataprank2_1_prt_boys_2_prt_jan02_3_prt_ohio" for table "ataprank2_1_prt_boys_2_prt_jan02"
NOTICE:  CREATE TABLE will create partition "ataprank2_1_prt_boys_2_prt_jan03" for table "ataprank2_1_prt_boys"
NOTICE:  CREATE TABLE will create partition "ataprank2_1_prt_boys_2_prt_jan03_3_prt_mass" for table "ataprank2_1_prt_boys_2_prt_jan03"
NOTICE:  CREATE TABLE will create partition "ataprank2_1_prt_boys_2_prt_jan03_3_prt_cali" for table "ataprank2_1_prt_boys_2_prt_jan03"
NOTICE:  CREATE TABLE will create partition "ataprank2_1_prt_boys_2_prt_jan03_3_prt_ohio" for table "ataprank2_1_prt_boys_2_prt_jan03"
NOTICE:  CREATE TABLE will create partition "ataprank2_1_prt_boys_2_prt_jan04" for table "ataprank2_1_prt_boys"
NOTICE:  CREATE TABLE will create partition "ataprank2_1_prt_boys_2_prt_jan04_3_prt_mass" for table "ataprank2_1_prt_boys_2_prt_jan04"
NOTICE:  CREATE TABLE will create partition "ataprank2_1_prt_boys_2_prt_jan04_3_prt_cali" for table "ataprank2_1_prt_boys_2_prt_jan04"
NOTICE:  CREATE TABLE will create partition "ataprank2_1_prt_boys_2_prt_jan04_3_prt_ohio" for table "ataprank2_1_prt_boys_2_prt_jan04"
NOTICE:  CREATE TABLE will create partition "ataprank2_1_prt_boys_2_prt_jan05" for table "ataprank2_1_prt_boys"
NOTICE:  CREATE TABLE will create partition "ataprank2_1_prt_boys_2_prt_jan05_3_prt_mass" for table "ataprank2_1_prt_boys_2_prt_jan05"
NOTICE:  CREATE TABLE will create partition "ataprank2_1_prt_boys_2_prt_jan05_3_prt_cali" for table "ataprank2_1_prt_boys_2_prt_jan05"
NOTICE:  CREATE TABLE will create partition "ataprank2_1_prt_boys_2_prt_jan05_3_prt_ohio" for table "ataprank2_1_prt_boys_2_prt_jan05"
NOTICE:  CREATE TABLE will create partition "ataprank2_1_prt_girls" for table "ataprank2"
NOTICE:  CREATE TABLE will create partition "ataprank2_1_prt_girls_2_prt_jan01" for table "ataprank2_1_prt_girls"
NOTICE:  CREATE TABLE will create partition "ataprank2_1_prt_girls_2_prt_jan01_3_prt_mass" for table "ataprank2_1_prt_girls_2_prt_jan01"
NOTICE:  CREATE TABLE will create partition "ataprank2_1_prt_girls_2_prt_jan01_3_prt_cali" for table "ataprank2_1_prt_girls_2_prt_jan01"
NOTICE:  CREATE TABLE will create partition "ataprank2_1_prt_girls_2_prt_jan01_3_prt_ohio" for table "ataprank2_1_prt_girls_2_prt_jan01"
NOTICE:  CREATE TABLE will create partition "ataprank2_1_prt_girls_2_prt_jan02" for table "ataprank2_1_prt_girls"
NOTICE:  CREATE TABLE will create partition "ataprank2_1_prt_girls_2_prt_jan02_3_prt_mass" for table "ataprank2_1_prt_girls_2_prt_jan02"
NOTICE:  CREATE TABLE will create partition "ataprank2_1_prt_girls_2_prt_jan02_3_prt_cali" for table "ataprank2_1_prt_girls_2_prt_jan02"
NOTICE:  CREATE TABLE will create partition "ataprank2_1_prt_girls_2_prt_jan02_3_prt_ohio" for table "ataprank2_1_prt_girls_2_prt_jan02"
NOTICE:  CREATE TABLE will create partition "ataprank2_1_prt_girls_2_prt_jan03" for table "ataprank2_1_prt_girls"
NOTICE:  CREATE TABLE will create partition "ataprank2_1_prt_girls_2_prt_jan03_3_prt_mass" for table "ataprank2_1_prt_girls_2_prt_jan03"
NOTICE:  CREATE TABLE will create partition "ataprank2_1_prt_girls_2_prt_jan03_3_prt_cali" for table "ataprank2_1_prt_girls_2_prt_jan03"
NOTICE:  CREATE TABLE will create partition "ataprank2_1_prt_girls_2_prt_jan03_3_prt_ohio" for table "ataprank2_1_prt_girls_2_prt_jan03"
NOTICE:  CREATE TABLE will create partition "ataprank2_1_prt_girls_2_prt_jan04" for table "ataprank2_1_prt_girls"
NOTICE:  CREATE TABLE will create partition "ataprank2_1_prt_girls_2_prt_jan04_3_prt_mass" for table "ataprank2_1_prt_girls_2_prt_jan04"
NOTICE:  CREATE TABLE will create partition "ataprank2_1_prt_girls_2_prt_jan04_3_prt_cali" for table "ataprank2_1_prt_girls_2_prt_jan04"
NOTICE:  CREATE TABLE will create partition "ataprank2_1_prt_girls_2_prt_jan04_3_prt_ohio" for table "ataprank2_1_prt_girls_2_prt_jan04"
NOTICE:  CREATE TABLE will create partition "ataprank2_1_prt_girls_2_prt_jan05" for table "ataprank2_1_prt_girls"
NOTICE:  CREATE TABLE will create partition "ataprank2_1_prt_girls_2_prt_jan05_3_prt_mass" for table "ataprank2_1_prt_girls_2_prt_jan05"
NOTICE:  CREATE TABLE will create partition "ataprank2_1_prt_girls_2_prt_jan05_3_prt_cali" for table "ataprank2_1_prt_girls_2_prt_jan05"
NOTICE:  CREATE TABLE will create partition "ataprank2_1_prt_girls_2_prt_jan05_3_prt_ohio" for table "ataprank2_1_prt_girls_2_prt_jan05"
-- ok
alter table ataprank truncate partition girls;
NOTICE:  truncated partition "girls" for relation "ataprank" and its children
alter table ataprank alter partition girls truncate partition for (rank(1));
NOTICE:  truncated partition "jan01" for partition "girls" of relation "ataprank" and its children
alter table ataprank alter partition girls alter partition 
for (rank(1)) truncate partition mass;
NOTICE:  truncated partition "mass" for partition "jan01" of partition "girls" of relation "ataprank"
-- don't NOTIFY of children if cascade
alter table ataprank truncate partition girls cascade;
-- fail - no rank 100
alter table ataprank alter partition girls truncate partition for (rank(100));
ERROR:  partition for rank 100 of partition "girls" of relation "ataprank" does not exist
-- fail - no funky
alter table ataprank alter partition girls alter partition 
for (rank(1)) truncate partition "funky";
ERROR:  partition "funky" of partition "jan01" of partition "girls" of relation "ataprank" does not exist
-- fail - no funky (drop)
alter table ataprank alter partition girls alter partition 
for (rank(1)) drop partition "funky";
ERROR:  partition "funky" of partition "jan01" of partition "girls" of relation "ataprank" does not exist
-- fail - missing name
alter table ataprank alter partition girls alter partition 
for (rank(1)) drop partition ;
ERROR:  missing name or value for DROP for partition "jan01" of partition "girls" of relation "ataprank"
-- ok
alter table ataprank alter partition girls drop partition 
for (rank(1)) ;
NOTICE:  dropped partition "jan01" for partition "girls" of relation "ataprank" and its children
-- ok , skipping
alter table ataprank alter partition girls drop partition if exists jan01;
NOTICE:  partition "jan01" of partition "girls" of relation "ataprank" does not exist, skipping
-- ok until run out of partitions
alter table ataprank alter partition girls drop partition ;
NOTICE:  dropped partition "jan02" for partition "girls" of relation "ataprank" and its children
alter table ataprank alter partition girls drop partition ;
NOTICE:  dropped partition "jan03" for partition "girls" of relation "ataprank" and its children
alter table ataprank alter partition girls drop partition ;
NOTICE:  dropped partition "jan04" for partition "girls" of relation "ataprank" and its children
alter table ataprank alter partition girls drop partition ;
ERROR:  cannot drop partition "jan05" of partition "girls" of relation "ataprank" -- only one remains
HINT:  DROP the parent partition to remove the final partition
alter table ataprank alter partition girls drop partition ;
ERROR:  cannot drop partition "jan05" of partition "girls" of relation "ataprank" -- only one remains
HINT:  DROP the parent partition to remove the final partition
-- ok, skipping
alter table ataprank alter partition girls drop partition if exists for (rank(5));
NOTICE:  partition for specified rank of partition "girls" of relation "ataprank" does not exist, skipping
-- ok
alter table ataprank alter partition girls rename partition jan05 
to "funky fresh";
NOTICE:  renamed partition "jan05" to "funky fresh" for partition "girls" of relation "ataprank"
alter table ataprank alter partition girls rename partition "funky fresh"
to jan05;
NOTICE:  renamed partition "funky fresh" to "jan05" for partition "girls" of relation "ataprank"
-- fail , not exist
alter table ataprank alter partition girls alter partition jan05 rename
partition jan01 to foo;
ERROR:  partition "jan01" of partition "jan05" of partition "girls" of relation "ataprank" does not exist
-- fail not exist
alter table ataprank alter partition girls alter partition jan05 alter
partition cali rename partition foo to bar;
ERROR:  partition "foo" of partition "cali" of partition "jan05" of partition "girls" of relation "ataprank" does not exist
-- fail not partitioned
alter table ataprank alter partition girls alter partition jan05 alter
partition cali alter partition foo drop partition bar;
ERROR:  partition "cali" of partition "jan05" of partition "girls" of relation "ataprank" is not partitioned
-- ADD PARTITION, with and without templates
-- fails for ataprank (due to template), works for ataprank2
alter table ataprank
add partition neuter values ('N')
    (subpartition foo
         start ('2001-01-01') end ('2002-01-01')
         every (interval '1 month')
            (subpartition bar values ('AZ')));
ERROR:  subpartition configuration conflicts with subpartition template
alter table ataprank2
add partition neuter values ('N')
    (subpartition foo
         start ('2001-01-01') end ('2002-01-01')
         every (interval '1 month')
            (subpartition bar values ('AZ')));
NOTICE:  CREATE TABLE will create partition "ataprank2_1_prt_neuter" for table "ataprank2"
NOTICE:  CREATE TABLE will create partition "ataprank2_1_prt_neuter_2_prt_foo_1" for table "ataprank2_1_prt_neuter"
NOTICE:  CREATE TABLE will create partition "ataprank2_1_prt_neuter_2_prt_foo_1_3_prt_bar" for table "ataprank2_1_prt_neuter_2_prt_foo_1"
NOTICE:  CREATE TABLE will create partition "ataprank2_1_prt_neuter_2_prt_foo_2" for table "ataprank2_1_prt_neuter"
NOTICE:  CREATE TABLE will create partition "ataprank2_1_prt_neuter_2_prt_foo_2_3_prt_bar" for table "ataprank2_1_prt_neuter_2_prt_foo_2"
NOTICE:  CREATE TABLE will create partition "ataprank2_1_prt_neuter_2_prt_foo_3" for table "ataprank2_1_prt_neuter"
NOTICE:  CREATE TABLE will create partition "ataprank2_1_prt_neuter_2_prt_foo_3_3_prt_bar" for table "ataprank2_1_prt_neuter_2_prt_foo_3"
NOTICE:  CREATE TABLE will create partition "ataprank2_1_prt_neuter_2_prt_foo_4" for table "ataprank2_1_prt_neuter"
NOTICE:  CREATE TABLE will create partition "ataprank2_1_prt_neuter_2_prt_foo_4_3_prt_bar" for table "ataprank2_1_prt_neuter_2_prt_foo_4"
NOTICE:  CREATE TABLE will create partition "ataprank2_1_prt_neuter_2_prt_foo_5" for table "ataprank2_1_prt_neuter"
NOTICE:  CREATE TABLE will create partition "ataprank2_1_prt_neuter_2_prt_foo_5_3_prt_bar" for table "ataprank2_1_prt_neuter_2_prt_foo_5"
NOTICE:  CREATE TABLE will create partition "ataprank2_1_prt_neuter_2_prt_foo_6" for table "ataprank2_1_prt_neuter"
NOTICE:  CREATE TABLE will create partition "ataprank2_1_prt_neuter_2_prt_foo_6_3_prt_bar" for table "ataprank2_1_prt_neuter_2_prt_foo_6"
NOTICE:  CREATE TABLE will create partition "ataprank2_1_prt_neuter_2_prt_foo_7" for table "ataprank2_1_prt_neuter"
NOTICE:  CREATE TABLE will create partition "ataprank2_1_prt_neuter_2_prt_foo_7_3_prt_bar" for table "ataprank2_1_prt_neuter_2_prt_foo_7"
NOTICE:  CREATE TABLE will create partition "ataprank2_1_prt_neuter_2_prt_foo_8" for table "ataprank2_1_prt_neuter"
NOTICE:  CREATE TABLE will create partition "ataprank2_1_prt_neuter_2_prt_foo_8_3_prt_bar" for table "ataprank2_1_prt_neuter_2_prt_foo_8"
NOTICE:  CREATE TABLE will create partition "ataprank2_1_prt_neuter_2_prt_foo_9" for table "ataprank2_1_prt_neuter"
NOTICE:  CREATE TABLE will create partition "ataprank2_1_prt_neuter_2_prt_foo_9_3_prt_bar" for table "ataprank2_1_prt_neuter_2_prt_foo_9"
NOTICE:  CREATE TABLE will create partition "ataprank2_1_prt_neuter_2_prt_foo_10" for table "ataprank2_1_prt_neuter"
NOTICE:  CREATE TABLE will create partition "ataprank2_1_prt_neuter_2_prt_foo_10_3_prt_bar" for table "ataprank2_1_prt_neuter_2_prt_foo_10"
NOTICE:  CREATE TABLE will create partition "ataprank2_1_prt_neuter_2_prt_foo_11" for table "ataprank2_1_prt_neuter"
NOTICE:  CREATE TABLE will create partition "ataprank2_1_prt_neuter_2_prt_foo_11_3_prt_bar" for table "ataprank2_1_prt_neuter_2_prt_foo_11"
NOTICE:  CREATE TABLE will create partition "ataprank2_1_prt_neuter_2_prt_foo_12" for table "ataprank2_1_prt_neuter"
NOTICE:  CREATE TABLE will create partition "ataprank2_1_prt_neuter_2_prt_foo_12_3_prt_bar" for table "ataprank2_1_prt_neuter_2_prt_foo_12"
-- fail , no subpartition spec for ataprank2, works for ataprank
alter table ataprank alter partition boys
add partition jan00 start ('2000-01-01') end ('2001-01-01');
NOTICE:  CREATE TABLE will create partition "ataprank_1_prt_boys_2_prt_jan00" for table "ataprank_1_prt_boys"
NOTICE:  CREATE TABLE will create partition "ataprank_1_prt_boys_2_prt_jan00_3_prt_mass" for table "ataprank_1_prt_boys_2_prt_jan00"
NOTICE:  CREATE TABLE will create partition "ataprank_1_prt_boys_2_prt_jan00_3_prt_cali" for table "ataprank_1_prt_boys_2_prt_jan00"
NOTICE:  CREATE TABLE will create partition "ataprank_1_prt_boys_2_prt_jan00_3_prt_ohio" for table "ataprank_1_prt_boys_2_prt_jan00"
alter table ataprank2 alter partition boys
add partition jan00 start ('2000-01-01') end ('2001-01-01');
NOTICE:  CREATE TABLE will create partition "ataprank2_1_prt_boys_2_prt_jan00" for table "ataprank2_1_prt_boys"
ERROR:  no partitions specified at depth 3
-- work - create subpartition for ataprank2, fail for ataprank
alter table ataprank alter partition boys
add partition jan99 start ('1999-01-01') end ('2000-01-01')
  (subpartition ariz values ('AZ'));
ERROR:  subpartition configuration conflicts with subpartition template
alter table ataprank2 alter partition boys
add partition jan00 start ('2000-01-01') end ('2001-01-01')
  (subpartition ariz values ('AZ'));
NOTICE:  CREATE TABLE will create partition "ataprank2_1_prt_boys_2_prt_jan00" for table "ataprank2_1_prt_boys"
NOTICE:  CREATE TABLE will create partition "ataprank2_1_prt_boys_2_prt_jan00_3_prt_ariz" for table "ataprank2_1_prt_boys_2_prt_jan00"
-- works for both -- adding leaf partition doesn't conflict with template
alter table ataprank alter partition boys
alter partition jan00 
add partition haw values ('HI');
NOTICE:  CREATE TABLE will create partition "ataprank_1_prt_boys_2_prt_jan00_3_prt_haw" for table "ataprank_1_prt_boys_2_prt_jan00"
alter table ataprank2 alter partition boys
alter partition jan00 
add partition haw values ('HI');
NOTICE:  CREATE TABLE will create partition "ataprank2_1_prt_boys_2_prt_jan00_3_prt_haw" for table "ataprank2_1_prt_boys_2_prt_jan00"
alter table ataprank drop partition neuter;
ERROR:  partition "neuter" of relation "ataprank" does not exist
alter table ataprank2 drop partition neuter;
NOTICE:  dropped partition "neuter" for relation "ataprank2" and its children
-- fail , no subpartition spec for ataprank2, work for ataprank
alter table ataprank
add default partition neuter ;
NOTICE:  CREATE TABLE will create partition "ataprank_1_prt_neuter" for table "ataprank"
NOTICE:  CREATE TABLE will create partition "ataprank_1_prt_neuter_2_prt_jan01" for table "ataprank_1_prt_neuter"
NOTICE:  CREATE TABLE will create partition "ataprank_1_prt_neuter_2_prt_jan01_3_prt_mass" for table "ataprank_1_prt_neuter_2_prt_jan01"
NOTICE:  CREATE TABLE will create partition "ataprank_1_prt_neuter_2_prt_jan01_3_prt_cali" for table "ataprank_1_prt_neuter_2_prt_jan01"
NOTICE:  CREATE TABLE will create partition "ataprank_1_prt_neuter_2_prt_jan01_3_prt_ohio" for table "ataprank_1_prt_neuter_2_prt_jan01"
NOTICE:  CREATE TABLE will create partition "ataprank_1_prt_neuter_2_prt_jan01_3_prt_haw" for table "ataprank_1_prt_neuter_2_prt_jan01"
NOTICE:  CREATE TABLE will create partition "ataprank_1_prt_neuter_2_prt_jan02" for table "ataprank_1_prt_neuter"
NOTICE:  CREATE TABLE will create partition "ataprank_1_prt_neuter_2_prt_jan02_3_prt_mass" for table "ataprank_1_prt_neuter_2_prt_jan02"
NOTICE:  CREATE TABLE will create partition "ataprank_1_prt_neuter_2_prt_jan02_3_prt_cali" for table "ataprank_1_prt_neuter_2_prt_jan02"
NOTICE:  CREATE TABLE will create partition "ataprank_1_prt_neuter_2_prt_jan02_3_prt_ohio" for table "ataprank_1_prt_neuter_2_prt_jan02"
NOTICE:  CREATE TABLE will create partition "ataprank_1_prt_neuter_2_prt_jan02_3_prt_haw" for table "ataprank_1_prt_neuter_2_prt_jan02"
NOTICE:  CREATE TABLE will create partition "ataprank_1_prt_neuter_2_prt_jan03" for table "ataprank_1_prt_neuter"
NOTICE:  CREATE TABLE will create partition "ataprank_1_prt_neuter_2_prt_jan03_3_prt_mass" for table "ataprank_1_prt_neuter_2_prt_jan03"
NOTICE:  CREATE TABLE will create partition "ataprank_1_prt_neuter_2_prt_jan03_3_prt_cali" for table "ataprank_1_prt_neuter_2_prt_jan03"
NOTICE:  CREATE TABLE will create partition "ataprank_1_prt_neuter_2_prt_jan03_3_prt_ohio" for table "ataprank_1_prt_neuter_2_prt_jan03"
NOTICE:  CREATE TABLE will create partition "ataprank_1_prt_neuter_2_prt_jan03_3_prt_haw" for table "ataprank_1_prt_neuter_2_prt_jan03"
NOTICE:  CREATE TABLE will create partition "ataprank_1_prt_neuter_2_prt_jan04" for table "ataprank_1_prt_neuter"
NOTICE:  CREATE TABLE will create partition "ataprank_1_prt_neuter_2_prt_jan04_3_prt_mass" for table "ataprank_1_prt_neuter_2_prt_jan04"
NOTICE:  CREATE TABLE will create partition "ataprank_1_prt_neuter_2_prt_jan04_3_prt_cali" for table "ataprank_1_prt_neuter_2_prt_jan04"
NOTICE:  CREATE TABLE will create partition "ataprank_1_prt_neuter_2_prt_jan04_3_prt_ohio" for table "ataprank_1_prt_neuter_2_prt_jan04"
NOTICE:  CREATE TABLE will create partition "ataprank_1_prt_neuter_2_prt_jan04_3_prt_haw" for table "ataprank_1_prt_neuter_2_prt_jan04"
NOTICE:  CREATE TABLE will create partition "ataprank_1_prt_neuter_2_prt_jan05" for table "ataprank_1_prt_neuter"
NOTICE:  CREATE TABLE will create partition "ataprank_1_prt_neuter_2_prt_jan05_3_prt_mass" for table "ataprank_1_prt_neuter_2_prt_jan05"
NOTICE:  CREATE TABLE will create partition "ataprank_1_prt_neuter_2_prt_jan05_3_prt_cali" for table "ataprank_1_prt_neuter_2_prt_jan05"
NOTICE:  CREATE TABLE will create partition "ataprank_1_prt_neuter_2_prt_jan05_3_prt_ohio" for table "ataprank_1_prt_neuter_2_prt_jan05"
NOTICE:  CREATE TABLE will create partition "ataprank_1_prt_neuter_2_prt_jan05_3_prt_haw" for table "ataprank_1_prt_neuter_2_prt_jan05"
alter table ataprank2
add default partition neuter ;
NOTICE:  CREATE TABLE will create partition "ataprank2_1_prt_neuter" for table "ataprank2"
ERROR:  no partitions specified at depth 2
alter table ataprank
add default partition neuter 
    (subpartition foo
         start ('2001-01-01') end ('2002-01-01')
         every (interval '1 month')
            (subpartition ariz values ('AZ')));
ERROR:  partition "neuter" of relation "ataprank" already exists
alter table ataprank2
add default partition neuter 
    (subpartition foo
         start ('2001-01-01') end ('2002-01-01')
         every (interval '1 month')
            (subpartition ariz values ('AZ')));
NOTICE:  CREATE TABLE will create partition "ataprank2_1_prt_neuter" for table "ataprank2"
NOTICE:  CREATE TABLE will create partition "ataprank2_1_prt_neuter_2_prt_foo_1" for table "ataprank2_1_prt_neuter"
NOTICE:  CREATE TABLE will create partition "ataprank2_1_prt_neuter_2_prt_foo_1_3_prt_ariz" for table "ataprank2_1_prt_neuter_2_prt_foo_1"
NOTICE:  CREATE TABLE will create partition "ataprank2_1_prt_neuter_2_prt_foo_2" for table "ataprank2_1_prt_neuter"
NOTICE:  CREATE TABLE will create partition "ataprank2_1_prt_neuter_2_prt_foo_2_3_prt_ariz" for table "ataprank2_1_prt_neuter_2_prt_foo_2"
NOTICE:  CREATE TABLE will create partition "ataprank2_1_prt_neuter_2_prt_foo_3" for table "ataprank2_1_prt_neuter"
NOTICE:  CREATE TABLE will create partition "ataprank2_1_prt_neuter_2_prt_foo_3_3_prt_ariz" for table "ataprank2_1_prt_neuter_2_prt_foo_3"
NOTICE:  CREATE TABLE will create partition "ataprank2_1_prt_neuter_2_prt_foo_4" for table "ataprank2_1_prt_neuter"
NOTICE:  CREATE TABLE will create partition "ataprank2_1_prt_neuter_2_prt_foo_4_3_prt_ariz" for table "ataprank2_1_prt_neuter_2_prt_foo_4"
NOTICE:  CREATE TABLE will create partition "ataprank2_1_prt_neuter_2_prt_foo_5" for table "ataprank2_1_prt_neuter"
NOTICE:  CREATE TABLE will create partition "ataprank2_1_prt_neuter_2_prt_foo_5_3_prt_ariz" for table "ataprank2_1_prt_neuter_2_prt_foo_5"
NOTICE:  CREATE TABLE will create partition "ataprank2_1_prt_neuter_2_prt_foo_6" for table "ataprank2_1_prt_neuter"
NOTICE:  CREATE TABLE will create partition "ataprank2_1_prt_neuter_2_prt_foo_6_3_prt_ariz" for table "ataprank2_1_prt_neuter_2_prt_foo_6"
NOTICE:  CREATE TABLE will create partition "ataprank2_1_prt_neuter_2_prt_foo_7" for table "ataprank2_1_prt_neuter"
NOTICE:  CREATE TABLE will create partition "ataprank2_1_prt_neuter_2_prt_foo_7_3_prt_ariz" for table "ataprank2_1_prt_neuter_2_prt_foo_7"
NOTICE:  CREATE TABLE will create partition "ataprank2_1_prt_neuter_2_prt_foo_8" for table "ataprank2_1_prt_neuter"
NOTICE:  CREATE TABLE will create partition "ataprank2_1_prt_neuter_2_prt_foo_8_3_prt_ariz" for table "ataprank2_1_prt_neuter_2_prt_foo_8"
NOTICE:  CREATE TABLE will create partition "ataprank2_1_prt_neuter_2_prt_foo_9" for table "ataprank2_1_prt_neuter"
NOTICE:  CREATE TABLE will create partition "ataprank2_1_prt_neuter_2_prt_foo_9_3_prt_ariz" for table "ataprank2_1_prt_neuter_2_prt_foo_9"
NOTICE:  CREATE TABLE will create partition "ataprank2_1_prt_neuter_2_prt_foo_10" for table "ataprank2_1_prt_neuter"
NOTICE:  CREATE TABLE will create partition "ataprank2_1_prt_neuter_2_prt_foo_10_3_prt_ariz" for table "ataprank2_1_prt_neuter_2_prt_foo_10"
NOTICE:  CREATE TABLE will create partition "ataprank2_1_prt_neuter_2_prt_foo_11" for table "ataprank2_1_prt_neuter"
NOTICE:  CREATE TABLE will create partition "ataprank2_1_prt_neuter_2_prt_foo_11_3_prt_ariz" for table "ataprank2_1_prt_neuter_2_prt_foo_11"
NOTICE:  CREATE TABLE will create partition "ataprank2_1_prt_neuter_2_prt_foo_12" for table "ataprank2_1_prt_neuter"
NOTICE:  CREATE TABLE will create partition "ataprank2_1_prt_neuter_2_prt_foo_12_3_prt_ariz" for table "ataprank2_1_prt_neuter_2_prt_foo_12"
-- fail
alter table ataprank
alter default partition add default partition def1 
(subpartition haw values ('HI'));
ERROR:  subpartition configuration conflicts with subpartition template
-- fail
alter table ataprank
alter default partition alter default partition 
add default partition def2;
ERROR:  DEFAULT partition of partition "neuter" of relation "ataprank" does not exist
-- work
alter table ataprank
alter default partition add default partition def1;
NOTICE:  CREATE TABLE will create partition "ataprank_1_prt_neuter_2_prt_def1" for table "ataprank_1_prt_neuter"
NOTICE:  CREATE TABLE will create partition "ataprank_1_prt_neuter_2_prt_def1_3_prt_mass" for table "ataprank_1_prt_neuter_2_prt_def1"
NOTICE:  CREATE TABLE will create partition "ataprank_1_prt_neuter_2_prt_def1_3_prt_cali" for table "ataprank_1_prt_neuter_2_prt_def1"
NOTICE:  CREATE TABLE will create partition "ataprank_1_prt_neuter_2_prt_def1_3_prt_ohio" for table "ataprank_1_prt_neuter_2_prt_def1"
NOTICE:  CREATE TABLE will create partition "ataprank_1_prt_neuter_2_prt_def1_3_prt_haw" for table "ataprank_1_prt_neuter_2_prt_def1"
alter table ataprank
alter default partition alter default partition 
add default partition def2;
NOTICE:  CREATE TABLE will create partition "ataprank_1_prt_neuter_2_prt_def1_3_prt_def2" for table "ataprank_1_prt_neuter_2_prt_def1"
alter table ataprank2
alter default partition add default partition def1 
(subpartition haw values ('HI'));
NOTICE:  CREATE TABLE will create partition "ataprank2_1_prt_neuter_2_prt_def1" for table "ataprank2_1_prt_neuter"
NOTICE:  CREATE TABLE will create partition "ataprank2_1_prt_neuter_2_prt_def1_3_prt_haw" for table "ataprank2_1_prt_neuter_2_prt_def1"
alter table ataprank2
alter default partition alter default partition 
add default partition def2;
NOTICE:  CREATE TABLE will create partition "ataprank2_1_prt_neuter_2_prt_def1_3_prt_def2" for table "ataprank2_1_prt_neuter_2_prt_def1"
drop table ataprank ;
drop table ataprank2 ;
-- **END** ALTER TABLE ALTER PARTITION tests
-- Test casting
create table f (i int) partition by range (i) (start(1::int) end(10::int));
NOTICE:  Table doesn't have 'DISTRIBUTED BY' clause -- Using column named 'i' as the Greenplum Database data distribution key for this table.
HINT:  The 'DISTRIBUTED BY' clause determines the distribution of data. Make sure column(s) chosen are the optimal data distribution key to minimize skew.
NOTICE:  CREATE TABLE will create partition "f_1_prt_1" for table "f"
drop table f;
create table f (i bigint) partition by range (i) (start(1::int8)
end(1152921504606846976::int8) every(576460752303423488));
NOTICE:  Table doesn't have 'DISTRIBUTED BY' clause -- Using column named 'i' as the Greenplum Database data distribution key for this table.
HINT:  The 'DISTRIBUTED BY' clause determines the distribution of data. Make sure column(s) chosen are the optimal data distribution key to minimize skew.
NOTICE:  CREATE TABLE will create partition "f_1_prt_1" for table "f"
NOTICE:  CREATE TABLE will create partition "f_1_prt_2" for table "f"
drop table f;
create table f (n numeric(20, 2)) partition by range(n) (start(1::bigint)
end(10000::bigint));
NOTICE:  Table doesn't have 'DISTRIBUTED BY' clause -- Using column named 'n' as the Greenplum Database data distribution key for this table.
HINT:  The 'DISTRIBUTED BY' clause determines the distribution of data. Make sure column(s) chosen are the optimal data distribution key to minimize skew.
NOTICE:  CREATE TABLE will create partition "f_1_prt_1" for table "f"
drop table f;
create table f (n numeric(20, 2)) partition by range(n) (start(1::bigint)
end(10000::text));
NOTICE:  Table doesn't have 'DISTRIBUTED BY' clause -- Using column named 'n' as the Greenplum Database data distribution key for this table.
HINT:  The 'DISTRIBUTED BY' clause determines the distribution of data. Make sure column(s) chosen are the optimal data distribution key to minimize skew.
NOTICE:  CREATE TABLE will create partition "f_1_prt_1" for table "f"
drop table f;
--should fail. bool -> numeric makes no sense
create table f (n numeric(20, 2)) partition by range(n) (start(1::bigint)
end('f'::bool));
NOTICE:  Table doesn't have 'DISTRIBUTED BY' clause -- Using column named 'n' as the Greenplum Database data distribution key for this table.
HINT:  The 'DISTRIBUTED BY' clause determines the distribution of data. Make sure column(s) chosen are the optimal data distribution key to minimize skew.
ERROR:  cannot coerce partition parameter to column type "numeric"
LINE 2: end('f'::bool));
            ^
-- see that grant and revoke cascade to children
create role part_role;
NOTICE:  resource queue required -- using default resource queue "pg_default"
create table granttest (i int, j int) partition by range(i) 
subpartition by list(j) subpartition template (values(1, 2, 3))
(start(1) end(4) every(1));
NOTICE:  Table doesn't have 'DISTRIBUTED BY' clause -- Using column named 'i' as the Greenplum Database data distribution key for this table.
HINT:  The 'DISTRIBUTED BY' clause determines the distribution of data. Make sure column(s) chosen are the optimal data distribution key to minimize skew.
NOTICE:  CREATE TABLE will create partition "granttest_1_prt_1" for table "granttest"
NOTICE:  CREATE TABLE will create partition "granttest_1_prt_1_2_prt_1" for table "granttest_1_prt_1"
NOTICE:  CREATE TABLE will create partition "granttest_1_prt_2" for table "granttest"
NOTICE:  CREATE TABLE will create partition "granttest_1_prt_2_2_prt_1" for table "granttest_1_prt_2"
NOTICE:  CREATE TABLE will create partition "granttest_1_prt_3" for table "granttest"
NOTICE:  CREATE TABLE will create partition "granttest_1_prt_3_2_prt_1" for table "granttest_1_prt_3"
select relname, has_table_privilege('part_role', oid,'select') as tabpriv,
       has_column_privilege('part_role', oid, 'i', 'select') as i_priv,
       has_column_privilege('part_role', oid, 'j', 'select') as j_priv
from pg_class where relname like 'granttest%';
          relname          | tabpriv | i_priv | j_priv 
---------------------------+---------+--------+--------
 granttest_1_prt_2         | f       | f      | f
 granttest_1_prt_2_2_prt_1 | f       | f      | f
 granttest_1_prt_3         | f       | f      | f
 granttest_1_prt_3_2_prt_1 | f       | f      | f
 granttest                 | f       | f      | f
 granttest_1_prt_1         | f       | f      | f
 granttest_1_prt_1_2_prt_1 | f       | f      | f
(7 rows)

grant select (i) on granttest to part_role;
select relname, has_table_privilege('part_role', oid,'select') as tabpriv,
       has_column_privilege('part_role', oid, 'i', 'select') as i_priv,
       has_column_privilege('part_role', oid, 'j', 'select') as j_priv
from pg_class where relname like 'granttest%';
          relname          | tabpriv | i_priv | j_priv 
---------------------------+---------+--------+--------
 granttest_1_prt_2         | f       | t      | f
 granttest_1_prt_2_2_prt_1 | f       | t      | f
 granttest_1_prt_3         | f       | t      | f
 granttest_1_prt_3_2_prt_1 | f       | t      | f
 granttest                 | f       | t      | f
 granttest_1_prt_1         | f       | t      | f
 granttest_1_prt_1_2_prt_1 | f       | t      | f
(7 rows)

grant select on granttest to part_role;
select relname, has_table_privilege('part_role', oid,'select') as tabpriv,
       has_column_privilege('part_role', oid, 'i', 'select') as i_priv,
       has_column_privilege('part_role', oid, 'j', 'select') as j_priv
from pg_class where relname like 'granttest%';
          relname          | tabpriv | i_priv | j_priv 
---------------------------+---------+--------+--------
 granttest_1_prt_1         | t       | t      | t
 granttest_1_prt_1_2_prt_1 | t       | t      | t
 granttest_1_prt_2         | t       | t      | t
 granttest_1_prt_2_2_prt_1 | t       | t      | t
 granttest_1_prt_3         | t       | t      | t
 granttest_1_prt_3_2_prt_1 | t       | t      | t
 granttest                 | t       | t      | t
(7 rows)

grant insert on granttest to part_role;
select relname, has_table_privilege('part_role', oid, 'insert') as tabpriv,
       has_column_privilege('part_role', oid, 'i', 'insert') as i_priv,
       has_column_privilege('part_role', oid, 'j', 'insert') as j_priv
from pg_class where relname like 'granttest%';
          relname          | tabpriv | i_priv | j_priv 
---------------------------+---------+--------+--------
 granttest_1_prt_1         | t       | t      | t
 granttest_1_prt_1_2_prt_1 | t       | t      | t
 granttest_1_prt_2         | t       | t      | t
 granttest_1_prt_2_2_prt_1 | t       | t      | t
 granttest_1_prt_3         | t       | t      | t
 granttest_1_prt_3_2_prt_1 | t       | t      | t
 granttest                 | t       | t      | t
(7 rows)

revoke insert on granttest from part_role;
grant insert (j) on granttest to part_role;
select relname, has_table_privilege('part_role', oid, 'insert') as tabpriv,
       has_column_privilege('part_role', oid, 'i', 'insert') as i_priv,
       has_column_privilege('part_role', oid, 'j', 'insert') as j_priv
from pg_class where relname like 'granttest%';
          relname          | tabpriv | i_priv | j_priv 
---------------------------+---------+--------+--------
 granttest_1_prt_1         | f       | f      | t
 granttest_1_prt_1_2_prt_1 | f       | f      | t
 granttest_1_prt_2         | f       | f      | t
 granttest_1_prt_2_2_prt_1 | f       | f      | t
 granttest_1_prt_3         | f       | f      | t
 granttest_1_prt_3_2_prt_1 | f       | f      | t
 granttest                 | f       | f      | t
(7 rows)

-- Check that when a new partition is created, it inherits the permissions
-- from the parent.
alter table granttest add partition newpart start(100) end (101);
NOTICE:  CREATE TABLE will create partition "granttest_1_prt_newpart" for table "granttest"
NOTICE:  CREATE TABLE will create partition "granttest_1_prt_newpart_2_prt_1" for table "granttest_1_prt_newpart"
select relname, has_table_privilege('part_role', oid, 'select') as tabpriv,
       has_column_privilege('part_role', oid, 'i', 'select') as i_priv,
       has_column_privilege('part_role', oid, 'j', 'select') as j_priv
from pg_class where relname like 'granttest%';
             relname             | tabpriv | i_priv | j_priv 
---------------------------------+---------+--------+--------
 granttest_1_prt_1               | t       | t      | t
 granttest_1_prt_1_2_prt_1       | t       | t      | t
 granttest_1_prt_2               | t       | t      | t
 granttest_1_prt_2_2_prt_1       | t       | t      | t
 granttest_1_prt_3               | t       | t      | t
 granttest_1_prt_3_2_prt_1       | t       | t      | t
 granttest                       | t       | t      | t
 granttest_1_prt_newpart         | t       | t      | t
 granttest_1_prt_newpart_2_prt_1 | t       | t      | t
(9 rows)

select relname, has_table_privilege('part_role', oid, 'insert') as tabpriv,
       has_column_privilege('part_role', oid, 'i', 'insert') as i_priv,
       has_column_privilege('part_role', oid, 'j', 'insert') as j_priv
from pg_class where relname like 'granttest%';
             relname             | tabpriv | i_priv | j_priv 
---------------------------------+---------+--------+--------
 granttest_1_prt_1               | f       | f      | t
 granttest_1_prt_1_2_prt_1       | f       | f      | t
 granttest_1_prt_2               | f       | f      | t
 granttest_1_prt_2_2_prt_1       | f       | f      | t
 granttest_1_prt_3               | f       | f      | t
 granttest_1_prt_3_2_prt_1       | f       | f      | t
 granttest                       | f       | f      | t
 granttest_1_prt_newpart         | f       | f      | t
 granttest_1_prt_newpart_2_prt_1 | f       | f      | t
(9 rows)

revoke all on granttest from part_role;
select relname, has_table_privilege('part_role', oid, 'insert') as tabpriv,
       has_column_privilege('part_role', oid, 'i', 'insert') as i_priv,
       has_column_privilege('part_role', oid, 'j', 'insert') as j_priv
from pg_class where relname like 'granttest%';
             relname             | tabpriv | i_priv | j_priv 
---------------------------------+---------+--------+--------
 granttest_1_prt_1               | f       | f      | f
 granttest_1_prt_1_2_prt_1       | f       | f      | f
 granttest_1_prt_2               | f       | f      | f
 granttest_1_prt_2_2_prt_1       | f       | f      | f
 granttest_1_prt_3               | f       | f      | f
 granttest_1_prt_3_2_prt_1       | f       | f      | f
 granttest_1_prt_newpart         | f       | f      | f
 granttest_1_prt_newpart_2_prt_1 | f       | f      | f
 granttest                       | f       | f      | f
(9 rows)

drop table granttest;
drop role part_role;
-- deep inline + optional subpartition comma:
CREATE TABLE partsupp_1 (
    ps_partkey integer,
    ps_suppkey integer,
    ps_availqty integer,
    ps_supplycost numeric,
    ps_comment character varying(199)
) distributed by (ps_partkey) PARTITION BY RANGE(ps_suppkey)
          SUBPARTITION BY RANGE(ps_partkey)
                  SUBPARTITION BY RANGE(ps_supplycost) 
          (
          PARTITION p1_1 START (1) END (1666667) EVERY (1666666) 
                  (
                  START (1) END (19304783) 
                          (
                          START (1::numeric) END (501::numeric) EVERY (500), 
                          START (501::numeric) END (1001::numeric) EVERY (500)
                          ), 
                  START (19304783) END (100000001) 
                          (
                          START (1::numeric) END (501::numeric) EVERY (500), 
                          START (501::numeric) END (1001::numeric) EVERY (500)
                          )
                  ), 
          PARTITION p1_2 START (1666667) END (3333333) EVERY (1666666) 
                  (
                  START (1) END (19304783) 
                          (
                          START (1::numeric) END (501::numeric) EVERY (500), 
                          START (501::numeric) END (1001::numeric) EVERY (500)
                          ), 
                  START (19304783) END (100000001) 
                          (
                          START (1::numeric) END (501::numeric) EVERY (500), 
                          START (501::numeric) END (1001::numeric) EVERY (500)
                          )
                  ), 
          PARTITION p1_3 START (3333333) END (4999999) EVERY (1666666) 
                  (
                  START (1) END (19304783) 
                          (
                          START (1::numeric) END (501::numeric) EVERY (500), 
                          START (501::numeric) END (1001::numeric) EVERY (500)
                          ), 
                  START (19304783) END (100000001) 
                          (
                          START (1::numeric) END (501::numeric) EVERY (500), 
                          START (501::numeric) END (1001::numeric) EVERY (500)
                          )
                  ), 
          PARTITION p1_4 START (4999999) END (5000001) EVERY (1666666) 
                  (
                  START (1) END (19304783) 
                          (
                          START (1::numeric) END (501::numeric) EVERY (500), 
                          START (501::numeric) END (1001::numeric) EVERY (500)
                          ), 
                  START (19304783) END (100000001) 
                          (
                          START (1::numeric) END (501::numeric) EVERY (500), 
                          START (501::numeric) END (1001::numeric) EVERY (500)
                          )
                  )
          );
NOTICE:  CREATE TABLE will create partition "partsupp_1_1_prt_p1_1" for table "partsupp_1"
NOTICE:  CREATE TABLE will create partition "partsupp_1_1_prt_p1_1_2_prt_1" for table "partsupp_1_1_prt_p1_1"
NOTICE:  CREATE TABLE will create partition "partsupp_1_1_prt_p1_1_2_prt_1_3_prt_1" for table "partsupp_1_1_prt_p1_1_2_prt_1"
NOTICE:  CREATE TABLE will create partition "partsupp_1_1_prt_p1_1_2_prt_1_3_prt_2" for table "partsupp_1_1_prt_p1_1_2_prt_1"
NOTICE:  CREATE TABLE will create partition "partsupp_1_1_prt_p1_1_2_prt_2" for table "partsupp_1_1_prt_p1_1"
NOTICE:  CREATE TABLE will create partition "partsupp_1_1_prt_p1_1_2_prt_2_3_prt_1" for table "partsupp_1_1_prt_p1_1_2_prt_2"
NOTICE:  CREATE TABLE will create partition "partsupp_1_1_prt_p1_1_2_prt_2_3_prt_2" for table "partsupp_1_1_prt_p1_1_2_prt_2"
NOTICE:  CREATE TABLE will create partition "partsupp_1_1_prt_p1_2" for table "partsupp_1"
NOTICE:  CREATE TABLE will create partition "partsupp_1_1_prt_p1_2_2_prt_1" for table "partsupp_1_1_prt_p1_2"
NOTICE:  CREATE TABLE will create partition "partsupp_1_1_prt_p1_2_2_prt_1_3_prt_1" for table "partsupp_1_1_prt_p1_2_2_prt_1"
NOTICE:  CREATE TABLE will create partition "partsupp_1_1_prt_p1_2_2_prt_1_3_prt_2" for table "partsupp_1_1_prt_p1_2_2_prt_1"
NOTICE:  CREATE TABLE will create partition "partsupp_1_1_prt_p1_2_2_prt_2" for table "partsupp_1_1_prt_p1_2"
NOTICE:  CREATE TABLE will create partition "partsupp_1_1_prt_p1_2_2_prt_2_3_prt_1" for table "partsupp_1_1_prt_p1_2_2_prt_2"
NOTICE:  CREATE TABLE will create partition "partsupp_1_1_prt_p1_2_2_prt_2_3_prt_2" for table "partsupp_1_1_prt_p1_2_2_prt_2"
NOTICE:  CREATE TABLE will create partition "partsupp_1_1_prt_p1_3" for table "partsupp_1"
NOTICE:  CREATE TABLE will create partition "partsupp_1_1_prt_p1_3_2_prt_1" for table "partsupp_1_1_prt_p1_3"
NOTICE:  CREATE TABLE will create partition "partsupp_1_1_prt_p1_3_2_prt_1_3_prt_1" for table "partsupp_1_1_prt_p1_3_2_prt_1"
NOTICE:  CREATE TABLE will create partition "partsupp_1_1_prt_p1_3_2_prt_1_3_prt_2" for table "partsupp_1_1_prt_p1_3_2_prt_1"
NOTICE:  CREATE TABLE will create partition "partsupp_1_1_prt_p1_3_2_prt_2" for table "partsupp_1_1_prt_p1_3"
NOTICE:  CREATE TABLE will create partition "partsupp_1_1_prt_p1_3_2_prt_2_3_prt_1" for table "partsupp_1_1_prt_p1_3_2_prt_2"
NOTICE:  CREATE TABLE will create partition "partsupp_1_1_prt_p1_3_2_prt_2_3_prt_2" for table "partsupp_1_1_prt_p1_3_2_prt_2"
NOTICE:  CREATE TABLE will create partition "partsupp_1_1_prt_p1_4" for table "partsupp_1"
NOTICE:  CREATE TABLE will create partition "partsupp_1_1_prt_p1_4_2_prt_1" for table "partsupp_1_1_prt_p1_4"
NOTICE:  CREATE TABLE will create partition "partsupp_1_1_prt_p1_4_2_prt_1_3_prt_1" for table "partsupp_1_1_prt_p1_4_2_prt_1"
NOTICE:  CREATE TABLE will create partition "partsupp_1_1_prt_p1_4_2_prt_1_3_prt_2" for table "partsupp_1_1_prt_p1_4_2_prt_1"
NOTICE:  CREATE TABLE will create partition "partsupp_1_1_prt_p1_4_2_prt_2" for table "partsupp_1_1_prt_p1_4"
NOTICE:  CREATE TABLE will create partition "partsupp_1_1_prt_p1_4_2_prt_2_3_prt_1" for table "partsupp_1_1_prt_p1_4_2_prt_2"
NOTICE:  CREATE TABLE will create partition "partsupp_1_1_prt_p1_4_2_prt_2_3_prt_2" for table "partsupp_1_1_prt_p1_4_2_prt_2"
-- Accept negative values trivially:
create table partition_g (i int) partition by range(i) (start((-1)) end(10));
NOTICE:  Table doesn't have 'DISTRIBUTED BY' clause -- Using column named 'i' as the Greenplum Database data distribution key for this table.
HINT:  The 'DISTRIBUTED BY' clause determines the distribution of data. Make sure column(s) chosen are the optimal data distribution key to minimize skew.
NOTICE:  CREATE TABLE will create partition "partition_g_1_prt_1" for table "partition_g"
drop table partition_g;
create table partition_g (i int) partition by range(i) (start(-1) end(10));
NOTICE:  Table doesn't have 'DISTRIBUTED BY' clause -- Using column named 'i' as the Greenplum Database data distribution key for this table.
HINT:  The 'DISTRIBUTED BY' clause determines the distribution of data. Make sure column(s) chosen are the optimal data distribution key to minimize skew.
NOTICE:  CREATE TABLE will create partition "partition_g_1_prt_1" for table "partition_g"
drop table partition_g;
CREATE TABLE orders (
    o_orderkey bigint,
    o_custkey integer,
    o_orderstatus character(1),
    o_totalprice numeric,
    o_orderdate date,
    o_orderpriority character(15),
    o_clerk character(15),
    o_shippriority integer,
    o_comment character varying(79)
)
WITH (appendonly=true, checksum=true, blocksize=368640, compresslevel=9) PARTITION BY RANGE(o_orderdate)
          SUBPARTITION BY RANGE(o_custkey)
                  SUBPARTITION BY RANGE(o_orderkey) 
          (
          PARTITION p1_1 START ('1992-01-01'::date) END ('1993-06-01'::date) EVERY ('1 year 5 mons'::interval) WITH (appendonly=true, checksum=true, blocksize=368640, compresslevel=9) 
                  (
                  SUBPARTITION sp1 START (1) END (46570) WITH (appendonly=true, checksum=true, blocksize=368640, compresslevel=9) 
                          (
                          START (1::bigint) END (1500001::bigint) EVERY (1500000) WITH (appendonly=true, checksum=true, blocksize=368640, compresslevel=9), 
                          START (1500001::bigint) END (3000001::bigint) EVERY (1500000) WITH (appendonly=true, checksum=true, blocksize=368640, compresslevel=9), 
                          START (3000001::bigint) END (4500001::bigint) EVERY (1500000) WITH (appendonly=true, checksum=true, blocksize=368640, compresslevel=9), 
                          START (4500001::bigint) END (6000001::bigint) EVERY (1500000) WITH (appendonly=true, checksum=true, blocksize=368640, compresslevel=9)
                          ), 
                  SUBPARTITION sp2 START (46570) END (150001) INCLUSIVE WITH (appendonly=true, checksum=true, blocksize=368640, compresslevel=9) 
                          (
                          START (1::bigint) END (1500001::bigint) EVERY (1500000) WITH (appendonly=true, checksum=true, blocksize=368640, compresslevel=9), 
                          START (1500001::bigint) END (3000001::bigint) EVERY (1500000) WITH (appendonly=true, checksum=true, blocksize=368640, compresslevel=9), 
                          START (3000001::bigint) END (4500001::bigint) EVERY (1500000) WITH (appendonly=true, checksum=true, blocksize=368640, compresslevel=9), 
                          START (4500001::bigint) END (6000001::bigint) EVERY (1500000) WITH (appendonly=true, checksum=true, blocksize=368640, compresslevel=9)
                          )
                  ), 
          PARTITION p1_2 START ('1993-06-01'::date) END ('1994-11-01'::date) EVERY ('1 year 5 mons'::interval) WITH (appendonly=true, checksum=true, blocksize=368640, compresslevel=9) 
                  (
                  SUBPARTITION sp1 START (1) END (46570) WITH (appendonly=true, checksum=true, blocksize=368640, compresslevel=9) 
                          (
                          START (1::bigint) END (1500001::bigint) EVERY (1500000) WITH (appendonly=true, checksum=true, blocksize=368640, compresslevel=9), 
                          START (1500001::bigint) END (3000001::bigint) EVERY (1500000) WITH (appendonly=true, checksum=true, blocksize=368640, compresslevel=9), 
                          START (3000001::bigint) END (4500001::bigint) EVERY (1500000) WITH (appendonly=true, checksum=true, blocksize=368640, compresslevel=9), 
                          START (4500001::bigint) END (6000001::bigint) EVERY (1500000) WITH (appendonly=true, checksum=true, blocksize=368640, compresslevel=9)
                          ), 
                  SUBPARTITION sp2 START (46570) END (150001) INCLUSIVE WITH (appendonly=true, checksum=true, blocksize=368640, compresslevel=9) 
                          (
                          START (1::bigint) END (1500001::bigint) EVERY (1500000) WITH (appendonly=true, checksum=true, blocksize=368640, compresslevel=9), 
                          START (1500001::bigint) END (3000001::bigint) EVERY (1500000) WITH (appendonly=true, checksum=true, blocksize=368640, compresslevel=9), 
                          START (3000001::bigint) END (4500001::bigint) EVERY (1500000) WITH (appendonly=true, checksum=true, blocksize=368640, compresslevel=9), 
                          START (4500001::bigint) END (6000001::bigint) EVERY (1500000) WITH (appendonly=true, checksum=true, blocksize=368640, compresslevel=9)
                          )
                  ), 
          PARTITION p1_3 START ('1994-11-01'::date) END ('1996-04-01'::date) EVERY ('1 year 5 mons'::interval) WITH (appendonly=true, checksum=true, blocksize=368640, compresslevel=9) 
                  (
                  SUBPARTITION sp1 START (1) END (46570) WITH (appendonly=true, checksum=true, blocksize=368640, compresslevel=9) 
                          (
                          START (1::bigint) END (1500001::bigint) EVERY (1500000) WITH (appendonly=true, checksum=true, blocksize=368640, compresslevel=9), 
                          START (1500001::bigint) END (3000001::bigint) EVERY (1500000) WITH (appendonly=true, checksum=true, blocksize=368640, compresslevel=9), 
                          START (3000001::bigint) END (4500001::bigint) EVERY (1500000) WITH (appendonly=true, checksum=true, blocksize=368640, compresslevel=9), 
                          START (4500001::bigint) END (6000001::bigint) EVERY (1500000) WITH (appendonly=true, checksum=true, blocksize=368640, compresslevel=9)
                          ), 
                  SUBPARTITION sp2 START (46570) END (150001) INCLUSIVE WITH (appendonly=true, checksum=true, blocksize=368640, compresslevel=9) 
                          (
                          START (1::bigint) END (1500001::bigint) EVERY (1500000) WITH (appendonly=true, checksum=true, blocksize=368640, compresslevel=9), 
                          START (1500001::bigint) END (3000001::bigint) EVERY (1500000) WITH (appendonly=true, checksum=true, blocksize=368640, compresslevel=9), 
                          START (3000001::bigint) END (4500001::bigint) EVERY (1500000) WITH (appendonly=true, checksum=true, blocksize=368640, compresslevel=9), 
                          START (4500001::bigint) END (6000001::bigint) EVERY (1500000) WITH (appendonly=true, checksum=true, blocksize=368640, compresslevel=9)
                          )
                  ), 
          PARTITION p1_4 START ('1996-04-01'::date) END ('1997-09-01'::date) EVERY ('1 year 5 mons'::interval) WITH (appendonly=true, checksum=true, blocksize=368640, compresslevel=9) 
                  (
                  SUBPARTITION sp1 START (1) END (46570) WITH (appendonly=true, checksum=true, blocksize=368640, compresslevel=9) 
                          (
                          START (1::bigint) END (1500001::bigint) EVERY (1500000) WITH (appendonly=true, checksum=true, blocksize=368640, compresslevel=9), 
                          START (1500001::bigint) END (3000001::bigint) EVERY (1500000) WITH (appendonly=true, checksum=true, blocksize=368640, compresslevel=9), 
                          START (3000001::bigint) END (4500001::bigint) EVERY (1500000) WITH (appendonly=true, checksum=true, blocksize=368640, compresslevel=9), 
                          START (4500001::bigint) END (6000001::bigint) EVERY (1500000) WITH (appendonly=true, checksum=true, blocksize=368640, compresslevel=9)
                          ), 
                  SUBPARTITION sp2 START (46570) END (150001) INCLUSIVE WITH (appendonly=true, checksum=true, blocksize=368640, compresslevel=9) 
                          (
                          START (1::bigint) END (1500001::bigint) EVERY (1500000) WITH (appendonly=true, checksum=true, blocksize=368640, compresslevel=9), 
                          START (1500001::bigint) END (3000001::bigint) EVERY (1500000) WITH (appendonly=true, checksum=true, blocksize=368640, compresslevel=9), 
                          START (3000001::bigint) END (4500001::bigint) EVERY (1500000) WITH (appendonly=true, checksum=true, blocksize=368640, compresslevel=9), 
                          START (4500001::bigint) END (6000001::bigint) EVERY (1500000) WITH (appendonly=true, checksum=true, blocksize=368640, compresslevel=9)
                          )
                  ), 
          PARTITION p1_5 START ('1997-09-01'::date) END ('1998-08-03'::date) EVERY ('1 year 5 mons'::interval) WITH (appendonly=true, checksum=true, blocksize=368640, compresslevel=9) 
                  (
                  SUBPARTITION sp1 START (1) END (46570) WITH (appendonly=true, checksum=true, blocksize=368640, compresslevel=9) 
                          (
                          START (1::bigint) END (1500001::bigint) EVERY (1500000) WITH (appendonly=true, checksum=true, blocksize=368640, compresslevel=9), 
                          START (1500001::bigint) END (3000001::bigint) EVERY (1500000) WITH (appendonly=true, checksum=true, blocksize=368640, compresslevel=9), 
                          START (3000001::bigint) END (4500001::bigint) EVERY (1500000) WITH (appendonly=true, checksum=true, blocksize=368640, compresslevel=9), 
                          START (4500001::bigint) END (6000001::bigint) EVERY (1500000) WITH (appendonly=true, checksum=true, blocksize=368640, compresslevel=9)
                          ), 
                  SUBPARTITION sp2 START (46570) END (150001) INCLUSIVE WITH (appendonly=true, checksum=true, blocksize=368640, compresslevel=9) 
                          (
                          START (1::bigint) END (1500001::bigint) EVERY (1500000) WITH (appendonly=true, checksum=true, blocksize=368640, compresslevel=9), 
                          START (1500001::bigint) END (3000001::bigint) EVERY (1500000) WITH (appendonly=true, checksum=true, blocksize=368640, compresslevel=9), 
                          START (3000001::bigint) END (4500001::bigint) EVERY (1500000) WITH (appendonly=true, checksum=true, blocksize=368640, compresslevel=9), 
                          START (4500001::bigint) END (6000001::bigint) EVERY (1500000) WITH (appendonly=true, checksum=true, blocksize=368640, compresslevel=9)
                          )
                  )
          );
NOTICE:  Table doesn't have 'DISTRIBUTED BY' clause -- Using column named 'o_orderkey' as the Greenplum Database data distribution key for this table.
HINT:  The 'DISTRIBUTED BY' clause determines the distribution of data. Make sure column(s) chosen are the optimal data distribution key to minimize skew.
NOTICE:  CREATE TABLE will create partition "orders_1_prt_p1_1" for table "orders"
NOTICE:  CREATE TABLE will create partition "orders_1_prt_p1_1_2_prt_sp1" for table "orders_1_prt_p1_1"
NOTICE:  CREATE TABLE will create partition "orders_1_prt_p1_1_2_prt_sp1_3_prt_1" for table "orders_1_prt_p1_1_2_prt_sp1"
NOTICE:  CREATE TABLE will create partition "orders_1_prt_p1_1_2_prt_sp1_3_prt_2" for table "orders_1_prt_p1_1_2_prt_sp1"
NOTICE:  CREATE TABLE will create partition "orders_1_prt_p1_1_2_prt_sp1_3_prt_3" for table "orders_1_prt_p1_1_2_prt_sp1"
NOTICE:  CREATE TABLE will create partition "orders_1_prt_p1_1_2_prt_sp1_3_prt_4" for table "orders_1_prt_p1_1_2_prt_sp1"
NOTICE:  CREATE TABLE will create partition "orders_1_prt_p1_1_2_prt_sp2" for table "orders_1_prt_p1_1"
NOTICE:  CREATE TABLE will create partition "orders_1_prt_p1_1_2_prt_sp2_3_prt_1" for table "orders_1_prt_p1_1_2_prt_sp2"
NOTICE:  CREATE TABLE will create partition "orders_1_prt_p1_1_2_prt_sp2_3_prt_2" for table "orders_1_prt_p1_1_2_prt_sp2"
NOTICE:  CREATE TABLE will create partition "orders_1_prt_p1_1_2_prt_sp2_3_prt_3" for table "orders_1_prt_p1_1_2_prt_sp2"
NOTICE:  CREATE TABLE will create partition "orders_1_prt_p1_1_2_prt_sp2_3_prt_4" for table "orders_1_prt_p1_1_2_prt_sp2"
NOTICE:  CREATE TABLE will create partition "orders_1_prt_p1_2" for table "orders"
NOTICE:  CREATE TABLE will create partition "orders_1_prt_p1_2_2_prt_sp1" for table "orders_1_prt_p1_2"
NOTICE:  CREATE TABLE will create partition "orders_1_prt_p1_2_2_prt_sp1_3_prt_1" for table "orders_1_prt_p1_2_2_prt_sp1"
NOTICE:  CREATE TABLE will create partition "orders_1_prt_p1_2_2_prt_sp1_3_prt_2" for table "orders_1_prt_p1_2_2_prt_sp1"
NOTICE:  CREATE TABLE will create partition "orders_1_prt_p1_2_2_prt_sp1_3_prt_3" for table "orders_1_prt_p1_2_2_prt_sp1"
NOTICE:  CREATE TABLE will create partition "orders_1_prt_p1_2_2_prt_sp1_3_prt_4" for table "orders_1_prt_p1_2_2_prt_sp1"
NOTICE:  CREATE TABLE will create partition "orders_1_prt_p1_2_2_prt_sp2" for table "orders_1_prt_p1_2"
NOTICE:  CREATE TABLE will create partition "orders_1_prt_p1_2_2_prt_sp2_3_prt_1" for table "orders_1_prt_p1_2_2_prt_sp2"
NOTICE:  CREATE TABLE will create partition "orders_1_prt_p1_2_2_prt_sp2_3_prt_2" for table "orders_1_prt_p1_2_2_prt_sp2"
NOTICE:  CREATE TABLE will create partition "orders_1_prt_p1_2_2_prt_sp2_3_prt_3" for table "orders_1_prt_p1_2_2_prt_sp2"
NOTICE:  CREATE TABLE will create partition "orders_1_prt_p1_2_2_prt_sp2_3_prt_4" for table "orders_1_prt_p1_2_2_prt_sp2"
NOTICE:  CREATE TABLE will create partition "orders_1_prt_p1_3" for table "orders"
NOTICE:  CREATE TABLE will create partition "orders_1_prt_p1_3_2_prt_sp1" for table "orders_1_prt_p1_3"
NOTICE:  CREATE TABLE will create partition "orders_1_prt_p1_3_2_prt_sp1_3_prt_1" for table "orders_1_prt_p1_3_2_prt_sp1"
NOTICE:  CREATE TABLE will create partition "orders_1_prt_p1_3_2_prt_sp1_3_prt_2" for table "orders_1_prt_p1_3_2_prt_sp1"
NOTICE:  CREATE TABLE will create partition "orders_1_prt_p1_3_2_prt_sp1_3_prt_3" for table "orders_1_prt_p1_3_2_prt_sp1"
NOTICE:  CREATE TABLE will create partition "orders_1_prt_p1_3_2_prt_sp1_3_prt_4" for table "orders_1_prt_p1_3_2_prt_sp1"
NOTICE:  CREATE TABLE will create partition "orders_1_prt_p1_3_2_prt_sp2" for table "orders_1_prt_p1_3"
NOTICE:  CREATE TABLE will create partition "orders_1_prt_p1_3_2_prt_sp2_3_prt_1" for table "orders_1_prt_p1_3_2_prt_sp2"
NOTICE:  CREATE TABLE will create partition "orders_1_prt_p1_3_2_prt_sp2_3_prt_2" for table "orders_1_prt_p1_3_2_prt_sp2"
NOTICE:  CREATE TABLE will create partition "orders_1_prt_p1_3_2_prt_sp2_3_prt_3" for table "orders_1_prt_p1_3_2_prt_sp2"
NOTICE:  CREATE TABLE will create partition "orders_1_prt_p1_3_2_prt_sp2_3_prt_4" for table "orders_1_prt_p1_3_2_prt_sp2"
NOTICE:  CREATE TABLE will create partition "orders_1_prt_p1_4" for table "orders"
NOTICE:  CREATE TABLE will create partition "orders_1_prt_p1_4_2_prt_sp1" for table "orders_1_prt_p1_4"
NOTICE:  CREATE TABLE will create partition "orders_1_prt_p1_4_2_prt_sp1_3_prt_1" for table "orders_1_prt_p1_4_2_prt_sp1"
NOTICE:  CREATE TABLE will create partition "orders_1_prt_p1_4_2_prt_sp1_3_prt_2" for table "orders_1_prt_p1_4_2_prt_sp1"
NOTICE:  CREATE TABLE will create partition "orders_1_prt_p1_4_2_prt_sp1_3_prt_3" for table "orders_1_prt_p1_4_2_prt_sp1"
NOTICE:  CREATE TABLE will create partition "orders_1_prt_p1_4_2_prt_sp1_3_prt_4" for table "orders_1_prt_p1_4_2_prt_sp1"
NOTICE:  CREATE TABLE will create partition "orders_1_prt_p1_4_2_prt_sp2" for table "orders_1_prt_p1_4"
NOTICE:  CREATE TABLE will create partition "orders_1_prt_p1_4_2_prt_sp2_3_prt_1" for table "orders_1_prt_p1_4_2_prt_sp2"
NOTICE:  CREATE TABLE will create partition "orders_1_prt_p1_4_2_prt_sp2_3_prt_2" for table "orders_1_prt_p1_4_2_prt_sp2"
NOTICE:  CREATE TABLE will create partition "orders_1_prt_p1_4_2_prt_sp2_3_prt_3" for table "orders_1_prt_p1_4_2_prt_sp2"
NOTICE:  CREATE TABLE will create partition "orders_1_prt_p1_4_2_prt_sp2_3_prt_4" for table "orders_1_prt_p1_4_2_prt_sp2"
NOTICE:  CREATE TABLE will create partition "orders_1_prt_p1_5" for table "orders"
NOTICE:  CREATE TABLE will create partition "orders_1_prt_p1_5_2_prt_sp1" for table "orders_1_prt_p1_5"
NOTICE:  CREATE TABLE will create partition "orders_1_prt_p1_5_2_prt_sp1_3_prt_1" for table "orders_1_prt_p1_5_2_prt_sp1"
NOTICE:  CREATE TABLE will create partition "orders_1_prt_p1_5_2_prt_sp1_3_prt_2" for table "orders_1_prt_p1_5_2_prt_sp1"
NOTICE:  CREATE TABLE will create partition "orders_1_prt_p1_5_2_prt_sp1_3_prt_3" for table "orders_1_prt_p1_5_2_prt_sp1"
NOTICE:  CREATE TABLE will create partition "orders_1_prt_p1_5_2_prt_sp1_3_prt_4" for table "orders_1_prt_p1_5_2_prt_sp1"
NOTICE:  CREATE TABLE will create partition "orders_1_prt_p1_5_2_prt_sp2" for table "orders_1_prt_p1_5"
NOTICE:  CREATE TABLE will create partition "orders_1_prt_p1_5_2_prt_sp2_3_prt_1" for table "orders_1_prt_p1_5_2_prt_sp2"
NOTICE:  CREATE TABLE will create partition "orders_1_prt_p1_5_2_prt_sp2_3_prt_2" for table "orders_1_prt_p1_5_2_prt_sp2"
NOTICE:  CREATE TABLE will create partition "orders_1_prt_p1_5_2_prt_sp2_3_prt_3" for table "orders_1_prt_p1_5_2_prt_sp2"
NOTICE:  CREATE TABLE will create partition "orders_1_prt_p1_5_2_prt_sp2_3_prt_4" for table "orders_1_prt_p1_5_2_prt_sp2"
-- grammar bug: MPP-3361
create table i2 (i int) partition by range(i) (start(-2::int) end(20));
NOTICE:  Table doesn't have 'DISTRIBUTED BY' clause -- Using column named 'i' as the Greenplum Database data distribution key for this table.
HINT:  The 'DISTRIBUTED BY' clause determines the distribution of data. Make sure column(s) chosen are the optimal data distribution key to minimize skew.
NOTICE:  CREATE TABLE will create partition "i2_1_prt_1" for table "i2"
drop table i2;
create table i2 (i int) partition by range(i) (start((-2)::int) end(20));
NOTICE:  Table doesn't have 'DISTRIBUTED BY' clause -- Using column named 'i' as the Greenplum Database data distribution key for this table.
HINT:  The 'DISTRIBUTED BY' clause determines the distribution of data. Make sure column(s) chosen are the optimal data distribution key to minimize skew.
NOTICE:  CREATE TABLE will create partition "i2_1_prt_1" for table "i2"
drop table i2;
create table i2 (i int) partition by range(i) (start(cast ((-2)::bigint as int))
end(20));
NOTICE:  Table doesn't have 'DISTRIBUTED BY' clause -- Using column named 'i' as the Greenplum Database data distribution key for this table.
HINT:  The 'DISTRIBUTED BY' clause determines the distribution of data. Make sure column(s) chosen are the optimal data distribution key to minimize skew.
NOTICE:  CREATE TABLE will create partition "i2_1_prt_1" for table "i2"
drop table i2;
CREATE TABLE partsupp (
    ps_partkey integer,
    ps_suppkey integer,
    ps_availqty integer,
    ps_supplycost numeric,
    ps_comment character varying(199)
) PARTITION BY RANGE(ps_supplycost)
          (
          PARTITION newpart START ((-10000)::numeric) EXCLUSIVE END (1::numeric)
,
          PARTITION p1 START (1::numeric) END (1001::numeric)
          );
NOTICE:  Table doesn't have 'DISTRIBUTED BY' clause -- Using column named 'ps_partkey' as the Greenplum Database data distribution key for this table.
HINT:  The 'DISTRIBUTED BY' clause determines the distribution of data. Make sure column(s) chosen are the optimal data distribution key to minimize skew.
NOTICE:  CREATE TABLE will create partition "partsupp_1_prt_newpart" for table "partsupp"
NOTICE:  CREATE TABLE will create partition "partsupp_1_prt_p1" for table "partsupp"
drop table partsupp;
-- Deletion tests
CREATE TABLE tmp_nation_region (n_regionkey integer);
drop table if exists tmp_nation;
NOTICE:  table "tmp_nation" does not exist, skipping
CREATE TABLE tmp_nation (N_NATIONKEY INTEGER, N_NAME CHAR(25), N_REGIONKEY INTEGER, N_COMMENT VARCHAR(152))  
partition by range (n_nationkey) 
 (
partition p1 start('0')  WITH (appendonly=true,checksum=true,blocksize=1998848,compresslevel=4),  
partition p2 start('11') end('15') inclusive WITH (checksum=false,appendonly=true,blocksize=655360,compresslevel=4),
partition p3 start('15') exclusive end('19'), partition p4 start('19')  WITH (compresslevel=8,appendonly=true,checksum=false,blocksize=884736), 
partition p5 start('20')
);
NOTICE:  Table doesn't have 'DISTRIBUTED BY' clause -- Using column named 'n_nationkey' as the Greenplum Database data distribution key for this table.
HINT:  The 'DISTRIBUTED BY' clause determines the distribution of data. Make sure column(s) chosen are the optimal data distribution key to minimize skew.
NOTICE:  CREATE TABLE will create partition "tmp_nation_1_prt_p1" for table "tmp_nation"
NOTICE:  CREATE TABLE will create partition "tmp_nation_1_prt_p2" for table "tmp_nation"
NOTICE:  CREATE TABLE will create partition "tmp_nation_1_prt_p3" for table "tmp_nation"
NOTICE:  CREATE TABLE will create partition "tmp_nation_1_prt_p4" for table "tmp_nation"
NOTICE:  CREATE TABLE will create partition "tmp_nation_1_prt_p5" for table "tmp_nation"
delete from tmp_nation where n_regionkey in (select n_regionkey from tmp_nation_region) and n_nationkey between 1 and 5;
drop table tmp_nation;
-- SPLIT tests
-- basic sanity tests. All should pass.
create table k (i int) partition by range(i) (start(1) end(10) every(2), 
default partition mydef);
NOTICE:  Table doesn't have 'DISTRIBUTED BY' clause -- Using column named 'i' as the Greenplum Database data distribution key for this table.
HINT:  The 'DISTRIBUTED BY' clause determines the distribution of data. Make sure column(s) chosen are the optimal data distribution key to minimize skew.
NOTICE:  CREATE TABLE will create partition "k_1_prt_mydef" for table "k"
NOTICE:  CREATE TABLE will create partition "k_1_prt_2" for table "k"
NOTICE:  CREATE TABLE will create partition "k_1_prt_3" for table "k"
NOTICE:  CREATE TABLE will create partition "k_1_prt_4" for table "k"
NOTICE:  CREATE TABLE will create partition "k_1_prt_5" for table "k"
NOTICE:  CREATE TABLE will create partition "k_1_prt_6" for table "k"
insert into k select i from generate_series(1, 100) i;
alter table k split partition mydef at (20) into (partition mydef, 
partition foo);
ERROR:  AT clause cannot be used when splitting a default RANGE partition
drop table k;
create table j (i int) partition by list(i) (partition a values(1, 2, 3, 4),
partition b values(5, 6, 7, 8));
NOTICE:  Table doesn't have 'DISTRIBUTED BY' clause -- Using column named 'i' as the Greenplum Database data distribution key for this table.
HINT:  The 'DISTRIBUTED BY' clause determines the distribution of data. Make sure column(s) chosen are the optimal data distribution key to minimize skew.
NOTICE:  CREATE TABLE will create partition "j_1_prt_a" for table "j"
NOTICE:  CREATE TABLE will create partition "j_1_prt_b" for table "j"
insert into j select i from generate_series(1, 8) i;
alter table j split partition for(1) at (2, 3) into (partition fa, partition
fb);
NOTICE:  exchanged partition "a" of relation "j" with relation "pg_temp_4022167"
NOTICE:  dropped partition "a" for relation "j"
NOTICE:  CREATE TABLE will create partition "j_1_prt_fa" for table "j"
NOTICE:  CREATE TABLE will create partition "j_1_prt_fb" for table "j"
select * from j_1_prt_fa;
 i 
---
 1
 4
(2 rows)

select * from j_1_prt_fb;
 i 
---
 3
 2
(2 rows)

alter table j split partition for(5) at (6);
NOTICE:  exchanged partition "b" of relation "j" with relation "pg_temp_4022167"
NOTICE:  dropped partition "b" for relation "j"
NOTICE:  CREATE TABLE will create partition "j_1_prt_r1937461509" for table "j"
NOTICE:  CREATE TABLE will create partition "j_1_prt_r90281515" for table "j"
select * from j;
 i 
---
 1
 3
 5
 7
 4
 2
 8
 6
(8 rows)

-- should fail
alter table j split partition for (1) at (100);
ERROR:  AT clause parameter is not a member of the target partition specification
drop table j;
create table k (i int) partition by range(i) (start(1) end(10) every(2), 
default partition mydef);
NOTICE:  Table doesn't have 'DISTRIBUTED BY' clause -- Using column named 'i' as the Greenplum Database data distribution key for this table.
HINT:  The 'DISTRIBUTED BY' clause determines the distribution of data. Make sure column(s) chosen are the optimal data distribution key to minimize skew.
NOTICE:  CREATE TABLE will create partition "k_1_prt_mydef" for table "k"
NOTICE:  CREATE TABLE will create partition "k_1_prt_2" for table "k"
NOTICE:  CREATE TABLE will create partition "k_1_prt_3" for table "k"
NOTICE:  CREATE TABLE will create partition "k_1_prt_4" for table "k"
NOTICE:  CREATE TABLE will create partition "k_1_prt_5" for table "k"
NOTICE:  CREATE TABLE will create partition "k_1_prt_6" for table "k"
-- should fail
alter table k split default partition start(30) end (300) into (partition mydef, partition mydef);
ERROR:  both INTO partitions already exist
alter table k split partition for(3) at (20);
ERROR:  AT clause parameter is not a member of the target partition specification
drop table k;
-- should work
create table k (i int) partition by range(i) (start(1) end(10) every(2), 
default partition mydef);
NOTICE:  Table doesn't have 'DISTRIBUTED BY' clause -- Using column named 'i' as the Greenplum Database data distribution key for this table.
HINT:  The 'DISTRIBUTED BY' clause determines the distribution of data. Make sure column(s) chosen are the optimal data distribution key to minimize skew.
NOTICE:  CREATE TABLE will create partition "k_1_prt_mydef" for table "k"
NOTICE:  CREATE TABLE will create partition "k_1_prt_2" for table "k"
NOTICE:  CREATE TABLE will create partition "k_1_prt_3" for table "k"
NOTICE:  CREATE TABLE will create partition "k_1_prt_4" for table "k"
NOTICE:  CREATE TABLE will create partition "k_1_prt_5" for table "k"
NOTICE:  CREATE TABLE will create partition "k_1_prt_6" for table "k"
insert into k select i from generate_series(1, 30) i;
alter table k split default partition start(15) end(20) into
(partition mydef, partition foo);
NOTICE:  exchanged partition "mydef" of relation "k" with relation "pg_temp_4022885"
NOTICE:  dropped partition "mydef" for relation "k"
NOTICE:  CREATE TABLE will create partition "k_1_prt_foo" for table "k"
NOTICE:  CREATE TABLE will create partition "k_1_prt_mydef" for table "k"
select * from k_1_prt_foo;
 i  
----
 16
 18
 15
 17
 19
(5 rows)

alter table k split default partition start(22) exclusive end(25) inclusive
into (partition bar, partition mydef);
NOTICE:  exchanged partition "mydef" of relation "k" with relation "pg_temp_4022885"
NOTICE:  dropped partition "mydef" for relation "k"
NOTICE:  CREATE TABLE will create partition "k_1_prt_bar" for table "k"
NOTICE:  CREATE TABLE will create partition "k_1_prt_mydef" for table "k"
select * from k_1_prt_bar;
 i  
----
 23
 25
 24
(3 rows)

alter table k split partition bar at (23) into (partition baz, partition foz);
NOTICE:  exchanged partition "bar" of relation "k" with relation "pg_temp_4022885"
NOTICE:  dropped partition "bar" for relation "k"
NOTICE:  CREATE TABLE will create partition "k_1_prt_baz" for table "k"
NOTICE:  CREATE TABLE will create partition "k_1_prt_foz" for table "k"
select partitiontablename,partitionposition,partitionrangestart,
       partitionrangeend from pg_partitions where tablename = 'k'
	   order by partitionposition;
 partitiontablename | partitionposition | partitionrangestart | partitionrangeend 
--------------------+-------------------+---------------------+-------------------
 k_1_prt_mydef      |                 0 |                     | 
 k_1_prt_2          |                 1 | 1                   | 3
 k_1_prt_3          |                 2 | 3                   | 5
 k_1_prt_4          |                 3 | 5                   | 7
 k_1_prt_5          |                 4 | 7                   | 9
 k_1_prt_6          |                 5 | 9                   | 10
 k_1_prt_foo        |                 6 | 15                  | 20
 k_1_prt_baz        |                 7 | 22                  | 23
 k_1_prt_foz        |                 8 | 23                  | 25
(9 rows)

drop table k;
-- Add CO partition and split, reported in MPP-17761
create table k (i int) with (appendonly = true, orientation = column) distributed by (i) partition by range(i) (start(1) end(10) every(5));
alter table k add partition co start(11) end (17) with (appendonly = true, orientation = column);
alter table k split partition co at (14) into (partition co1, partition co2);
NOTICE:  dropped partition "co" for relation "k"
drop table k;
create table k (a int, b int) with (appendonly = true) distributed by (a) partition by list(b)
(
	partition a values (1, 2, 3, 4) with (appendonly = true, orientation = column),
	partition b values (5, 6, 7 ,8) with (appendonly = true, orientation = column)
);
alter table k split partition for(2) at(2) into (partition one, partition two);
NOTICE:  dropped partition "a" for relation "k"
drop table k;
-- Test errors for default handling
create table k (i int) partition by range(i) (start(1) end(2), 
default partition mydef);
NOTICE:  Table doesn't have 'DISTRIBUTED BY' clause -- Using column named 'i' as the Greenplum Database data distribution key for this table.
HINT:  The 'DISTRIBUTED BY' clause determines the distribution of data. Make sure column(s) chosen are the optimal data distribution key to minimize skew.
NOTICE:  CREATE TABLE will create partition "k_1_prt_mydef" for table "k"
NOTICE:  CREATE TABLE will create partition "k_1_prt_2" for table "k"
alter table k split partition mydef at (25) into (partition foo, partition
mydef);
ERROR:  AT clause cannot be used when splitting a default RANGE partition
drop table k;
create table k (i int) partition by list(i) (values(1), values(2),
default partition mydef);
NOTICE:  Table doesn't have 'DISTRIBUTED BY' clause -- Using column named 'i' as the Greenplum Database data distribution key for this table.
HINT:  The 'DISTRIBUTED BY' clause determines the distribution of data. Make sure column(s) chosen are the optimal data distribution key to minimize skew.
NOTICE:  CREATE TABLE will create partition "k_1_prt_1" for table "k"
NOTICE:  CREATE TABLE will create partition "k_1_prt_2" for table "k"
NOTICE:  CREATE TABLE will create partition "k_1_prt_mydef" for table "k"
alter table k split default partition start(10) end(20);
ERROR:  cannot SPLIT DEFAULT PARTITION with LIST
HINT:  Use SPLIT with the AT clause instead.
drop table k;
-- Check that we support int2
CREATE TABLE myINT2_TBL(q1 int2)
 partition by range (q1)
 (start (1) end (3) every (1));
NOTICE:  Table doesn't have 'DISTRIBUTED BY' clause -- Using column named 'q1' as the Greenplum Database data distribution key for this table.
HINT:  The 'DISTRIBUTED BY' clause determines the distribution of data. Make sure column(s) chosen are the optimal data distribution key to minimize skew.
NOTICE:  CREATE TABLE will create partition "myint2_tbl_1_prt_1" for table "myint2_tbl"
NOTICE:  CREATE TABLE will create partition "myint2_tbl_1_prt_2" for table "myint2_tbl"
insert into myint2_tbl values(1), (2);
drop table myint2_tbl;
-- check that we don't allow updates of tuples such that they would move
-- between partitions
create table v (i int, j int) partition by range(j) (start(1) end(5)
 every(2));
NOTICE:  Table doesn't have 'DISTRIBUTED BY' clause -- Using column named 'i' as the Greenplum Database data distribution key for this table.
HINT:  The 'DISTRIBUTED BY' clause determines the distribution of data. Make sure column(s) chosen are the optimal data distribution key to minimize skew.
NOTICE:  CREATE TABLE will create partition "v_1_prt_1" for table "v"
NOTICE:  CREATE TABLE will create partition "v_1_prt_2" for table "v"
insert into v values(1, 1) ;
-- should work
update v set j = 2;
-- should fail
update v set j = 3;
ERROR:  moving tuple from partition "v_1_prt_1" to partition "v_1_prt_2" not supported  (seg0 slarimac:40000 pid=97875)
drop table v;
-- try SREH on a partitioned table.
create table ao_p (i int) with (appendonly = true)
 partition by range(i)
 (start(1) end(5) every(1));
NOTICE:  Table doesn't have 'DISTRIBUTED BY' clause -- Using column named 'i' as the Greenplum Database data distribution key for this table.
HINT:  The 'DISTRIBUTED BY' clause determines the distribution of data. Make sure column(s) chosen are the optimal data distribution key to minimize skew.
NOTICE:  CREATE TABLE will create partition "ao_p_1_prt_1" for table "ao_p"
NOTICE:  CREATE TABLE will create partition "ao_p_1_prt_2" for table "ao_p"
NOTICE:  CREATE TABLE will create partition "ao_p_1_prt_3" for table "ao_p"
NOTICE:  CREATE TABLE will create partition "ao_p_1_prt_4" for table "ao_p"
copy ao_p from stdin log errors segment reject limit 100;
NOTICE:  found 2 data formatting errors (2 or more input rows), rejected related input data
select * from ao_p;
 i 
---
 2
 3
(2 rows)

drop table ao_p;
-- MPP-3591: make sure we get inclusive/exclusive right with every().
create table k (i int) partition by range(i)
(start(0) exclusive end(100) inclusive every(25));
NOTICE:  Table doesn't have 'DISTRIBUTED BY' clause -- Using column named 'i' as the Greenplum Database data distribution key for this table.
HINT:  The 'DISTRIBUTED BY' clause determines the distribution of data. Make sure column(s) chosen are the optimal data distribution key to minimize skew.
NOTICE:  CREATE TABLE will create partition "k_1_prt_1" for table "k"
NOTICE:  CREATE TABLE will create partition "k_1_prt_2" for table "k"
NOTICE:  CREATE TABLE will create partition "k_1_prt_3" for table "k"
NOTICE:  CREATE TABLE will create partition "k_1_prt_4" for table "k"
select partitiontablename, partitionboundary from pg_partitions
where tablename = 'k' order by 1;
 partitiontablename |             partitionboundary             
--------------------+-------------------------------------------
 k_1_prt_1          | START (0) EXCLUSIVE END (25) EVERY (25)
 k_1_prt_2          | START (25) END (50) EVERY (25)
 k_1_prt_3          | START (50) END (75) EVERY (25)
 k_1_prt_4          | START (75) END (100) INCLUSIVE EVERY (25)
(4 rows)

insert into k select i from generate_series(1, 100) i;
drop table k;
-- ADD and SPLIT must get inherit permissions of the partition they're
-- modifying
create role part_role;
NOTICE:  resource queue required -- using default resource queue "pg_default"
create table a (a int, b int, c int) partition by range(a) subpartition by
range(b) subpartition template (subpartition h start(1) end(10)) 
subpartition by range(c)
subpartition template(subpartition i start(1) end(10)) 
(partition g start(1) end(2));
NOTICE:  Table doesn't have 'DISTRIBUTED BY' clause -- Using column named 'a' as the Greenplum Database data distribution key for this table.
HINT:  The 'DISTRIBUTED BY' clause determines the distribution of data. Make sure column(s) chosen are the optimal data distribution key to minimize skew.
NOTICE:  CREATE TABLE will create partition "a_1_prt_g" for table "a"
NOTICE:  CREATE TABLE will create partition "a_1_prt_g_2_prt_h" for table "a_1_prt_g"
NOTICE:  CREATE TABLE will create partition "a_1_prt_g_2_prt_h_3_prt_i" for table "a_1_prt_g_2_prt_h"
revoke all on a from public;
NOTICE:  no privileges could be revoked
grant insert on a to part_role;
-- revoke it from one existing partition, to make sure we don't screw up
-- existing permissions
revoke all on a_1_prt_g_2_prt_h_3_prt_i from part_role;
alter table a add partition b start(40) end(50);
NOTICE:  CREATE TABLE will create partition "a_1_prt_b" for table "a"
NOTICE:  CREATE TABLE will create partition "a_1_prt_b_2_prt_h" for table "a_1_prt_b"
NOTICE:  CREATE TABLE will create partition "a_1_prt_b_2_prt_h_3_prt_i" for table "a_1_prt_b_2_prt_h"
set session authorization part_role;
select has_table_privilege('part_role', 'a'::regclass,'insert');
 has_table_privilege 
---------------------
 t
(1 row)

select has_table_privilege('part_role', 'a_1_prt_b_2_prt_h'::regclass,'insert');
 has_table_privilege 
---------------------
 t
(1 row)

select has_table_privilege('part_role', 'a_1_prt_b_2_prt_h_3_prt_i'::regclass,'insert');
 has_table_privilege 
---------------------
 t
(1 row)

select has_table_privilege('part_role', 'a_1_prt_g_2_prt_h_3_prt_i'::regclass,
'insert');
 has_table_privilege 
---------------------
 f
(1 row)

insert into a values(45, 5, 5);
-- didn't grant select
select has_table_privilege('part_role', 'a'::regclass,'select');
 has_table_privilege 
---------------------
 f
(1 row)

select has_table_privilege('part_role', 'a_1_prt_b_2_prt_h'::regclass,'select');
 has_table_privilege 
---------------------
 f
(1 row)

select has_table_privilege('part_role', 'a_1_prt_b_2_prt_h_3_prt_i'::regclass,'select');
 has_table_privilege 
---------------------
 f
(1 row)

\c -
drop table a;
create table a (i date) partition by range(i) 
(partition f start(date '2005-01-01') end (date '2009-01-01')
	every(interval '2 years'));
NOTICE:  Table doesn't have 'DISTRIBUTED BY' clause -- Using column named 'i' as the Greenplum Database data distribution key for this table.
HINT:  The 'DISTRIBUTED BY' clause determines the distribution of data. Make sure column(s) chosen are the optimal data distribution key to minimize skew.
NOTICE:  CREATE TABLE will create partition "a_1_prt_f_1" for table "a"
NOTICE:  CREATE TABLE will create partition "a_1_prt_f_2" for table "a"
revoke all on a from public;
NOTICE:  no privileges could be revoked
grant insert on a to part_role;
alter table a split partition for(rank(1)) at (date '2006-01-01')
  into (partition f, partition g);
NOTICE:  exchanged partition "f_1" of relation "a" with relation "pg_temp_4025077"
NOTICE:  dropped partition "f_1" for relation "a"
NOTICE:  CREATE TABLE will create partition "a_1_prt_f" for table "a"
NOTICE:  CREATE TABLE will create partition "a_1_prt_g" for table "a"
alter table a add default partition mydef;
NOTICE:  CREATE TABLE will create partition "a_1_prt_mydef" for table "a"
alter table a split default partition start(date '2010-01-01') end(date
'2011-01-01') into(partition mydef, partition other);
NOTICE:  exchanged partition "mydef" of relation "a" with relation "pg_temp_4025077"
NOTICE:  dropped partition "mydef" for relation "a"
NOTICE:  CREATE TABLE will create partition "a_1_prt_other" for table "a"
NOTICE:  CREATE TABLE will create partition "a_1_prt_mydef" for table "a"
set session authorization part_role;
select has_table_privilege('part_role', 'a'::regclass,'insert');
 has_table_privilege 
---------------------
 t
(1 row)

select has_table_privilege('part_role', 'a_1_prt_f'::regclass,'insert');
 has_table_privilege 
---------------------
 t
(1 row)

select has_table_privilege('part_role', 'a_1_prt_mydef'::regclass,'insert');
 has_table_privilege 
---------------------
 t
(1 row)

select has_table_privilege('part_role', 'a_1_prt_other'::regclass,'insert');
 has_table_privilege 
---------------------
 t
(1 row)

insert into a values('2005-05-05');
insert into a values('2006-05-05');
insert into a values('2010-10-10');
\c -
drop table a;
drop role part_role;
-- Check that when we split a default, the INTO clause must named the default
create table k (i date) partition by range(i) (start('2008-01-01')
end('2009-01-01') every(interval '1 month'), default partition default_part);
NOTICE:  Table doesn't have 'DISTRIBUTED BY' clause -- Using column named 'i' as the Greenplum Database data distribution key for this table.
HINT:  The 'DISTRIBUTED BY' clause determines the distribution of data. Make sure column(s) chosen are the optimal data distribution key to minimize skew.
NOTICE:  CREATE TABLE will create partition "k_1_prt_default_part" for table "k"
NOTICE:  CREATE TABLE will create partition "k_1_prt_2" for table "k"
NOTICE:  CREATE TABLE will create partition "k_1_prt_3" for table "k"
NOTICE:  CREATE TABLE will create partition "k_1_prt_4" for table "k"
NOTICE:  CREATE TABLE will create partition "k_1_prt_5" for table "k"
NOTICE:  CREATE TABLE will create partition "k_1_prt_6" for table "k"
NOTICE:  CREATE TABLE will create partition "k_1_prt_7" for table "k"
NOTICE:  CREATE TABLE will create partition "k_1_prt_8" for table "k"
NOTICE:  CREATE TABLE will create partition "k_1_prt_9" for table "k"
NOTICE:  CREATE TABLE will create partition "k_1_prt_10" for table "k"
NOTICE:  CREATE TABLE will create partition "k_1_prt_11" for table "k"
NOTICE:  CREATE TABLE will create partition "k_1_prt_12" for table "k"
NOTICE:  CREATE TABLE will create partition "k_1_prt_13" for table "k"
alter table k split default partition start ('2009-01-01') end ('2009-02-01')
into (partition aa, partition nodate);
ERROR:  default partition name missing from INTO clause
alter table k split default partition start ('2009-01-01') end ('2009-02-01')
into (partition aa, partition default_part);
NOTICE:  exchanged partition "default_part" of relation "k" with relation "pg_temp_4025549"
NOTICE:  dropped partition "default_part" for relation "k"
NOTICE:  CREATE TABLE will create partition "k_1_prt_aa" for table "k"
NOTICE:  CREATE TABLE will create partition "k_1_prt_default_part" for table "k"
-- check that it works without INTO
alter table k split default partition start ('2009-02-01') end ('2009-03-01');
NOTICE:  exchanged partition "default_part" of relation "k" with relation "pg_temp_4025549"
NOTICE:  dropped partition "default_part" for relation "k"
NOTICE:  CREATE TABLE will create partition "k_1_prt_r900425354" for table "k"
NOTICE:  CREATE TABLE will create partition "k_1_prt_default_part" for table "k"
drop table k;
-- List too
create table k (i int) partition by list(i) (partition a values(1, 2),
partition b values(3, 4), default partition mydef);
NOTICE:  Table doesn't have 'DISTRIBUTED BY' clause -- Using column named 'i' as the Greenplum Database data distribution key for this table.
HINT:  The 'DISTRIBUTED BY' clause determines the distribution of data. Make sure column(s) chosen are the optimal data distribution key to minimize skew.
NOTICE:  CREATE TABLE will create partition "k_1_prt_a" for table "k"
NOTICE:  CREATE TABLE will create partition "k_1_prt_b" for table "k"
NOTICE:  CREATE TABLE will create partition "k_1_prt_mydef" for table "k"
alter table k split partition mydef at (5) into (partition foo, partition bar);
ERROR:  default partition name missing from INTO clause
alter table k split partition mydef at (5) into (partition foo, partition mydef);
NOTICE:  exchanged partition "mydef" of relation "k" with relation "pg_temp_4026409"
NOTICE:  dropped partition "mydef" for relation "k"
NOTICE:  CREATE TABLE will create partition "k_1_prt_foo" for table "k"
NOTICE:  CREATE TABLE will create partition "k_1_prt_mydef" for table "k"
alter table k split partition mydef at (10);
NOTICE:  exchanged partition "mydef" of relation "k" with relation "pg_temp_4026409"
NOTICE:  dropped partition "mydef" for relation "k"
NOTICE:  CREATE TABLE will create partition "k_1_prt_r1752840607" for table "k"
NOTICE:  CREATE TABLE will create partition "k_1_prt_mydef" for table "k"
drop table k;
-- For LIST, make sure that we reject AT() clauses which match all parameters
create table j (i int) partition by list(i) (partition a values(1, 2, 3, 4),
 partition b values(5, 6, 7, 8));
NOTICE:  Table doesn't have 'DISTRIBUTED BY' clause -- Using column named 'i' as the Greenplum Database data distribution key for this table.
HINT:  The 'DISTRIBUTED BY' clause determines the distribution of data. Make sure column(s) chosen are the optimal data distribution key to minimize skew.
NOTICE:  CREATE TABLE will create partition "j_1_prt_a" for table "j"
NOTICE:  CREATE TABLE will create partition "j_1_prt_b" for table "j"
alter table j split partition for(1) at (1,2) into (partition fa, partition fb);
NOTICE:  exchanged partition "a" of relation "j" with relation "pg_temp_4026879"
NOTICE:  dropped partition "a" for relation "j"
NOTICE:  CREATE TABLE will create partition "j_1_prt_fa" for table "j"
NOTICE:  CREATE TABLE will create partition "j_1_prt_fb" for table "j"
alter table j split partition for(1) at (1,2) 
into (partition f1a, partition f1b); -- This has partition rules that overlaps
ERROR:  AT clause cannot contain all values in partition "fb"
drop table j;
-- Check that we can split LIST partitions that have a default partition
create table j (i int) partition by list(i) (partition a values(1, 2, 3, 4),
partition b values(5, 6, 7, 8), default partition default_part);
NOTICE:  Table doesn't have 'DISTRIBUTED BY' clause -- Using column named 'i' as the Greenplum Database data distribution key for this table.
HINT:  The 'DISTRIBUTED BY' clause determines the distribution of data. Make sure column(s) chosen are the optimal data distribution key to minimize skew.
NOTICE:  CREATE TABLE will create partition "j_1_prt_a" for table "j"
NOTICE:  CREATE TABLE will create partition "j_1_prt_b" for table "j"
NOTICE:  CREATE TABLE will create partition "j_1_prt_default_part" for table "j"
alter table j split partition for(1) at (1,2) into (partition f1a, partition
f1b);
NOTICE:  exchanged partition "a" of relation "j" with relation "pg_temp_4027155"
NOTICE:  dropped partition "a" for relation "j"
NOTICE:  CREATE TABLE will create partition "j_1_prt_f1a" for table "j"
NOTICE:  CREATE TABLE will create partition "j_1_prt_f1b" for table "j"
drop table j;
-- Make sure range can too
create table j (i int) partition by range(i) (partition a start(1) end(10),
default partition default_part);
NOTICE:  Table doesn't have 'DISTRIBUTED BY' clause -- Using column named 'i' as the Greenplum Database data distribution key for this table.
HINT:  The 'DISTRIBUTED BY' clause determines the distribution of data. Make sure column(s) chosen are the optimal data distribution key to minimize skew.
NOTICE:  CREATE TABLE will create partition "j_1_prt_default_part" for table "j"
NOTICE:  CREATE TABLE will create partition "j_1_prt_a" for table "j"
alter table j split partition for(1) at (5) into (partition f1a, partition f1b);
NOTICE:  exchanged partition "a" of relation "j" with relation "pg_temp_4027458"
NOTICE:  dropped partition "a" for relation "j"
NOTICE:  CREATE TABLE will create partition "j_1_prt_f1a" for table "j"
NOTICE:  CREATE TABLE will create partition "j_1_prt_f1b" for table "j"
drop table j;
-- MPP-3667 ADD PARTITION overlaps
create table mpp3621 (aa date, bb date) partition by range (bb)
(partition foo start('2008-01-01'));
NOTICE:  Table doesn't have 'DISTRIBUTED BY' clause -- Using column named 'aa' as the Greenplum Database data distribution key for this table.
HINT:  The 'DISTRIBUTED BY' clause determines the distribution of data. Make sure column(s) chosen are the optimal data distribution key to minimize skew.
NOTICE:  CREATE TABLE will create partition "mpp3621_1_prt_foo" for table "mpp3621"
-- these are ok
alter table mpp3621 add partition a1 start ('2007-01-01') end ('2007-02-01');
NOTICE:  CREATE TABLE will create partition "mpp3621_1_prt_a1" for table "mpp3621"
alter table mpp3621 add partition a2 start ('2007-02-01') end ('2007-03-01');
NOTICE:  CREATE TABLE will create partition "mpp3621_1_prt_a2" for table "mpp3621"
alter table mpp3621 add partition a3 start ('2007-03-01') end ('2007-04-01');
NOTICE:  CREATE TABLE will create partition "mpp3621_1_prt_a3" for table "mpp3621"
alter table mpp3621 add partition a4 start ('2007-09-01') end ('2007-10-01');
NOTICE:  CREATE TABLE will create partition "mpp3621_1_prt_a4" for table "mpp3621"
alter table mpp3621 add partition a5 start ('2007-08-01') end ('2007-09-01');
NOTICE:  CREATE TABLE will create partition "mpp3621_1_prt_a5" for table "mpp3621"
alter table mpp3621 add partition a6 start ('2007-04-01') end ('2007-05-01');
NOTICE:  CREATE TABLE will create partition "mpp3621_1_prt_a6" for table "mpp3621"
alter table mpp3621 add partition a7 start ('2007-05-01') end ('2007-06-01');
NOTICE:  CREATE TABLE will create partition "mpp3621_1_prt_a7" for table "mpp3621"
 -- was error due to startSearchpoint != endSearchpoint
alter table mpp3621 add partition a8 start ('2007-07-01') end ('2007-08-01');
NOTICE:  CREATE TABLE will create partition "mpp3621_1_prt_a8" for table "mpp3621"
-- ok
alter table mpp3621 add partition a9 start ('2007-06-01') end ('2007-07-01');
NOTICE:  CREATE TABLE will create partition "mpp3621_1_prt_a9" for table "mpp3621"
drop table mpp3621;
-- Check for MPP-3679 and MPP-3692
create table list_test (a text, b text) partition by list (a) (
  partition foo values ('foo'),
  partition bar values ('bar'),
  default partition baz);
NOTICE:  Table doesn't have 'DISTRIBUTED BY' clause -- Using column named 'a' as the Greenplum Database data distribution key for this table.
HINT:  The 'DISTRIBUTED BY' clause determines the distribution of data. Make sure column(s) chosen are the optimal data distribution key to minimize skew.
NOTICE:  CREATE TABLE will create partition "list_test_1_prt_foo" for table "list_test"
NOTICE:  CREATE TABLE will create partition "list_test_1_prt_bar" for table "list_test"
NOTICE:  CREATE TABLE will create partition "list_test_1_prt_baz" for table "list_test"
insert into list_test values ('foo', 'blah');
insert into list_test values ('bar', 'blah');
insert into list_test values ('baz', 'blah');
alter table list_test split default partition at ('baz')
  into (partition bing, default partition);
NOTICE:  exchanged partition "baz" of relation "list_test" with relation "pg_temp_4028238"
NOTICE:  dropped partition "baz" for relation "list_test"
NOTICE:  CREATE TABLE will create partition "list_test_1_prt_bing" for table "list_test"
NOTICE:  CREATE TABLE will create partition "list_test_1_prt_baz" for table "list_test"
drop table list_test;
-- MPP-3816: cannot drop column  which is the subject of partition config
create table list_test(a int, b int, c int) distributed by (a)
  partition by list(b) 
  subpartition by list(c) subpartition template(subpartition c values(2))
  (partition b values(1));
NOTICE:  CREATE TABLE will create partition "list_test_1_prt_b" for table "list_test"
NOTICE:  CREATE TABLE will create partition "list_test_1_prt_b_2_prt_c" for table "list_test_1_prt_b"
-- should fail
alter table list_test drop column b;
ERROR:  cannot drop partitioning column "b"
alter table list_test drop column c;
ERROR:  cannot drop partitioning column "c"
drop table list_test;
-- MPP-3678: allow exchange and split on tables with subpartitioning
CREATE TABLE rank_exc (
id int,
rank int,
year int,
gender char(1),
count int ) 
DISTRIBUTED BY (id)
PARTITION BY LIST (gender)
SUBPARTITION BY RANGE (year)
SUBPARTITION TEMPLATE (
SUBPARTITION year1 START (2001),
SUBPARTITION year2 START (2002),
SUBPARTITION year3 START (2003),
SUBPARTITION year4 START (2004),
SUBPARTITION year5 START (2005),
SUBPARTITION year6 START (2006) END (2007) )
(PARTITION girls VALUES ('F'),
PARTITION boys VALUES ('M')
);
NOTICE:  CREATE TABLE will create partition "rank_exc_1_prt_girls" for table "rank_exc"
NOTICE:  CREATE TABLE will create partition "rank_exc_1_prt_girls_2_prt_year1" for table "rank_exc_1_prt_girls"
NOTICE:  CREATE TABLE will create partition "rank_exc_1_prt_girls_2_prt_year2" for table "rank_exc_1_prt_girls"
NOTICE:  CREATE TABLE will create partition "rank_exc_1_prt_girls_2_prt_year3" for table "rank_exc_1_prt_girls"
NOTICE:  CREATE TABLE will create partition "rank_exc_1_prt_girls_2_prt_year4" for table "rank_exc_1_prt_girls"
NOTICE:  CREATE TABLE will create partition "rank_exc_1_prt_girls_2_prt_year5" for table "rank_exc_1_prt_girls"
NOTICE:  CREATE TABLE will create partition "rank_exc_1_prt_girls_2_prt_year6" for table "rank_exc_1_prt_girls"
NOTICE:  CREATE TABLE will create partition "rank_exc_1_prt_boys" for table "rank_exc"
NOTICE:  CREATE TABLE will create partition "rank_exc_1_prt_boys_2_prt_year1" for table "rank_exc_1_prt_boys"
NOTICE:  CREATE TABLE will create partition "rank_exc_1_prt_boys_2_prt_year2" for table "rank_exc_1_prt_boys"
NOTICE:  CREATE TABLE will create partition "rank_exc_1_prt_boys_2_prt_year3" for table "rank_exc_1_prt_boys"
NOTICE:  CREATE TABLE will create partition "rank_exc_1_prt_boys_2_prt_year4" for table "rank_exc_1_prt_boys"
NOTICE:  CREATE TABLE will create partition "rank_exc_1_prt_boys_2_prt_year5" for table "rank_exc_1_prt_boys"
NOTICE:  CREATE TABLE will create partition "rank_exc_1_prt_boys_2_prt_year6" for table "rank_exc_1_prt_boys"
alter table rank_exc alter partition girls add default partition gfuture;
NOTICE:  CREATE TABLE will create partition "rank_exc_1_prt_girls_2_prt_gfuture" for table "rank_exc_1_prt_girls"
alter table rank_exc alter partition boys add default partition bfuture;
NOTICE:  CREATE TABLE will create partition "rank_exc_1_prt_boys_2_prt_bfuture" for table "rank_exc_1_prt_boys"
insert into rank_exc values(1, 1, 2007, 'M', 1);
insert into rank_exc values(2, 2, 2008, 'M', 3);
select * from rank_exc;
 id | rank | year | gender | count 
----+------+------+--------+-------
  1 |    1 | 2007 | M      |     1
  2 |    2 | 2008 | M      |     3
(2 rows)

alter table rank_exc alter partition boys split default partition start ('2007')
end ('2008') into (partition bfuture, partition year7);
NOTICE:  exchanged partition "bfuture" of partition "boys" of relation "rank_exc" with relation "pg_temp_4028684"
NOTICE:  dropped partition "bfuture" for partition "boys" of relation "rank_exc"
NOTICE:  CREATE TABLE will create partition "rank_exc_1_prt_boys_2_prt_year7" for table "rank_exc_1_prt_boys"
NOTICE:  CREATE TABLE will create partition "rank_exc_1_prt_boys_2_prt_bfuture" for table "rank_exc_1_prt_boys"
select * from rank_exc_1_prt_boys_2_prt_bfuture;
 id | rank | year | gender | count 
----+------+------+--------+-------
  2 |    2 | 2008 | M      |     3
(1 row)

select * from rank_exc_1_prt_boys_2_prt_year7;
 id | rank | year | gender | count 
----+------+------+--------+-------
  1 |    1 | 2007 | M      |     1
(1 row)

select * from rank_exc;
 id | rank | year | gender | count 
----+------+------+--------+-------
  2 |    2 | 2008 | M      |     3
  1 |    1 | 2007 | M      |     1
(2 rows)

--exchange test
create table r (like rank_exc);
NOTICE:  table doesn't have 'DISTRIBUTED BY' clause, defaulting to distribution columns from LIKE table
insert into rank_exc values(3, 3, 2004, 'F', 100);
insert into r values(3, 3, 2004, 'F', 100000);
alter table rank_exc alter partition girls exchange partition year4 with table r;
NOTICE:  exchanged partition "year4" of partition "girls" of relation "rank_exc" with relation "r"
select * from rank_exc_1_prt_girls_2_prt_year4;
 id | rank | year | gender | count  
----+------+------+--------+--------
  3 |    3 | 2004 | F      | 100000
(1 row)

select * from r;
 id | rank | year | gender | count 
----+------+------+--------+-------
  3 |    3 | 2004 | F      |   100
(1 row)

alter table rank_exc alter partition girls exchange partition year4 with table r;
NOTICE:  exchanged partition "year4" of partition "girls" of relation "rank_exc" with relation "r"
select * from rank_exc_1_prt_girls_2_prt_year4;
 id | rank | year | gender | count 
----+------+------+--------+-------
  3 |    3 | 2004 | F      |   100
(1 row)

select * from r;
 id | rank | year | gender | count  
----+------+------+--------+--------
  3 |    3 | 2004 | F      | 100000
(1 row)

-- Split test
alter table rank_exc alter partition girls split default partition start('2008')
  end('2020') into (partition years, partition gfuture);
NOTICE:  exchanged partition "gfuture" of partition "girls" of relation "rank_exc" with relation "pg_temp_4028684"
NOTICE:  dropped partition "gfuture" for partition "girls" of relation "rank_exc"
NOTICE:  CREATE TABLE will create partition "rank_exc_1_prt_girls_2_prt_years" for table "rank_exc_1_prt_girls"
NOTICE:  CREATE TABLE will create partition "rank_exc_1_prt_girls_2_prt_gfuture" for table "rank_exc_1_prt_girls"
insert into rank_exc values(4, 4, 2009, 'F', 100);
drop table rank_exc;
drop table r;
-- MPP-4245: remove virtual subpartition templates when we drop the partitioned
-- table
create table bar_p (i int, j int) partition by range(i) subpartition by range(j)
subpartition template(start(1) end(10) every(1)) subpartition by range(i)
subpartition template(start(1) end(10) every(5)) (start(1) end(10));
NOTICE:  Table doesn't have 'DISTRIBUTED BY' clause -- Using column named 'i' as the Greenplum Database data distribution key for this table.
HINT:  The 'DISTRIBUTED BY' clause determines the distribution of data. Make sure column(s) chosen are the optimal data distribution key to minimize skew.
NOTICE:  CREATE TABLE will create partition "bar_p_1_prt_1" for table "bar_p"
NOTICE:  CREATE TABLE will create partition "bar_p_1_prt_1_2_prt_1" for table "bar_p_1_prt_1"
NOTICE:  CREATE TABLE will create partition "bar_p_1_prt_1_2_prt_1_3_prt_1" for table "bar_p_1_prt_1_2_prt_1"
NOTICE:  CREATE TABLE will create partition "bar_p_1_prt_1_2_prt_1_3_prt_2" for table "bar_p_1_prt_1_2_prt_1"
NOTICE:  CREATE TABLE will create partition "bar_p_1_prt_1_2_prt_2" for table "bar_p_1_prt_1"
NOTICE:  CREATE TABLE will create partition "bar_p_1_prt_1_2_prt_2_3_prt_1" for table "bar_p_1_prt_1_2_prt_2"
NOTICE:  CREATE TABLE will create partition "bar_p_1_prt_1_2_prt_2_3_prt_2" for table "bar_p_1_prt_1_2_prt_2"
NOTICE:  CREATE TABLE will create partition "bar_p_1_prt_1_2_prt_3" for table "bar_p_1_prt_1"
NOTICE:  CREATE TABLE will create partition "bar_p_1_prt_1_2_prt_3_3_prt_1" for table "bar_p_1_prt_1_2_prt_3"
NOTICE:  CREATE TABLE will create partition "bar_p_1_prt_1_2_prt_3_3_prt_2" for table "bar_p_1_prt_1_2_prt_3"
NOTICE:  CREATE TABLE will create partition "bar_p_1_prt_1_2_prt_4" for table "bar_p_1_prt_1"
NOTICE:  CREATE TABLE will create partition "bar_p_1_prt_1_2_prt_4_3_prt_1" for table "bar_p_1_prt_1_2_prt_4"
NOTICE:  CREATE TABLE will create partition "bar_p_1_prt_1_2_prt_4_3_prt_2" for table "bar_p_1_prt_1_2_prt_4"
NOTICE:  CREATE TABLE will create partition "bar_p_1_prt_1_2_prt_5" for table "bar_p_1_prt_1"
NOTICE:  CREATE TABLE will create partition "bar_p_1_prt_1_2_prt_5_3_prt_1" for table "bar_p_1_prt_1_2_prt_5"
NOTICE:  CREATE TABLE will create partition "bar_p_1_prt_1_2_prt_5_3_prt_2" for table "bar_p_1_prt_1_2_prt_5"
NOTICE:  CREATE TABLE will create partition "bar_p_1_prt_1_2_prt_6" for table "bar_p_1_prt_1"
NOTICE:  CREATE TABLE will create partition "bar_p_1_prt_1_2_prt_6_3_prt_1" for table "bar_p_1_prt_1_2_prt_6"
NOTICE:  CREATE TABLE will create partition "bar_p_1_prt_1_2_prt_6_3_prt_2" for table "bar_p_1_prt_1_2_prt_6"
NOTICE:  CREATE TABLE will create partition "bar_p_1_prt_1_2_prt_7" for table "bar_p_1_prt_1"
NOTICE:  CREATE TABLE will create partition "bar_p_1_prt_1_2_prt_7_3_prt_1" for table "bar_p_1_prt_1_2_prt_7"
NOTICE:  CREATE TABLE will create partition "bar_p_1_prt_1_2_prt_7_3_prt_2" for table "bar_p_1_prt_1_2_prt_7"
NOTICE:  CREATE TABLE will create partition "bar_p_1_prt_1_2_prt_8" for table "bar_p_1_prt_1"
NOTICE:  CREATE TABLE will create partition "bar_p_1_prt_1_2_prt_8_3_prt_1" for table "bar_p_1_prt_1_2_prt_8"
NOTICE:  CREATE TABLE will create partition "bar_p_1_prt_1_2_prt_8_3_prt_2" for table "bar_p_1_prt_1_2_prt_8"
NOTICE:  CREATE TABLE will create partition "bar_p_1_prt_1_2_prt_9" for table "bar_p_1_prt_1"
NOTICE:  CREATE TABLE will create partition "bar_p_1_prt_1_2_prt_9_3_prt_1" for table "bar_p_1_prt_1_2_prt_9"
NOTICE:  CREATE TABLE will create partition "bar_p_1_prt_1_2_prt_9_3_prt_2" for table "bar_p_1_prt_1_2_prt_9"
alter table bar_p alter partition for ('5') alter partition for ('5')
  drop partition for ('5');
insert into bar_p values(1, 1);
insert into bar_p values(5, 5);
ERROR:  no partition for partitioning key  (seg0 slarimac:40000 pid=97899)
drop table bar_p;
-- Drop should not leave anything lingering for bar_p or its
-- subpartitions in pg_partition* catalog tables.
select count(*) = 0 as passed from pg_partition_rule pr
 left outer join pg_partition p on pr.paroid = p.oid
 where p.parrelid not in (select oid from pg_class);
 passed 
--------
 t
(1 row)

-- MPP-4172
-- should fail
create table ggg (a char(1), b int)
distributed by (b)
partition by range(a)
(
partition aa start ('2006') end ('2009'), partition bb start ('2007') end
('2008')
);
ERROR:  value too long for type character(1)
-- MPP-4892 SET SUBPARTITION TEMPLATE
create table mpp4892 (a char, b int, d char)
partition by range (b)
subpartition by list (d)
subpartition template (
 subpartition sp1 values ('a'),
 subpartition sp2 values ('b'))
(
start (1) end (10) every (1)
);
NOTICE:  Table doesn't have 'DISTRIBUTED BY' clause -- Using column named 'a' as the Greenplum Database data distribution key for this table.
HINT:  The 'DISTRIBUTED BY' clause determines the distribution of data. Make sure column(s) chosen are the optimal data distribution key to minimize skew.
NOTICE:  CREATE TABLE will create partition "mpp4892_1_prt_1" for table "mpp4892"
NOTICE:  CREATE TABLE will create partition "mpp4892_1_prt_1_2_prt_sp1" for table "mpp4892_1_prt_1"
NOTICE:  CREATE TABLE will create partition "mpp4892_1_prt_1_2_prt_sp2" for table "mpp4892_1_prt_1"
NOTICE:  CREATE TABLE will create partition "mpp4892_1_prt_2" for table "mpp4892"
NOTICE:  CREATE TABLE will create partition "mpp4892_1_prt_2_2_prt_sp1" for table "mpp4892_1_prt_2"
NOTICE:  CREATE TABLE will create partition "mpp4892_1_prt_2_2_prt_sp2" for table "mpp4892_1_prt_2"
NOTICE:  CREATE TABLE will create partition "mpp4892_1_prt_3" for table "mpp4892"
NOTICE:  CREATE TABLE will create partition "mpp4892_1_prt_3_2_prt_sp1" for table "mpp4892_1_prt_3"
NOTICE:  CREATE TABLE will create partition "mpp4892_1_prt_3_2_prt_sp2" for table "mpp4892_1_prt_3"
NOTICE:  CREATE TABLE will create partition "mpp4892_1_prt_4" for table "mpp4892"
NOTICE:  CREATE TABLE will create partition "mpp4892_1_prt_4_2_prt_sp1" for table "mpp4892_1_prt_4"
NOTICE:  CREATE TABLE will create partition "mpp4892_1_prt_4_2_prt_sp2" for table "mpp4892_1_prt_4"
NOTICE:  CREATE TABLE will create partition "mpp4892_1_prt_5" for table "mpp4892"
NOTICE:  CREATE TABLE will create partition "mpp4892_1_prt_5_2_prt_sp1" for table "mpp4892_1_prt_5"
NOTICE:  CREATE TABLE will create partition "mpp4892_1_prt_5_2_prt_sp2" for table "mpp4892_1_prt_5"
NOTICE:  CREATE TABLE will create partition "mpp4892_1_prt_6" for table "mpp4892"
NOTICE:  CREATE TABLE will create partition "mpp4892_1_prt_6_2_prt_sp1" for table "mpp4892_1_prt_6"
NOTICE:  CREATE TABLE will create partition "mpp4892_1_prt_6_2_prt_sp2" for table "mpp4892_1_prt_6"
NOTICE:  CREATE TABLE will create partition "mpp4892_1_prt_7" for table "mpp4892"
NOTICE:  CREATE TABLE will create partition "mpp4892_1_prt_7_2_prt_sp1" for table "mpp4892_1_prt_7"
NOTICE:  CREATE TABLE will create partition "mpp4892_1_prt_7_2_prt_sp2" for table "mpp4892_1_prt_7"
NOTICE:  CREATE TABLE will create partition "mpp4892_1_prt_8" for table "mpp4892"
NOTICE:  CREATE TABLE will create partition "mpp4892_1_prt_8_2_prt_sp1" for table "mpp4892_1_prt_8"
NOTICE:  CREATE TABLE will create partition "mpp4892_1_prt_8_2_prt_sp2" for table "mpp4892_1_prt_8"
NOTICE:  CREATE TABLE will create partition "mpp4892_1_prt_9" for table "mpp4892"
NOTICE:  CREATE TABLE will create partition "mpp4892_1_prt_9_2_prt_sp1" for table "mpp4892_1_prt_9"
NOTICE:  CREATE TABLE will create partition "mpp4892_1_prt_9_2_prt_sp2" for table "mpp4892_1_prt_9"
-- works
alter table mpp4892 add partition p1 end (11);
NOTICE:  CREATE TABLE will create partition "mpp4892_1_prt_p1" for table "mpp4892"
NOTICE:  CREATE TABLE will create partition "mpp4892_1_prt_p1_2_prt_sp1" for table "mpp4892_1_prt_p1"
NOTICE:  CREATE TABLE will create partition "mpp4892_1_prt_p1_2_prt_sp2" for table "mpp4892_1_prt_p1"
-- complain about existing template
alter table mpp4892 add partition p3 end (13) (subpartition sp3 values ('c'));
ERROR:  subpartition configuration conflicts with subpartition template
-- remove template
alter table mpp4892 set	subpartition template ();
NOTICE:  dropped level 1 subpartition template specification for relation "mpp4892"
-- should work (because the template is gone)
alter table mpp4892 add partition p3 end (13) (subpartition sp3 values ('c'));
NOTICE:  CREATE TABLE will create partition "mpp4892_1_prt_p3" for table "mpp4892"
NOTICE:  CREATE TABLE will create partition "mpp4892_1_prt_p3_2_prt_sp3" for table "mpp4892_1_prt_p3"
-- complain because the template is already gone
alter table mpp4892 set	subpartition template ();
ERROR:  relation "mpp4892" does not have a level 1 subpartition template specification
-- should work
alter table mpp4892 set subpartition template (subpartition sp3 values ('c'));
NOTICE:  adding level 1 subpartition template specification for relation "mpp4892"
-- should work
alter table mpp4892 add partition p4 end (15);
NOTICE:  CREATE TABLE will create partition "mpp4892_1_prt_p4" for table "mpp4892"
NOTICE:  CREATE TABLE will create partition "mpp4892_1_prt_p4_2_prt_sp3" for table "mpp4892_1_prt_p4"
drop table mpp4892;
-- make sure we do not allow overlapping range intervals
-- should fail
-- unordered elems
create table ttt (t int) partition by range(t) (
partition a start (1) end(10) inclusive,
partition c start(11) end(14),
partition b start(5) end(15)
);
NOTICE:  Table doesn't have 'DISTRIBUTED BY' clause -- Using column named 't' as the Greenplum Database data distribution key for this table.
HINT:  The 'DISTRIBUTED BY' clause determines the distribution of data. Make sure column(s) chosen are the optimal data distribution key to minimize skew.
ERROR:  starting value of partition "b" overlaps previous range
LINE 4: partition b start(5) end(15)
                    ^
-- should fail, this time it's ordered
create table ttt (t int) partition by range(t) (
partition a start (1) end(10) inclusive,
partition b start(5) end(15),
partition c start(11) end(14)
);
NOTICE:  Table doesn't have 'DISTRIBUTED BY' clause -- Using column named 't' as the Greenplum Database data distribution key for this table.
HINT:  The 'DISTRIBUTED BY' clause determines the distribution of data. Make sure column(s) chosen are the optimal data distribution key to minimize skew.
ERROR:  starting value of partition "b" overlaps previous range
LINE 3: partition b start(5) end(15),
                    ^
-- should fail
create table ttt (t date) partition by range(t) (
partition a start ('2005-01-01') end('2006-01-01') inclusive,
partition b start('2005-05-01') end('2005-06-11'),
partition c start('2006-01-01') exclusive end('2006-01-10')
);
NOTICE:  Table doesn't have 'DISTRIBUTED BY' clause -- Using column named 't' as the Greenplum Database data distribution key for this table.
HINT:  The 'DISTRIBUTED BY' clause determines the distribution of data. Make sure column(s) chosen are the optimal data distribution key to minimize skew.
ERROR:  starting value of partition "b" overlaps previous range
LINE 3: partition b start('2005-05-01') end('2005-06-11'),
                    ^
-- should fail
create table ttt (t char) partition by range(t) (
partition a start('a') end('f'),
partition b start('e') end('g')
);
NOTICE:  Table doesn't have 'DISTRIBUTED BY' clause -- Using column named 't' as the Greenplum Database data distribution key for this table.
HINT:  The 'DISTRIBUTED BY' clause determines the distribution of data. Make sure column(s) chosen are the optimal data distribution key to minimize skew.
ERROR:  starting value of partition "b" overlaps previous range
LINE 3: partition b start('e') end('g')
                    ^
-- MPP-5159 MPP-26829
-- Should fail -- missing partition spec and subpartition template follows the
-- partition declaration.
CREATE TABLE list_sales (trans_id int, date date, amount
decimal(9,2), region text)
DISTRIBUTED BY (trans_id)
PARTITION BY LIST (region)
SUBPARTITION TEMPLATE
( SUBPARTITION usa VALUES ('usa'),
  SUBPARTITION asia VALUES ('asia'),
  SUBPARTITION europe VALUES ('europe')
);
ERROR:  syntax error at or near "TEMPLATE"
LINE 5: SUBPARTITION TEMPLATE
                     ^
-- MPP-5185 MPP-26829
-- Should work
CREATE TABLE rank_settemp (id int, rank int, year date, gender
char(1)) DISTRIBUTED BY (id, gender, year)
partition by list (gender)
subpartition by range (year)
subpartition template (
start (date '2001-01-01'),
start (date '2002-01-01'),
start (date '2003-01-01'),
start (date '2004-01-01'),
start (date '2005-01-01')
)
(
partition boys values ('M'),
partition girls values ('F')
);
NOTICE:  CREATE TABLE will create partition "rank_settemp_1_prt_boys" for table "rank_settemp"
NOTICE:  CREATE TABLE will create partition "rank_settemp_1_prt_boys_2_prt_1" for table "rank_settemp_1_prt_boys"
NOTICE:  CREATE TABLE will create partition "rank_settemp_1_prt_boys_2_prt_2" for table "rank_settemp_1_prt_boys"
NOTICE:  CREATE TABLE will create partition "rank_settemp_1_prt_boys_2_prt_3" for table "rank_settemp_1_prt_boys"
NOTICE:  CREATE TABLE will create partition "rank_settemp_1_prt_boys_2_prt_4" for table "rank_settemp_1_prt_boys"
NOTICE:  CREATE TABLE will create partition "rank_settemp_1_prt_boys_2_prt_5" for table "rank_settemp_1_prt_boys"
NOTICE:  CREATE TABLE will create partition "rank_settemp_1_prt_girls" for table "rank_settemp"
NOTICE:  CREATE TABLE will create partition "rank_settemp_1_prt_girls_2_prt_1" for table "rank_settemp_1_prt_girls"
NOTICE:  CREATE TABLE will create partition "rank_settemp_1_prt_girls_2_prt_2" for table "rank_settemp_1_prt_girls"
NOTICE:  CREATE TABLE will create partition "rank_settemp_1_prt_girls_2_prt_3" for table "rank_settemp_1_prt_girls"
NOTICE:  CREATE TABLE will create partition "rank_settemp_1_prt_girls_2_prt_4" for table "rank_settemp_1_prt_girls"
NOTICE:  CREATE TABLE will create partition "rank_settemp_1_prt_girls_2_prt_5" for table "rank_settemp_1_prt_girls"
alter table rank_settemp set subpartition template ();
NOTICE:  dropped level 1 subpartition template specification for relation "rank_settemp"
-- nothing there
select * from pg_partition_templates where tablename like 'rank_settemp%';
 schemaname | tablename | partitionname | partitiontype | partitionlevel | partitionrank | partitionposition | partitionlistvalues | partitionrangestart | partitionstartinclusive | partitionrangeend | partitionendinclusive | partitioneveryclause | partitionisdefault | partitionboundary 
------------+-----------+---------------+---------------+----------------+---------------+-------------------+---------------------+---------------------+-------------------------+-------------------+-----------------------+----------------------+--------------------+-------------------
(0 rows)

alter table rank_settemp set subpartition template (default subpartition def2);
NOTICE:  adding level 1 subpartition template specification for relation "rank_settemp"
NOTICE:  CREATE TABLE will create partition "rank_settemp_1_prt_subpartition_template" for table "rank_settemp"
NOTICE:  CREATE TABLE will create partition "rank_settemp_1_prt_subpartition_template_2_prt_def2" for table "rank_settemp_1_prt_subpartition_template"
-- def2 is there
select * from pg_partition_templates where tablename like 'rank_settemp%';
 schemaname |  tablename   | partitionname | partitiontype | partitionlevel | partitionrank | partitionposition | partitionlistvalues | partitionrangestart | partitionstartinclusive | partitionrangeend | partitionendinclusive | partitioneveryclause | partitionisdefault |     partitionboundary      
------------+--------------+---------------+---------------+----------------+---------------+-------------------+---------------------+---------------------+-------------------------+-------------------+-----------------------+----------------------+--------------------+----------------------------
 public     | rank_settemp | def2          | range         |              1 |             1 |                 1 |                     |                     | f                       |                   | f                     |                      | t                  | DEFAULT SUBPARTITION def2 
(1 row)

alter table rank_settemp set subpartition template (default subpartition def2);
NOTICE:  replacing level 1 subpartition template specification for relation "rank_settemp"
NOTICE:  CREATE TABLE will create partition "rank_settemp_1_prt_subpartition_template" for table "rank_settemp"
NOTICE:  CREATE TABLE will create partition "rank_settemp_1_prt_subpartition_template_2_prt_def2" for table "rank_settemp_1_prt_subpartition_template"
-- Should still be there
select * from pg_partition_templates where tablename like 'rank_settemp%';
 schemaname |  tablename   | partitionname | partitiontype | partitionlevel | partitionrank | partitionposition | partitionlistvalues | partitionrangestart | partitionstartinclusive | partitionrangeend | partitionendinclusive | partitioneveryclause | partitionisdefault |     partitionboundary      
------------+--------------+---------------+---------------+----------------+---------------+-------------------+---------------------+---------------------+-------------------------+-------------------+-----------------------+----------------------+--------------------+----------------------------
 public     | rank_settemp | def2          | range         |              1 |             1 |                 1 |                     |                     | f                       |                   | f                     |                      | t                  | DEFAULT SUBPARTITION def2 
(1 row)

alter table rank_settemp set subpartition template (start (date '2006-01-01') with (appendonly=true));
NOTICE:  replacing level 1 subpartition template specification for relation "rank_settemp"
NOTICE:  CREATE TABLE will create partition "rank_settemp_1_prt_subpartition_template" for table "rank_settemp"
NOTICE:  CREATE TABLE will create partition "rank_settemp_1_prt_subpartition_template_2_prt_1" for table "rank_settemp_1_prt_subpartition_template"
alter table rank_settemp add partition f1 values ('N');
NOTICE:  CREATE TABLE will create partition "rank_settemp_1_prt_f1" for table "rank_settemp"
NOTICE:  CREATE TABLE will create partition "rank_settemp_1_prt_f1_2_prt_1" for table "rank_settemp_1_prt_f1"
alter table rank_settemp set subpartition template (start (date '2007-01-01') with (appendonly=true, compresslevel=5));
NOTICE:  replacing level 1 subpartition template specification for relation "rank_settemp"
NOTICE:  CREATE TABLE will create partition "rank_settemp_1_prt_subpartition_template" for table "rank_settemp"
NOTICE:  CREATE TABLE will create partition "rank_settemp_1_prt_subpartition_template_2_prt_1" for table "rank_settemp_1_prt_subpartition_template"
alter table rank_settemp add partition f2 values ('C');
NOTICE:  CREATE TABLE will create partition "rank_settemp_1_prt_f2" for table "rank_settemp"
NOTICE:  CREATE TABLE will create partition "rank_settemp_1_prt_f2_2_prt_1" for table "rank_settemp_1_prt_f2"
select * from pg_partition_templates where tablename like 'rank_settemp%';
 schemaname |  tablename   | partitionname | partitiontype | partitionlevel | partitionrank | partitionposition | partitionlistvalues | partitionrangestart | partitionstartinclusive | partitionrangeend | partitionendinclusive | partitioneveryclause | partitionisdefault |                         partitionboundary                          
------------+--------------+---------------+---------------+----------------+---------------+-------------------+---------------------+---------------------+-------------------------+-------------------+-----------------------+----------------------+--------------------+--------------------------------------------------------------------
 public     | rank_settemp |               | range         |              1 |             1 |                 1 |                     | '01-01-2007'::date  | t                       |                   | f                     |                      | f                  | START ('01-01-2007'::date) WITH (appendonly=true, compresslevel=5)
(1 row)

drop table rank_settemp;
-- MPP-5397 and MPP-7002
-- should be able to add/split/exchange partition after dropped a col
create table mpp_5397 (a int, b int, c int, d int)
  distributed by (a) 
  partition by range (b)  
  (partition a1 start (0) end (5), 
   partition a2 end (10),  
   partition a3 end(15));
NOTICE:  CREATE TABLE will create partition "mpp_5397_1_prt_a1" for table "mpp_5397"
NOTICE:  CREATE TABLE will create partition "mpp_5397_1_prt_a2" for table "mpp_5397"
NOTICE:  CREATE TABLE will create partition "mpp_5397_1_prt_a3" for table "mpp_5397"
alter table mpp_5397 drop column c;
-- should work now
alter table mpp_5397 add partition z end (20);
NOTICE:  CREATE TABLE will create partition "mpp_5397_1_prt_z" for table "mpp_5397"
-- ensure splitting default partition also works
alter table mpp_5397 add default partition adefault;
alter table mpp_5397 drop column d;
alter table mpp_5397 split default partition start (21) inclusive end (25) inclusive;
NOTICE:  dropped partition "adefault" for relation "mpp_5397"
drop table mpp_5397;
-- MPP-4987 -- make sure we can't damage a partitioning configuration
-- MPP-8405: disallow OIDS on partitioned tables 
create table rank_damage (i int, j int) with oids
partition by range(j) (start(1) end(5) every(1));
NOTICE:  Table doesn't have 'DISTRIBUTED BY' clause -- Using column named 'i' as the Greenplum Database data distribution key for this table.
HINT:  The 'DISTRIBUTED BY' clause determines the distribution of data. Make sure column(s) chosen are the optimal data distribution key to minimize skew.
NOTICE:  CREATE TABLE will create partition "rank_damage_1_prt_1" for table "rank_damage"
NOTICE:  CREATE TABLE will create partition "rank_damage_1_prt_2" for table "rank_damage"
NOTICE:  CREATE TABLE will create partition "rank_damage_1_prt_3" for table "rank_damage"
NOTICE:  CREATE TABLE will create partition "rank_damage_1_prt_4" for table "rank_damage"
ERROR:  OIDS=TRUE is not allowed on partitioned tables
HINT:  Use OIDS=FALSE.
-- this works
create table rank_damage (i int, j int)
partition by range(j) (start(1) end(5) every(1));
NOTICE:  Table doesn't have 'DISTRIBUTED BY' clause -- Using column named 'i' as the Greenplum Database data distribution key for this table.
HINT:  The 'DISTRIBUTED BY' clause determines the distribution of data. Make sure column(s) chosen are the optimal data distribution key to minimize skew.
NOTICE:  CREATE TABLE will create partition "rank_damage_1_prt_1" for table "rank_damage"
NOTICE:  CREATE TABLE will create partition "rank_damage_1_prt_2" for table "rank_damage"
NOTICE:  CREATE TABLE will create partition "rank_damage_1_prt_3" for table "rank_damage"
NOTICE:  CREATE TABLE will create partition "rank_damage_1_prt_4" for table "rank_damage"
-- should all fail
alter table rank_damage_1_prt_1 no inherit rank_damage;
ERROR:  can't alter inheritance on "rank_damage_1_prt_1"; it is a partitioned table or part thereof
create table rank2_damage(like rank_damage);
NOTICE:  table doesn't have 'DISTRIBUTED BY' clause, defaulting to distribution columns from LIKE table
alter table rank_damage_1_prt_1 inherit rank2_damage;
ERROR:  can't alter inheritance on "rank_damage_1_prt_1"; it is a partitioned table or part thereof
alter table rank_damage_1_prt_1 alter column i type bigint;
ERROR:  can't alter a column datatype of "rank_damage_1_prt_1"; it is part of a partitioned table
HINT:  You may be able to perform the operation on the partitioned table as a whole.
alter table rank_damage_1_prt_1 set without oids;
ERROR:  can't alter the oid setting of "rank_damage_1_prt_1"; it is part of a partitioned table
HINT:  You may be able to perform the operation on the partitioned table as a whole.
alter table rank_damage_1_prt_1 drop constraint rank_damage_1_prt_1_check;
ERROR:  can't drop a constraint from "rank_damage_1_prt_1"; it is part of a partitioned table
HINT:  You may be able to perform the operation on the partitioned table as a whole.
alter table rank_damage add partition ppo end (22) with (oids = true);
NOTICE:  CREATE TABLE will create partition "rank_damage_1_prt_ppo" for table "rank_damage"
ERROR:  OIDS=TRUE is not allowed on partitioned tables
HINT:  Use OIDS=FALSE.
drop table rank_damage, rank2_damage;
-- MPP-5831, type cast in SPLIT
CREATE TABLE sg_cal_event_silvertail_hour (
caldt date NOT NULL,
calhr smallint NOT NULL,
ip character varying(128),
transactionid character varying(32),
transactiontime timestamp(2) without time zone
)
WITH (appendonly=true, compresslevel=5)
distributed by (ip) PARTITION BY RANGE(transactiontime)
(
PARTITION "P2009041607"
START ('2009-04-16 07:00:00'::timestamp without time zone)
END ('2009-04-16 08:00:00'::timestamp without time zone),
PARTITION "P2009041608"
START ('2009-04-16 08:00:00'::timestamp without time zone)
END ('2009-04-16 09:00:00'::timestamp without time zone),
DEFAULT PARTITION st_default
);
NOTICE:  CREATE TABLE will create partition "sg_cal_event_silvertail_hour_1_prt_st_default" for table "sg_cal_event_silvertail_hour"
NOTICE:  CREATE TABLE will create partition "sg_cal_event_silvertail_hour_1_prt_P2009041607" for table "sg_cal_event_silvertail_hour"
NOTICE:  CREATE TABLE will create partition "sg_cal_event_silvertail_hour_1_prt_P2009041608" for table "sg_cal_event_silvertail_hour"
ALTER TABLE SG_CAL_EVENT_SILVERTAIL_HOUR SPLIT DEFAULT PARTITION
START ('2009-04-29 07:00:00'::timestamp) INCLUSIVE END ('2009-04-29
08:00:00'::timestamp) EXCLUSIVE INTO ( PARTITION P2009042907 ,
PARTITION st_default );
NOTICE:  exchanged partition "st_default" of relation "sg_cal_event_silvertail_hour" with relation "pg_temp_4034830"
NOTICE:  dropped partition "st_default" for relation "sg_cal_event_silvertail_hour"
NOTICE:  CREATE TABLE will create partition "sg_cal_event_silvertail_hour_1_prt_p2009042907" for table "sg_cal_event_silvertail_hour"
NOTICE:  CREATE TABLE will create partition "sg_cal_event_silvertail_hour_1_prt_st_default" for table "sg_cal_event_silvertail_hour"
select pg_get_partition_def('sg_cal_event_silvertail_hour'::regclass, true);
                                                                                                pg_get_partition_def                                                                                                 
---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 PARTITION BY RANGE(transactiontime)                                                                                                                                                                                +
           (                                                                                                                                                                                                        +
           PARTITION "P2009041607" START ('Thu Apr 16 07:00:00 2009'::timestamp(2) without time zone) END ('Thu Apr 16 08:00:00 2009'::timestamp(2) without time zone) WITH (appendonly='true', compresslevel='5'), +
           PARTITION "P2009041608" START ('Thu Apr 16 08:00:00 2009'::timestamp(2) without time zone) END ('Thu Apr 16 09:00:00 2009'::timestamp(2) without time zone) WITH (appendonly='true', compresslevel='5'), +
           PARTITION p2009042907 START ('Wed Apr 29 07:00:00 2009'::timestamp(2) without time zone) END ('Wed Apr 29 08:00:00 2009'::timestamp(2) without time zone) WITH (appendonly='true', compresslevel='5'),   +
           DEFAULT PARTITION st_default  WITH (appendonly='true', compresslevel='5')                                                                                                                                +
           )
(1 row)

drop table sg_cal_event_silvertail_hour;
-- Make sure we inherit master's storage settings
create table foo_p (i int, j int, k text)
with (appendonly = true, compresslevel = 5)
partition by range(j) (start(1) end(10) every(1), default partition def);
NOTICE:  Table doesn't have 'DISTRIBUTED BY' clause -- Using column named 'i' as the Greenplum Database data distribution key for this table.
HINT:  The 'DISTRIBUTED BY' clause determines the distribution of data. Make sure column(s) chosen are the optimal data distribution key to minimize skew.
NOTICE:  CREATE TABLE will create partition "foo_p_1_prt_def" for table "foo_p"
NOTICE:  CREATE TABLE will create partition "foo_p_1_prt_2" for table "foo_p"
NOTICE:  CREATE TABLE will create partition "foo_p_1_prt_3" for table "foo_p"
NOTICE:  CREATE TABLE will create partition "foo_p_1_prt_4" for table "foo_p"
NOTICE:  CREATE TABLE will create partition "foo_p_1_prt_5" for table "foo_p"
NOTICE:  CREATE TABLE will create partition "foo_p_1_prt_6" for table "foo_p"
NOTICE:  CREATE TABLE will create partition "foo_p_1_prt_7" for table "foo_p"
NOTICE:  CREATE TABLE will create partition "foo_p_1_prt_8" for table "foo_p"
NOTICE:  CREATE TABLE will create partition "foo_p_1_prt_9" for table "foo_p"
NOTICE:  CREATE TABLE will create partition "foo_p_1_prt_10" for table "foo_p"
insert into foo_p select i, i+1, repeat('fooo', 9000) from generate_series(1, 100) i;
alter table foo_p split default partition start (10) end(20) 
into (partition p10_20, partition def);
NOTICE:  exchanged partition "def" of relation "foo_p" with relation "pg_temp_4035155"
NOTICE:  dropped partition "def" for relation "foo_p"
NOTICE:  CREATE TABLE will create partition "foo_p_1_prt_p10_20" for table "foo_p"
NOTICE:  CREATE TABLE will create partition "foo_p_1_prt_def" for table "foo_p"
select reloptions from pg_class where relname = 'foo_p_1_prt_p10_20';
            reloptions             
-----------------------------------
 {appendonly=true,compresslevel=5}
(1 row)

select count(distinct k) from foo_p;
 count 
-------
     1
(1 row)

drop table foo_p;
create table foo_p (i int, j int, k text)
partition by range(j) (start(1) end(10) every(1), default partition def
with(appendonly = true));
NOTICE:  Table doesn't have 'DISTRIBUTED BY' clause -- Using column named 'i' as the Greenplum Database data distribution key for this table.
HINT:  The 'DISTRIBUTED BY' clause determines the distribution of data. Make sure column(s) chosen are the optimal data distribution key to minimize skew.
NOTICE:  CREATE TABLE will create partition "foo_p_1_prt_def" for table "foo_p"
NOTICE:  CREATE TABLE will create partition "foo_p_1_prt_2" for table "foo_p"
NOTICE:  CREATE TABLE will create partition "foo_p_1_prt_3" for table "foo_p"
NOTICE:  CREATE TABLE will create partition "foo_p_1_prt_4" for table "foo_p"
NOTICE:  CREATE TABLE will create partition "foo_p_1_prt_5" for table "foo_p"
NOTICE:  CREATE TABLE will create partition "foo_p_1_prt_6" for table "foo_p"
NOTICE:  CREATE TABLE will create partition "foo_p_1_prt_7" for table "foo_p"
NOTICE:  CREATE TABLE will create partition "foo_p_1_prt_8" for table "foo_p"
NOTICE:  CREATE TABLE will create partition "foo_p_1_prt_9" for table "foo_p"
NOTICE:  CREATE TABLE will create partition "foo_p_1_prt_10" for table "foo_p"
insert into foo_p select i, i+1, repeat('fooo', 9000) from generate_series(1, 100) i;
alter table foo_p split default partition start (10) end(20) 
into (partition p10_20, partition def);
NOTICE:  exchanged partition "def" of relation "foo_p" with relation "pg_temp_4035809"
NOTICE:  dropped partition "def" for relation "foo_p"
NOTICE:  CREATE TABLE will create partition "foo_p_1_prt_p10_20" for table "foo_p"
NOTICE:  CREATE TABLE will create partition "foo_p_1_prt_def" for table "foo_p"
select reloptions from pg_class where relname = 'foo_p_1_prt_p10_20';
    reloptions     
-------------------
 {appendonly=true}
(1 row)

select reloptions from pg_class where relname = 'foo_p_1_prt_def';
    reloptions     
-------------------
 {appendonly=true}
(1 row)

select count(distinct k) from foo_p;
 count 
-------
     1
(1 row)

drop table foo_p;
-- MPP-5878 - display correct partition boundary 
create table mpp5878 (a int, b char, d char)
partition by list (b,d)
(
values (('a','b'),('c','d')),
values (('e','f'),('g','h'))
);
NOTICE:  Table doesn't have 'DISTRIBUTED BY' clause -- Using column named 'a' as the Greenplum Database data distribution key for this table.
HINT:  The 'DISTRIBUTED BY' clause determines the distribution of data. Make sure column(s) chosen are the optimal data distribution key to minimize skew.
NOTICE:  CREATE TABLE will create partition "mpp5878_1_prt_1" for table "mpp5878"
NOTICE:  CREATE TABLE will create partition "mpp5878_1_prt_2" for table "mpp5878"
create table mpp5878a (a int, b character(1), d character(1))
partition by list (b,d)
(
values (('a','b'),('c','d')),
values (('e','f'),('g','h'))
);
NOTICE:  Table doesn't have 'DISTRIBUTED BY' clause -- Using column named 'a' as the Greenplum Database data distribution key for this table.
HINT:  The 'DISTRIBUTED BY' clause determines the distribution of data. Make sure column(s) chosen are the optimal data distribution key to minimize skew.
NOTICE:  CREATE TABLE will create partition "mpp5878a_1_prt_1" for table "mpp5878a"
NOTICE:  CREATE TABLE will create partition "mpp5878a_1_prt_2" for table "mpp5878a"
select tablename, partitionlistvalues from pg_partitions where tablename like 'mpp5878%';
 tablename |                            partitionlistvalues                             
-----------+----------------------------------------------------------------------------
 mpp5878   | 'a'::character(1), 'b'::character(1), 'c'::character(1), 'd'::character(1)
 mpp5878   | 'e'::character(1), 'f'::character(1), 'g'::character(1), 'h'::character(1)
 mpp5878a  | 'a'::character(1), 'b'::character(1), 'c'::character(1), 'd'::character(1)
 mpp5878a  | 'e'::character(1), 'f'::character(1), 'g'::character(1), 'h'::character(1)
(4 rows)

select tablename, partitionboundary from pg_partitions where tablename like 'mpp5878%';
 tablename |        partitionboundary         
-----------+----------------------------------
 mpp5878   | VALUES( ('a', 'b'),  ('c', 'd'))
 mpp5878   | VALUES( ('e', 'f'),  ('g', 'h'))
 mpp5878a  | VALUES( ('a', 'b'),  ('c', 'd'))
 mpp5878a  | VALUES( ('e', 'f'),  ('g', 'h'))
(4 rows)

-- MPP-5941: work with many levels of templates
CREATE TABLE mpp5941 (a int, b date, c char, 
	   		 		 d char(4), e varchar(20), f timestamp)
partition by range (b)
subpartition by list (a) 
subpartition template ( 
subpartition l1 values (1,2,3,4,5), 
subpartition l2 values (6,7,8,9,10) )
subpartition by list (e) 
subpartition template ( 
subpartition ll1 values ('Engineering'), 
subpartition ll2 values ('QA') )
subpartition by list (c) 
subpartition template ( 
subpartition lll1 values ('M'), 
subpartition lll2 values ('F') )
(
  start (date '2007-01-01')
  end (date '2010-01-01') every (interval '1 year')
);
NOTICE:  Table doesn't have 'DISTRIBUTED BY' clause -- Using column named 'a' as the Greenplum Database data distribution key for this table.
HINT:  The 'DISTRIBUTED BY' clause determines the distribution of data. Make sure column(s) chosen are the optimal data distribution key to minimize skew.
NOTICE:  CREATE TABLE will create partition "mpp5941_1_prt_1" for table "mpp5941"
NOTICE:  CREATE TABLE will create partition "mpp5941_1_prt_1_2_prt_l1" for table "mpp5941_1_prt_1"
NOTICE:  CREATE TABLE will create partition "mpp5941_1_prt_1_2_prt_l1_3_prt_ll1" for table "mpp5941_1_prt_1_2_prt_l1"
NOTICE:  CREATE TABLE will create partition "mpp5941_1_prt_1_2_prt_l1_3_prt_ll2" for table "mpp5941_1_prt_1_2_prt_l1"
NOTICE:  CREATE TABLE will create partition "mpp5941_1_prt_1_2_prt_l1_3_prt_ll1_4_prt_lll1" for table "mpp5941_1_prt_1_2_prt_l1_3_prt_ll1"
NOTICE:  CREATE TABLE will create partition "mpp5941_1_prt_1_2_prt_l1_3_prt_ll1_4_prt_lll2" for table "mpp5941_1_prt_1_2_prt_l1_3_prt_ll1"
NOTICE:  CREATE TABLE will create partition "mpp5941_1_prt_1_2_prt_l1_3_prt_ll2_4_prt_lll1" for table "mpp5941_1_prt_1_2_prt_l1_3_prt_ll2"
NOTICE:  CREATE TABLE will create partition "mpp5941_1_prt_1_2_prt_l1_3_prt_ll2_4_prt_lll2" for table "mpp5941_1_prt_1_2_prt_l1_3_prt_ll2"
NOTICE:  CREATE TABLE will create partition "mpp5941_1_prt_1_2_prt_l2" for table "mpp5941_1_prt_1"
NOTICE:  CREATE TABLE will create partition "mpp5941_1_prt_1_2_prt_l2_3_prt_ll1" for table "mpp5941_1_prt_1_2_prt_l2"
NOTICE:  CREATE TABLE will create partition "mpp5941_1_prt_1_2_prt_l2_3_prt_ll2" for table "mpp5941_1_prt_1_2_prt_l2"
NOTICE:  CREATE TABLE will create partition "mpp5941_1_prt_1_2_prt_l2_3_prt_ll1_4_prt_lll1" for table "mpp5941_1_prt_1_2_prt_l2_3_prt_ll1"
NOTICE:  CREATE TABLE will create partition "mpp5941_1_prt_1_2_prt_l2_3_prt_ll1_4_prt_lll2" for table "mpp5941_1_prt_1_2_prt_l2_3_prt_ll1"
NOTICE:  CREATE TABLE will create partition "mpp5941_1_prt_1_2_prt_l2_3_prt_ll2_4_prt_lll1" for table "mpp5941_1_prt_1_2_prt_l2_3_prt_ll2"
NOTICE:  CREATE TABLE will create partition "mpp5941_1_prt_1_2_prt_l2_3_prt_ll2_4_prt_lll2" for table "mpp5941_1_prt_1_2_prt_l2_3_prt_ll2"
NOTICE:  CREATE TABLE will create partition "mpp5941_1_prt_2" for table "mpp5941"
NOTICE:  CREATE TABLE will create partition "mpp5941_1_prt_2_2_prt_l1" for table "mpp5941_1_prt_2"
NOTICE:  CREATE TABLE will create partition "mpp5941_1_prt_2_2_prt_l1_3_prt_ll1" for table "mpp5941_1_prt_2_2_prt_l1"
NOTICE:  CREATE TABLE will create partition "mpp5941_1_prt_2_2_prt_l1_3_prt_ll2" for table "mpp5941_1_prt_2_2_prt_l1"
NOTICE:  CREATE TABLE will create partition "mpp5941_1_prt_2_2_prt_l1_3_prt_ll1_4_prt_lll1" for table "mpp5941_1_prt_2_2_prt_l1_3_prt_ll1"
NOTICE:  CREATE TABLE will create partition "mpp5941_1_prt_2_2_prt_l1_3_prt_ll1_4_prt_lll2" for table "mpp5941_1_prt_2_2_prt_l1_3_prt_ll1"
NOTICE:  CREATE TABLE will create partition "mpp5941_1_prt_2_2_prt_l1_3_prt_ll2_4_prt_lll1" for table "mpp5941_1_prt_2_2_prt_l1_3_prt_ll2"
NOTICE:  CREATE TABLE will create partition "mpp5941_1_prt_2_2_prt_l1_3_prt_ll2_4_prt_lll2" for table "mpp5941_1_prt_2_2_prt_l1_3_prt_ll2"
NOTICE:  CREATE TABLE will create partition "mpp5941_1_prt_2_2_prt_l2" for table "mpp5941_1_prt_2"
NOTICE:  CREATE TABLE will create partition "mpp5941_1_prt_2_2_prt_l2_3_prt_ll1" for table "mpp5941_1_prt_2_2_prt_l2"
NOTICE:  CREATE TABLE will create partition "mpp5941_1_prt_2_2_prt_l2_3_prt_ll2" for table "mpp5941_1_prt_2_2_prt_l2"
NOTICE:  CREATE TABLE will create partition "mpp5941_1_prt_2_2_prt_l2_3_prt_ll1_4_prt_lll1" for table "mpp5941_1_prt_2_2_prt_l2_3_prt_ll1"
NOTICE:  CREATE TABLE will create partition "mpp5941_1_prt_2_2_prt_l2_3_prt_ll1_4_prt_lll2" for table "mpp5941_1_prt_2_2_prt_l2_3_prt_ll1"
NOTICE:  CREATE TABLE will create partition "mpp5941_1_prt_2_2_prt_l2_3_prt_ll2_4_prt_lll1" for table "mpp5941_1_prt_2_2_prt_l2_3_prt_ll2"
NOTICE:  CREATE TABLE will create partition "mpp5941_1_prt_2_2_prt_l2_3_prt_ll2_4_prt_lll2" for table "mpp5941_1_prt_2_2_prt_l2_3_prt_ll2"
NOTICE:  CREATE TABLE will create partition "mpp5941_1_prt_3" for table "mpp5941"
NOTICE:  CREATE TABLE will create partition "mpp5941_1_prt_3_2_prt_l1" for table "mpp5941_1_prt_3"
NOTICE:  CREATE TABLE will create partition "mpp5941_1_prt_3_2_prt_l1_3_prt_ll1" for table "mpp5941_1_prt_3_2_prt_l1"
NOTICE:  CREATE TABLE will create partition "mpp5941_1_prt_3_2_prt_l1_3_prt_ll2" for table "mpp5941_1_prt_3_2_prt_l1"
NOTICE:  CREATE TABLE will create partition "mpp5941_1_prt_3_2_prt_l1_3_prt_ll1_4_prt_lll1" for table "mpp5941_1_prt_3_2_prt_l1_3_prt_ll1"
NOTICE:  CREATE TABLE will create partition "mpp5941_1_prt_3_2_prt_l1_3_prt_ll1_4_prt_lll2" for table "mpp5941_1_prt_3_2_prt_l1_3_prt_ll1"
NOTICE:  CREATE TABLE will create partition "mpp5941_1_prt_3_2_prt_l1_3_prt_ll2_4_prt_lll1" for table "mpp5941_1_prt_3_2_prt_l1_3_prt_ll2"
NOTICE:  CREATE TABLE will create partition "mpp5941_1_prt_3_2_prt_l1_3_prt_ll2_4_prt_lll2" for table "mpp5941_1_prt_3_2_prt_l1_3_prt_ll2"
NOTICE:  CREATE TABLE will create partition "mpp5941_1_prt_3_2_prt_l2" for table "mpp5941_1_prt_3"
NOTICE:  CREATE TABLE will create partition "mpp5941_1_prt_3_2_prt_l2_3_prt_ll1" for table "mpp5941_1_prt_3_2_prt_l2"
NOTICE:  CREATE TABLE will create partition "mpp5941_1_prt_3_2_prt_l2_3_prt_ll2" for table "mpp5941_1_prt_3_2_prt_l2"
NOTICE:  CREATE TABLE will create partition "mpp5941_1_prt_3_2_prt_l2_3_prt_ll1_4_prt_lll1" for table "mpp5941_1_prt_3_2_prt_l2_3_prt_ll1"
NOTICE:  CREATE TABLE will create partition "mpp5941_1_prt_3_2_prt_l2_3_prt_ll1_4_prt_lll2" for table "mpp5941_1_prt_3_2_prt_l2_3_prt_ll1"
NOTICE:  CREATE TABLE will create partition "mpp5941_1_prt_3_2_prt_l2_3_prt_ll2_4_prt_lll1" for table "mpp5941_1_prt_3_2_prt_l2_3_prt_ll2"
NOTICE:  CREATE TABLE will create partition "mpp5941_1_prt_3_2_prt_l2_3_prt_ll2_4_prt_lll2" for table "mpp5941_1_prt_3_2_prt_l2_3_prt_ll2"
-- just truncate for fun to see that everything is there
alter table mpp5941 alter partition for ('2008-01-01') 
alter partition for (1) alter partition for ('QA')
truncate partition for ('M');
NOTICE:  truncated partition "lll1" for partition "ll2" of partition "l1" of partition for value ('2008-01-01') of relation "mpp5941"
alter table mpp5941 alter partition for ('2008-01-01') 
alter partition for (1) truncate partition for ('QA');
NOTICE:  truncated partition "ll2" for partition "l1" of partition for value ('2008-01-01') of relation "mpp5941" and its children
alter table mpp5941 alter partition for ('2008-01-01') 
truncate partition for (1);
NOTICE:  truncated partition "l1" for partition for value ('2008-01-01') of relation "mpp5941" and its children
alter table mpp5941 truncate partition for ('2008-01-01') ;
NOTICE:  truncated partition for value ('2008-01-01') for relation "mpp5941" and its children
truncate table mpp5941;
-- now look at the templates that we have
select tablename, partitionname, partitionlevel from pg_partition_templates 
where tablename = 'mpp5941';
 tablename | partitionname | partitionlevel 
-----------+---------------+----------------
 mpp5941   | l1            |              1
 mpp5941   | l2            |              1
 mpp5941   | ll1           |              2
 mpp5941   | ll2           |              2
 mpp5941   | lll1          |              3
 mpp5941   | lll2          |              3
(6 rows)

-- clear level 1
alter table mpp5941 set subpartition template ();
NOTICE:  dropped level 1 subpartition template specification for relation "mpp5941"
select tablename, partitionname, partitionlevel from pg_partition_templates 
where tablename = 'mpp5941';
 tablename | partitionname | partitionlevel 
-----------+---------------+----------------
 mpp5941   | ll1           |              2
 mpp5941   | ll2           |              2
 mpp5941   | lll1          |              3
 mpp5941   | lll2          |              3
(4 rows)

-- clear level 2
alter table mpp5941 alter partition for ('2008-01-01') 
set subpartition template ();
NOTICE:  dropped level 2 subpartition template specification for relation "mpp5941"
select tablename, partitionname, partitionlevel from pg_partition_templates 
where tablename = 'mpp5941';
 tablename | partitionname | partitionlevel 
-----------+---------------+----------------
 mpp5941   | lll1          |              3
 mpp5941   | lll2          |              3
(2 rows)

-- clear level 3
alter table mpp5941 alter partition for ('2008-01-01') 
alter partition for (1)
set subpartition template ();
NOTICE:  dropped level 3 subpartition template specification for relation "mpp5941"
select tablename, partitionname, partitionlevel from pg_partition_templates 
where tablename = 'mpp5941';
 tablename | partitionname | partitionlevel 
-----------+---------------+----------------
(0 rows)

-- no level 4 (error)
alter table mpp5941 alter partition for ('2008-01-01') 
alter partition for (1) alter partition for ('QA')
set subpartition template ();
ERROR:  relation "mpp5941" does not have a level 4 subpartition template specification
select tablename, partitionname, partitionlevel from pg_partition_templates 
where tablename = 'mpp5941';
 tablename | partitionname | partitionlevel 
-----------+---------------+----------------
(0 rows)

-- no level 5 (error)
alter table mpp5941 alter partition for ('2008-01-01') 
alter partition for (1) alter partition for ('QA')
alter partition for ('M')
set subpartition template ();
ERROR:  relation "mpp5941" does not have a level 5 subpartition template specification
select tablename, partitionname, partitionlevel from pg_partition_templates 
where tablename = 'mpp5941';
 tablename | partitionname | partitionlevel 
-----------+---------------+----------------
(0 rows)

-- set level 1 (error, because no templates for level 2, 3)
alter table mpp5941 set subpartition template (
subpartition l1 values (1,2,3,4,5), 
subpartition l2 values (6,7,8,9,10) );
NOTICE:  adding level 1 subpartition template specification for relation "mpp5941"
ERROR:  no partitions specified at depth 3
-- MPP-5992 - add deep templates correctly
-- Note: need to re-add the templates from deepest to shallowest,
-- because adding a template has a dependency on the existence of the
-- deeper template.
-- set level 3
alter table mpp5941 alter partition for ('2008-01-01') 
alter partition for (1)
set subpartition template (
subpartition lll1 values ('M'), 
subpartition lll2 values ('F') );
NOTICE:  adding level 3 subpartition template specification for relation "mpp5941"
select tablename, partitionname, partitionlevel from pg_partition_templates 
where tablename = 'mpp5941';
 tablename | partitionname | partitionlevel 
-----------+---------------+----------------
 mpp5941   | lll1          |              3
 mpp5941   | lll2          |              3
(2 rows)

-- set level 2
alter table mpp5941 alter partition for ('2008-01-01') 
set subpartition template (
subpartition ll1 values ('Engineering'), 
subpartition ll2 values ('QA') );
NOTICE:  adding level 2 subpartition template specification for relation "mpp5941"
select tablename, partitionname, partitionlevel from pg_partition_templates 
where tablename = 'mpp5941';
 tablename | partitionname | partitionlevel 
-----------+---------------+----------------
 mpp5941   | lll1          |              3
 mpp5941   | lll2          |              3
 mpp5941   | ll1           |              2
 mpp5941   | ll2           |              2
(4 rows)

-- set level 1
alter table mpp5941 set subpartition template (
subpartition l1 values (1,2,3,4,5), 
subpartition l2 values (6,7,8,9,10) );
NOTICE:  adding level 1 subpartition template specification for relation "mpp5941"
select tablename, partitionname, partitionlevel from pg_partition_templates 
where tablename = 'mpp5941';
 tablename | partitionname | partitionlevel 
-----------+---------------+----------------
 mpp5941   | lll1          |              3
 mpp5941   | lll2          |              3
 mpp5941   | ll1           |              2
 mpp5941   | ll2           |              2
 mpp5941   | l1            |              1
 mpp5941   | l2            |              1
(6 rows)

drop table mpp5941;
-- MPP-5984 - NULL is not allowed in RANGE partition
CREATE TABLE partsupp ( ps_partkey integer,
ps_suppkey integer, ps_availqty integer,
ps_supplycost numeric, ps_comment character varying(199) )
PARTITION BY RANGE(ps_partkey)
(
partition nnull start (NULL) end (300)
);
ERROR:  cannot use NULL with range partition specification
LINE 6: partition nnull start (NULL) end (300)
                        ^
CREATE TABLE partsupp ( ps_partkey integer,
ps_suppkey integer, ps_availqty integer,
ps_supplycost numeric, ps_comment character varying(199) )
PARTITION BY RANGE(ps_partkey)
(
partition nnull start (300) end (NULL)
);
NOTICE:  Table doesn't have 'DISTRIBUTED BY' clause -- Using column named 'ps_partkey' as the Greenplum Database data distribution key for this table.
HINT:  The 'DISTRIBUTED BY' clause determines the distribution of data. Make sure column(s) chosen are the optimal data distribution key to minimize skew.
ERROR:  cannot use NULL with range partition specification
LINE 6: partition nnull start (300) end (NULL)
                                    ^
CREATE TABLE partsupp ( ps_partkey integer,
ps_suppkey integer, ps_availqty integer,
ps_supplycost numeric, ps_comment character varying(199) )
PARTITION BY RANGE(ps_partkey)
(
partition nnull start (300) end (NULL::int)
);
NOTICE:  Table doesn't have 'DISTRIBUTED BY' clause -- Using column named 'ps_partkey' as the Greenplum Database data distribution key for this table.
HINT:  The 'DISTRIBUTED BY' clause determines the distribution of data. Make sure column(s) chosen are the optimal data distribution key to minimize skew.
ERROR:  cannot use NULL with range partition specification
LINE 6: partition nnull start (300) end (NULL::int)
                                    ^
CREATE TABLE partsupp ( ps_partkey integer,
ps_suppkey integer, ps_availqty integer,
ps_supplycost numeric, ps_comment character varying(199) )
PARTITION BY RANGE(ps_partkey)
(
partition p1 start(1) end(10),
partition p2 start(10) end(20),
default partition def
);
NOTICE:  Table doesn't have 'DISTRIBUTED BY' clause -- Using column named 'ps_partkey' as the Greenplum Database data distribution key for this table.
HINT:  The 'DISTRIBUTED BY' clause determines the distribution of data. Make sure column(s) chosen are the optimal data distribution key to minimize skew.
NOTICE:  CREATE TABLE will create partition "partsupp_1_prt_def" for table "partsupp"
NOTICE:  CREATE TABLE will create partition "partsupp_1_prt_p1" for table "partsupp"
NOTICE:  CREATE TABLE will create partition "partsupp_1_prt_p2" for table "partsupp"
alter table partsupp split partition p2 at (NULL);
ERROR:  AT clause parameter is not a member of the target partition specification
alter table partsupp split default partition start(null) end(200);
NOTICE:  exchanged partition "def" of relation "partsupp" with relation "pg_temp_4038708"
NOTICE:  dropped partition "def" for relation "partsupp"
ERROR:  cannot use NULL with range partition specification
drop table partsupp;
CREATE TABLE partsupp ( ps_partkey integer,
ps_suppkey integer, ps_availqty integer,
ps_supplycost numeric, ps_comment character varying(199) )
PARTITION BY RANGE(ps_partkey)
(
partition nnull start (300) end (400)
);
NOTICE:  Table doesn't have 'DISTRIBUTED BY' clause -- Using column named 'ps_partkey' as the Greenplum Database data distribution key for this table.
HINT:  The 'DISTRIBUTED BY' clause determines the distribution of data. Make sure column(s) chosen are the optimal data distribution key to minimize skew.
NOTICE:  CREATE TABLE will create partition "partsupp_1_prt_nnull" for table "partsupp"
alter table partsupp add partition foo start(500) end(NULL);
ERROR:  cannot use NULL with range partition specification
drop table partsupp;
-- Test for an old bug, where we used to crash on NULLs, because the code
-- to order the partitions by their start/end boundaries did not anticipate
-- NULLs. NULLs in boundaries are not accepted, but because we check for
-- them only after ordering the partitions, the sorting code needs to
-- handle them. (This test needs at least two partitions, so that there
-- is something to sort.)
create table partnulltest (
  col1 int,
  col2 numeric
)
distributed by (col1)
partition by range(col2)
(
  partition part2 start(1) end(10) ,
  partition part1 start (NULL)
);
ERROR:  cannot use NULL with range partition specification
LINE 9:   partition part1 start (NULL)
                          ^
--MPP-6240
CREATE TABLE supplier_hybrid_part(
                S_SUPPKEY INTEGER,
                S_NAME CHAR(25),
                S_ADDRESS VARCHAR(40),
                S_NATIONKEY INTEGER,                S_PHONE CHAR(15),
                S_ACCTBAL decimal,
                S_COMMENT VARCHAR(101)
                )
partition by range (s_suppkey) 
subpartition by list (s_nationkey) subpartition template (
    values('22','21','17'),
    values('6','11','1','7','16','2') WITH (checksum=false,appendonly=true,blocksize=1171456,         compresslevel=3),
    values('18','20'),
    values('9','23','13') WITH (checksum=true,appendonly=true,blocksize=1335296,compresslevel=7),
    values('0','3','12','15','14','8','4','24','19','10','5')
)               
(               
partition p1 start('1') end('10001') every(10000)
);
NOTICE:  Table doesn't have 'DISTRIBUTED BY' clause -- Using column named 's_suppkey' as the Greenplum Database data distribution key for this table.
HINT:  The 'DISTRIBUTED BY' clause determines the distribution of data. Make sure column(s) chosen are the optimal data distribution key to minimize skew.
NOTICE:  CREATE TABLE will create partition "supplier_hybrid_part_1_prt_p1" for table "supplier_hybrid_part"
NOTICE:  CREATE TABLE will create partition "supplier_hybrid_part_1_prt_p1_2_prt_1" for table "supplier_hybrid_part_1_prt_p1"
NOTICE:  CREATE TABLE will create partition "supplier_hybrid_part_1_prt_p1_2_prt_2" for table "supplier_hybrid_part_1_prt_p1"
NOTICE:  CREATE TABLE will create partition "supplier_hybrid_part_1_prt_p1_2_prt_3" for table "supplier_hybrid_part_1_prt_p1"
NOTICE:  CREATE TABLE will create partition "supplier_hybrid_part_1_prt_p1_2_prt_4" for table "supplier_hybrid_part_1_prt_p1"
NOTICE:  CREATE TABLE will create partition "supplier_hybrid_part_1_prt_p1_2_prt_5" for table "supplier_hybrid_part_1_prt_p1"
select pg_get_partition_def('supplier_hybrid_part'::regclass, true);
                                                       pg_get_partition_def                                                        
-----------------------------------------------------------------------------------------------------------------------------------
 PARTITION BY RANGE(s_suppkey)                                                                                                    +
           SUBPARTITION BY LIST(s_nationkey)                                                                                      +
           (                                                                                                                      +
           PARTITION p1 START (1) END (10001) EVERY (10000)                                                                       +
                   (                                                                                                              +
                   VALUES(22, 21, 17),                                                                                            +
                   VALUES(6, 11, 1, 7, 16, 2) WITH (checksum='false', appendonly='true', blocksize='1171456', compresslevel='3'), +
                   VALUES(18, 20),                                                                                                +
                   VALUES(9, 23, 13) WITH (checksum='true', appendonly='true', blocksize='1335296', compresslevel='7'),           +
                   VALUES(0, 3, 12, 15, 14, 8, 4, 24, 19, 10, 5)                                                                  +
                   )                                                                                                              +
           )
(1 row)

drop table supplier_hybrid_part;
-- MPP-3544
-- Domain
create domain domainvarchar varchar(5);
create domain domainnumeric numeric(8,2);
create domain domainint4 int4;
create domain domaintext text;
-- Test tables using domains
-- list
create table basictest1
           ( testint4 domainint4
           , testtext domaintext
           , testvarchar domainvarchar
           , testnumeric domainnumeric
           )
partition by LIST(testvarchar)
(
partition aa values ('aaaaa'),
partition bb values ('bbbbb'),
partition cc values ('ccccc')
);
NOTICE:  Table doesn't have 'DISTRIBUTED BY' clause -- Using column named 'testint4' as the Greenplum Database data distribution key for this table.
HINT:  The 'DISTRIBUTED BY' clause determines the distribution of data. Make sure column(s) chosen are the optimal data distribution key to minimize skew.
NOTICE:  CREATE TABLE will create partition "basictest1_1_prt_aa" for table "basictest1"
NOTICE:  CREATE TABLE will create partition "basictest1_1_prt_bb" for table "basictest1"
NOTICE:  CREATE TABLE will create partition "basictest1_1_prt_cc" for table "basictest1"
alter table basictest1 add partition dd values('ddddd');
NOTICE:  CREATE TABLE will create partition "basictest1_1_prt_dd" for table "basictest1"
insert into basictest1 values(1, 1, 'ddddd', 1);
insert into basictest1 values(1, 1, 'ccccc', 1);
insert into basictest1 values(1, 1, 'bbbbb', 1);
insert into basictest1 values(1, 1, 'aaaaa', 1);
drop table basictest1;
--range
create table basictest1 (testnumeric domainint4)
partition by range(testnumeric)
 (start(1) end(10) every(5));
NOTICE:  Table doesn't have 'DISTRIBUTED BY' clause -- Using column named 'testnumeric' as the Greenplum Database data distribution key for this table.
HINT:  The 'DISTRIBUTED BY' clause determines the distribution of data. Make sure column(s) chosen are the optimal data distribution key to minimize skew.
NOTICE:  CREATE TABLE will create partition "basictest1_1_prt_1" for table "basictest1"
NOTICE:  CREATE TABLE will create partition "basictest1_1_prt_2" for table "basictest1"
insert into basictest1 values(1);
insert into basictest1 values(2);
alter table basictest1 add partition ff start(10) end(20);
NOTICE:  CREATE TABLE will create partition "basictest1_1_prt_ff" for table "basictest1"
insert into basictest1 values(10);
drop table basictest1;
drop domain domainvarchar, domainnumeric, domainint4, domaintext;
-- Test index inheritance with partitions
create table ti (i int not null, j int)
distributed by (i)
partition by range (j) 
(start(1) end(3) every(1));
NOTICE:  CREATE TABLE will create partition "ti_1_prt_1" for table "ti"
NOTICE:  CREATE TABLE will create partition "ti_1_prt_2" for table "ti"
create unique index ti_pkey on ti(i);
NOTICE:  building index for child partition "ti_1_prt_1"
NOTICE:  building index for child partition "ti_1_prt_2"
select * from pg_indexes where schemaname = 'public' and tablename like 'ti%';
 schemaname | tablename  |    indexname     | tablespace |                                 indexdef                                  
------------+------------+------------------+------------+---------------------------------------------------------------------------
 public     | ti         | ti_pkey          |            | CREATE UNIQUE INDEX ti_pkey ON public.ti USING btree (i)
 public     | ti_1_prt_1 | ti_1_prt_1_i_idx |            | CREATE UNIQUE INDEX ti_1_prt_1_i_idx ON public.ti_1_prt_1 USING btree (i)
 public     | ti_1_prt_2 | ti_1_prt_2_i_idx |            | CREATE UNIQUE INDEX ti_1_prt_2_i_idx ON public.ti_1_prt_2 USING btree (i)
(3 rows)

create index ti_j_idx on ti using bitmap(j);
NOTICE:  building index for child partition "ti_1_prt_1"
NOTICE:  building index for child partition "ti_1_prt_2"
select * from pg_indexes where schemaname = 'public' and tablename like 'ti%';
 schemaname | tablename  |    indexname     | tablespace |                                 indexdef                                  
------------+------------+------------------+------------+---------------------------------------------------------------------------
 public     | ti         | ti_pkey          |            | CREATE UNIQUE INDEX ti_pkey ON public.ti USING btree (i)
 public     | ti_1_prt_1 | ti_1_prt_1_i_idx |            | CREATE UNIQUE INDEX ti_1_prt_1_i_idx ON public.ti_1_prt_1 USING btree (i)
 public     | ti_1_prt_2 | ti_1_prt_2_i_idx |            | CREATE UNIQUE INDEX ti_1_prt_2_i_idx ON public.ti_1_prt_2 USING btree (i)
 public     | ti         | ti_j_idx         |            | CREATE INDEX ti_j_idx ON public.ti USING bitmap (j)
 public     | ti_1_prt_1 | ti_1_prt_1_j_idx |            | CREATE INDEX ti_1_prt_1_j_idx ON public.ti_1_prt_1 USING bitmap (j)
 public     | ti_1_prt_2 | ti_1_prt_2_j_idx |            | CREATE INDEX ti_1_prt_2_j_idx ON public.ti_1_prt_2 USING bitmap (j)
(6 rows)

alter table ti add partition p3 start(3) end(10);
NOTICE:  CREATE TABLE will create partition "ti_1_prt_p3" for table "ti"
select * from pg_indexes where schemaname = 'public' and tablename like 'ti%';
 schemaname |  tablename  |     indexname     | tablespace |                                  indexdef                                   
------------+-------------+-------------------+------------+-----------------------------------------------------------------------------
 public     | ti          | ti_pkey           |            | CREATE UNIQUE INDEX ti_pkey ON public.ti USING btree (i)
 public     | ti_1_prt_1  | ti_1_prt_1_i_idx  |            | CREATE UNIQUE INDEX ti_1_prt_1_i_idx ON public.ti_1_prt_1 USING btree (i)
 public     | ti_1_prt_2  | ti_1_prt_2_i_idx  |            | CREATE UNIQUE INDEX ti_1_prt_2_i_idx ON public.ti_1_prt_2 USING btree (i)
 public     | ti          | ti_j_idx          |            | CREATE INDEX ti_j_idx ON public.ti USING bitmap (j)
 public     | ti_1_prt_1  | ti_1_prt_1_j_idx  |            | CREATE INDEX ti_1_prt_1_j_idx ON public.ti_1_prt_1 USING bitmap (j)
 public     | ti_1_prt_2  | ti_1_prt_2_j_idx  |            | CREATE INDEX ti_1_prt_2_j_idx ON public.ti_1_prt_2 USING bitmap (j)
 public     | ti_1_prt_p3 | ti_1_prt_p3_i_idx |            | CREATE UNIQUE INDEX ti_1_prt_p3_i_idx ON public.ti_1_prt_p3 USING btree (i)
 public     | ti_1_prt_p3 | ti_1_prt_p3_j_idx |            | CREATE INDEX ti_1_prt_p3_j_idx ON public.ti_1_prt_p3 USING bitmap (j)
(8 rows)

-- Should not be able to drop child indexes added implicitly via ADD PARTITION
drop index ti_1_prt_p3_i_idx;
ERROR:  cannot drop index ti_1_prt_p3_i_idx because index ti_pkey requires it
HINT:  You can drop index ti_pkey instead.
drop index ti_1_prt_p3_j_idx;
ERROR:  cannot drop index ti_1_prt_p3_j_idx because index ti_j_idx requires it
HINT:  You can drop index ti_j_idx instead.
alter table ti split partition p3 at (7) into (partition pnew1, partition pnew2);
NOTICE:  exchanged partition "p3" of relation "ti" with relation "pg_temp_4039681"
NOTICE:  dropped partition "p3" for relation "ti"
NOTICE:  CREATE TABLE will create partition "ti_1_prt_pnew1" for table "ti"
NOTICE:  CREATE TABLE will create partition "ti_1_prt_pnew2" for table "ti"
select * from pg_indexes where schemaname = 'public' and tablename like 'ti%';
 schemaname |   tablename    |      indexname       | tablespace |                                     indexdef                                      
------------+----------------+----------------------+------------+-----------------------------------------------------------------------------------
 public     | ti             | ti_pkey              |            | CREATE UNIQUE INDEX ti_pkey ON public.ti USING btree (i)
 public     | ti_1_prt_1     | ti_1_prt_1_i_idx     |            | CREATE UNIQUE INDEX ti_1_prt_1_i_idx ON public.ti_1_prt_1 USING btree (i)
 public     | ti_1_prt_2     | ti_1_prt_2_i_idx     |            | CREATE UNIQUE INDEX ti_1_prt_2_i_idx ON public.ti_1_prt_2 USING btree (i)
 public     | ti             | ti_j_idx             |            | CREATE INDEX ti_j_idx ON public.ti USING bitmap (j)
 public     | ti_1_prt_1     | ti_1_prt_1_j_idx     |            | CREATE INDEX ti_1_prt_1_j_idx ON public.ti_1_prt_1 USING bitmap (j)
 public     | ti_1_prt_2     | ti_1_prt_2_j_idx     |            | CREATE INDEX ti_1_prt_2_j_idx ON public.ti_1_prt_2 USING bitmap (j)
 public     | ti_1_prt_pnew1 | ti_1_prt_pnew1_i_idx |            | CREATE UNIQUE INDEX ti_1_prt_pnew1_i_idx ON public.ti_1_prt_pnew1 USING btree (i)
 public     | ti_1_prt_pnew1 | ti_1_prt_pnew1_j_idx |            | CREATE INDEX ti_1_prt_pnew1_j_idx ON public.ti_1_prt_pnew1 USING bitmap (j)
 public     | ti_1_prt_pnew2 | ti_1_prt_pnew2_i_idx |            | CREATE UNIQUE INDEX ti_1_prt_pnew2_i_idx ON public.ti_1_prt_pnew2 USING btree (i)
 public     | ti_1_prt_pnew2 | ti_1_prt_pnew2_j_idx |            | CREATE INDEX ti_1_prt_pnew2_j_idx ON public.ti_1_prt_pnew2 USING bitmap (j)
(10 rows)

-- Should not be able to drop child indexes added implicitly via SPLIT PARTITION
drop index ti_1_prt_pnew1_i_idx;
ERROR:  cannot drop index ti_1_prt_pnew1_i_idx because index ti_pkey requires it
HINT:  You can drop index ti_pkey instead.
drop index ti_1_prt_pnew1_j_idx;
ERROR:  cannot drop index ti_1_prt_pnew1_j_idx because index ti_j_idx requires it
HINT:  You can drop index ti_j_idx instead.
drop index ti_1_prt_pnew2_i_idx;
ERROR:  cannot drop index ti_1_prt_pnew2_i_idx because index ti_pkey requires it
HINT:  You can drop index ti_pkey instead.
drop index ti_1_prt_pnew2_j_idx;
ERROR:  cannot drop index ti_1_prt_pnew2_j_idx because index ti_j_idx requires it
HINT:  You can drop index ti_j_idx instead.
-- Index drop should cascade to all partitions- including those later added via
-- ADD PARTITION or SPLIT PARTITION
drop index ti_pkey;
drop index ti_j_idx;
select * from pg_indexes where schemaname = 'public' and tablename like 'ti%';
 schemaname | tablename | indexname | tablespace | indexdef 
------------+-----------+-----------+------------+----------
(0 rows)

drop table ti;
-- MPP-6611, make sure rename works with default partitions
create table it (i int, j int) partition by range(i) 
subpartition by range(j) subpartition template(start(1) end(10) every(5))
(start(1) end(3) every(1));
NOTICE:  Table doesn't have 'DISTRIBUTED BY' clause -- Using column named 'i' as the Greenplum Database data distribution key for this table.
HINT:  The 'DISTRIBUTED BY' clause determines the distribution of data. Make sure column(s) chosen are the optimal data distribution key to minimize skew.
NOTICE:  CREATE TABLE will create partition "it_1_prt_1" for table "it"
NOTICE:  CREATE TABLE will create partition "it_1_prt_1_2_prt_1" for table "it_1_prt_1"
NOTICE:  CREATE TABLE will create partition "it_1_prt_1_2_prt_2" for table "it_1_prt_1"
NOTICE:  CREATE TABLE will create partition "it_1_prt_2" for table "it"
NOTICE:  CREATE TABLE will create partition "it_1_prt_2_2_prt_1" for table "it_1_prt_2"
NOTICE:  CREATE TABLE will create partition "it_1_prt_2_2_prt_2" for table "it_1_prt_2"
alter table it rename to newit;
select schemaname, tablename from pg_tables where schemaname = 'public' and tablename like 'newit%';
 schemaname |       tablename       
------------+-----------------------
 public     | newit
 public     | newit_1_prt_1
 public     | newit_1_prt_1_2_prt_1
 public     | newit_1_prt_1_2_prt_2
 public     | newit_1_prt_2
 public     | newit_1_prt_2_2_prt_1
 public     | newit_1_prt_2_2_prt_2
(7 rows)

alter table newit add default partition def;
NOTICE:  CREATE TABLE will create partition "newit_1_prt_def" for table "newit"
NOTICE:  CREATE TABLE will create partition "newit_1_prt_def_2_prt_1" for table "newit_1_prt_def"
NOTICE:  CREATE TABLE will create partition "newit_1_prt_def_2_prt_2" for table "newit_1_prt_def"
select schemaname, tablename from pg_tables where schemaname = 'public' and tablename like 'newit%';
 schemaname |        tablename        
------------+-------------------------
 public     | newit
 public     | newit_1_prt_1
 public     | newit_1_prt_1_2_prt_1
 public     | newit_1_prt_1_2_prt_2
 public     | newit_1_prt_2
 public     | newit_1_prt_2_2_prt_1
 public     | newit_1_prt_2_2_prt_2
 public     | newit_1_prt_def_2_prt_1
 public     | newit_1_prt_def_2_prt_2
 public     | newit_1_prt_def
(10 rows)

alter table newit rename to anotherit;
select schemaname, tablename from pg_tables where schemaname = 'public' and tablename like
'anotherit%';
 schemaname |          tablename          
------------+-----------------------------
 public     | anotherit
 public     | anotherit_1_prt_1
 public     | anotherit_1_prt_1_2_prt_1
 public     | anotherit_1_prt_1_2_prt_2
 public     | anotherit_1_prt_2
 public     | anotherit_1_prt_2_2_prt_1
 public     | anotherit_1_prt_2_2_prt_2
 public     | anotherit_1_prt_def
 public     | anotherit_1_prt_def_2_prt_1
 public     | anotherit_1_prt_def_2_prt_2
(10 rows)

drop table anotherit;
--
-- Test table constraint inheritance
--
-- with a named UNIQUE constraint
create table it (i int) distributed by (i) partition by range(i) (start(1) end(3) every(1));
NOTICE:  CREATE TABLE will create partition "it_1_prt_1" for table "it"
NOTICE:  CREATE TABLE will create partition "it_1_prt_2" for table "it"
select schemaname, tablename, indexname from pg_indexes where schemaname = 'public' and tablename like 'it%';
 schemaname | tablename | indexname 
------------+-----------+-----------
(0 rows)

alter table it add constraint it_unique_i unique (i);
select schemaname, tablename, indexname from pg_indexes where schemaname = 'public' and tablename like 'it%';
 schemaname | tablename  |    indexname     
------------+------------+------------------
 public     | it         | it_unique_i
 public     | it_1_prt_1 | it_1_prt_1_i_key
 public     | it_1_prt_2 | it_1_prt_2_i_key
(3 rows)

alter table it drop constraint it_unique_i;
select schemaname, tablename, indexname from pg_indexes where schemaname = 'public' and tablename like 'it%';
 schemaname | tablename | indexname 
------------+-----------+-----------
(0 rows)

drop table it;
-- with a PRIMARY KEY constraint, without giving it a name explicitly.
create table it (i int) distributed by (i) partition by range(i) (start(1) end(3) every(1));
NOTICE:  CREATE TABLE will create partition "it_1_prt_1" for table "it"
NOTICE:  CREATE TABLE will create partition "it_1_prt_2" for table "it"
select schemaname, tablename, indexname from pg_indexes where schemaname = 'public' and tablename like 'it%';
 schemaname | tablename | indexname 
------------+-----------+-----------
(0 rows)

alter table it add primary key(i);
select schemaname, tablename, indexname from pg_indexes where schemaname = 'public' and tablename like 'it%';
 schemaname | tablename  |    indexname    
------------+------------+-----------------
 public     | it         | it_pkey
 public     | it_1_prt_1 | it_1_prt_1_pkey
 public     | it_1_prt_2 | it_1_prt_2_pkey
(3 rows)

-- FIXME: dropping a primary key doesn't currently work correctly. It doesn't
-- drop the key on the partitions, only the parent. See
-- https://github.com/greenplum-db/gpdb/issues/3750
--
-- alter table it add primary key(i);
-- select schemaname, tablename, indexname from pg_indexes where schemaname = 'public' and tablename like 'it%';
drop table it;
create table it (i int) distributed by (i) partition by range(i) (start(1) end(3) every(1));
NOTICE:  CREATE TABLE will create partition "it_1_prt_1" for table "it"
NOTICE:  CREATE TABLE will create partition "it_1_prt_2" for table "it"
select schemaname, tablename, indexname from pg_indexes where schemaname = 'public' and tablename like 'it%';
 schemaname | tablename | indexname 
------------+-----------+-----------
(0 rows)

alter table it add primary key(i);
select schemaname, tablename, indexname from pg_indexes where schemaname = 'public' and tablename like 'it%';
 schemaname | tablename  |    indexname    
------------+------------+-----------------
 public     | it         | it_pkey
 public     | it_1_prt_1 | it_1_prt_1_pkey
 public     | it_1_prt_2 | it_1_prt_2_pkey
(3 rows)

drop table it;
-- MPP-6297: test special WITH(tablename=...) syntax for dump/restore
-- original table was:
-- PARTITION BY RANGE(l_commitdate) 
-- (
--     PARTITION p1 
--       START ('1992-01-31'::date) END ('1995-04-30'::date) 
--       EVERY ('1 year 1 mon'::interval)
-- )
-- dump used to give a definition like this:
-- without the WITH(tablename=...), the vagaries of EVERY arithmetic
-- create >3 partitions
CREATE TABLE mpp6297 ( l_orderkey bigint,
l_commitdate date
)
distributed BY (l_orderkey) PARTITION BY RANGE(l_commitdate)
(
PARTITION p1_1 START ('1992-01-31'::date) END ('1993-02-28'::date)
EVERY ('1 year 1 mon'::interval)
,
PARTITION p1_2 START ('1993-02-28'::date) END ('1994-03-31'::date)
EVERY ('1 year 1 mon'::interval)
,
PARTITION p1_3 START ('1994-03-31'::date) END ('1995-04-30'::date)
EVERY ('1 year 1 mon'::interval)
);
NOTICE:  CREATE TABLE will create partition "mpp6297_1_prt_p1_1" for table "mpp6297"
NOTICE:  CREATE TABLE will create partition "mpp6297_1_prt_p1_2_1" for table "mpp6297"
NOTICE:  CREATE TABLE will create partition "mpp6297_1_prt_p1_2_2" for table "mpp6297"
NOTICE:  CREATE TABLE will create partition "mpp6297_1_prt_p1_3" for table "mpp6297"
-- should be a single partition def for p1 from 1/31 to 4/30, but
-- shows 4 partitions instead
select partitiontablename, partitionname, 
partitionrangestart, partitionrangeend, partitioneveryclause
from pg_partitions
where tablename like 'mpp6297%' order by partitionrank;
  partitiontablename  | partitionname | partitionrangestart | partitionrangeend  |    partitioneveryclause    
----------------------+---------------+---------------------+--------------------+----------------------------
 mpp6297_1_prt_p1_1   | p1_1          | '01-31-1992'::date  | '02-28-1993'::date | '@ 1 year 1 mon'::interval
 mpp6297_1_prt_p1_2_1 | p1_2_1        | '02-28-1993'::date  | '03-28-1994'::date | '@ 1 year 1 mon'::interval
 mpp6297_1_prt_p1_2_2 | p1_2_2        | '03-28-1994'::date  | '03-31-1994'::date | '@ 1 year 1 mon'::interval
 mpp6297_1_prt_p1_3   | p1_3          | '03-31-1994'::date  | '04-30-1995'::date | '@ 1 year 1 mon'::interval
(4 rows)

select 
pg_get_partition_def(
(select oid from pg_class 
where relname='mpp6297')::pg_catalog.oid, true);
                                               pg_get_partition_def                                                
-------------------------------------------------------------------------------------------------------------------
 PARTITION BY RANGE(l_commitdate)                                                                                 +
           (                                                                                                      +
           PARTITION p1 START ('01-31-1992'::date) END ('02-28-1993'::date) EVERY ('@ 1 year 1 mon'::interval),   +
           PARTITION p1_2 START ('02-28-1993'::date) END ('03-31-1994'::date) EVERY ('@ 1 year 1 mon'::interval), +
           PARTITION p1_3 START ('03-31-1994'::date) END ('04-30-1995'::date) EVERY ('@ 1 year 1 mon'::interval)  +
           )
(1 row)

drop table mpp6297;
-- when WITH(tablename=...) is specified, the EVERY is stored as an
-- attribute, but not expanded into additional partitions
CREATE TABLE mpp6297 ( l_orderkey bigint,
l_commitdate date
)
distributed BY (l_orderkey) PARTITION BY RANGE(l_commitdate)
(
PARTITION p1_1 START ('1992-01-31'::date) END ('1993-02-28'::date)
EVERY ('1 year 1 mon'::interval)
WITH (tablename='mpp6297_1_prt_p1_1'),
PARTITION p1_2 START ('1993-02-28'::date) END ('1994-03-31'::date)
EVERY ('1 year 1 mon'::interval)
WITH (tablename='mpp6297_1_prt_p1_2'),
PARTITION p1_3 START ('1994-03-31'::date) END ('1995-04-30'::date)
EVERY ('1 year 1 mon'::interval)
WITH (tablename='mpp6297_1_prt_p1_3')
);
NOTICE:  CREATE TABLE will create partition "mpp6297_1_prt_p1_1" for table "mpp6297"
NOTICE:  CREATE TABLE will create partition "mpp6297_1_prt_p1_2" for table "mpp6297"
NOTICE:  CREATE TABLE will create partition "mpp6297_1_prt_p1_3" for table "mpp6297"
-- should be a single partition def for p1 from 1/31 to 4/30, as intended
select 
pg_get_partition_def(
(select oid from pg_class 
where relname='mpp6297')::pg_catalog.oid, true);
                                             pg_get_partition_def                                              
---------------------------------------------------------------------------------------------------------------
 PARTITION BY RANGE(l_commitdate)                                                                             +
           (                                                                                                  +
           PARTITION p1 START ('01-31-1992'::date) END ('04-30-1995'::date) EVERY ('@ 1 year 1 mon'::interval)+
           )
(1 row)

drop table mpp6297;
-- more with basic cases
create table mpp6297 
(a int, 
b int) 
partition by range (b)
(
start (1) end (10) every (1),
end (11)		
);
NOTICE:  Table doesn't have 'DISTRIBUTED BY' clause -- Using column named 'a' as the Greenplum Database data distribution key for this table.
HINT:  The 'DISTRIBUTED BY' clause determines the distribution of data. Make sure column(s) chosen are the optimal data distribution key to minimize skew.
NOTICE:  CREATE TABLE will create partition "mpp6297_1_prt_1" for table "mpp6297"
NOTICE:  CREATE TABLE will create partition "mpp6297_1_prt_2" for table "mpp6297"
NOTICE:  CREATE TABLE will create partition "mpp6297_1_prt_3" for table "mpp6297"
NOTICE:  CREATE TABLE will create partition "mpp6297_1_prt_4" for table "mpp6297"
NOTICE:  CREATE TABLE will create partition "mpp6297_1_prt_5" for table "mpp6297"
NOTICE:  CREATE TABLE will create partition "mpp6297_1_prt_6" for table "mpp6297"
NOTICE:  CREATE TABLE will create partition "mpp6297_1_prt_7" for table "mpp6297"
NOTICE:  CREATE TABLE will create partition "mpp6297_1_prt_8" for table "mpp6297"
NOTICE:  CREATE TABLE will create partition "mpp6297_1_prt_9" for table "mpp6297"
NOTICE:  CREATE TABLE will create partition "mpp6297_1_prt_10" for table "mpp6297"
-- note that the partition from 10 to 11 is *not* part of every
select 
pg_get_partition_def(
(select oid from pg_class 
where relname='mpp6297')::pg_catalog.oid, true);
           pg_get_partition_def           
------------------------------------------
 PARTITION BY RANGE(b)                   +
           (                             +
           START (1) END (10) EVERY (1), +
           START (10) END (11)           +
           )
(1 row)

alter table mpp6297 drop partition for (rank(3));
-- note that the every clause splits into two parts: 1-3 and 4-10
select
pg_get_partition_def(
(select oid from pg_class
where relname='mpp6297')::pg_catalog.oid, true);
           pg_get_partition_def           
------------------------------------------
 PARTITION BY RANGE(b)                   +
           (                             +
           START (1) END (3) EVERY (1),  +
           START (4) END (10) EVERY (1), +
           START (10) END (11)           +
           )
(1 row)

-- this isn't legal (but it would be nice)
alter table mpp6297 add partition start (3) end (4) every (1);
ERROR:  cannot specify EVERY when adding RANGE partition to relation "mpp6297"
-- this is legal but it doesn't fix the EVERY clause
alter table mpp6297 add partition start (3) end (4) ;
NOTICE:  CREATE TABLE will create partition "mpp6297_1_prt_r61034287" for table "mpp6297"
-- note that the every clause is still splits into two parts: 1-3 and
-- 4-10, because the new partition from 3 to 4 doesn't have an EVERY
-- attribute
select
pg_get_partition_def(
(select oid from pg_class
where relname='mpp6297')::pg_catalog.oid, true);
           pg_get_partition_def           
------------------------------------------
 PARTITION BY RANGE(b)                   +
           (                             +
           START (1) END (3) EVERY (1),  +
           START (3) END (4),            +
           START (4) END (10) EVERY (1), +
           START (10) END (11)           +
           )
(1 row)

drop table mpp6297;
-- similarly, we can merge adjacent EVERY clauses if they match
create table mpp6297 
(a int, 
b int) 
partition by range (b)
(
start (1) end (5) every (1),
start (5) end (10) every (1)
);
NOTICE:  Table doesn't have 'DISTRIBUTED BY' clause -- Using column named 'a' as the Greenplum Database data distribution key for this table.
HINT:  The 'DISTRIBUTED BY' clause determines the distribution of data. Make sure column(s) chosen are the optimal data distribution key to minimize skew.
NOTICE:  CREATE TABLE will create partition "mpp6297_1_prt_1" for table "mpp6297"
NOTICE:  CREATE TABLE will create partition "mpp6297_1_prt_2" for table "mpp6297"
NOTICE:  CREATE TABLE will create partition "mpp6297_1_prt_3" for table "mpp6297"
NOTICE:  CREATE TABLE will create partition "mpp6297_1_prt_4" for table "mpp6297"
NOTICE:  CREATE TABLE will create partition "mpp6297_1_prt_5" for table "mpp6297"
NOTICE:  CREATE TABLE will create partition "mpp6297_1_prt_6" for table "mpp6297"
NOTICE:  CREATE TABLE will create partition "mpp6297_1_prt_7" for table "mpp6297"
NOTICE:  CREATE TABLE will create partition "mpp6297_1_prt_8" for table "mpp6297"
NOTICE:  CREATE TABLE will create partition "mpp6297_1_prt_9" for table "mpp6297"
-- note that there is only a single every from 1-10
select 
pg_get_partition_def(
(select oid from pg_class 
where relname='mpp6297')::pg_catalog.oid, true);
          pg_get_partition_def          
----------------------------------------
 PARTITION BY RANGE(b)                 +
           (                           +
           START (1) END (10) EVERY (1)+
           )
(1 row)

drop table mpp6297;
-- we cannot merge adjacent EVERY clauses if inclusivity/exclusivity is wrong
create table mpp6297 
(a int, 
b int) 
partition by range (b)
(
start (1) end (5) every (1),
start (5) exclusive end (10) every (1)
);
NOTICE:  Table doesn't have 'DISTRIBUTED BY' clause -- Using column named 'a' as the Greenplum Database data distribution key for this table.
HINT:  The 'DISTRIBUTED BY' clause determines the distribution of data. Make sure column(s) chosen are the optimal data distribution key to minimize skew.
NOTICE:  CREATE TABLE will create partition "mpp6297_1_prt_1" for table "mpp6297"
NOTICE:  CREATE TABLE will create partition "mpp6297_1_prt_2" for table "mpp6297"
NOTICE:  CREATE TABLE will create partition "mpp6297_1_prt_3" for table "mpp6297"
NOTICE:  CREATE TABLE will create partition "mpp6297_1_prt_4" for table "mpp6297"
NOTICE:  CREATE TABLE will create partition "mpp6297_1_prt_5" for table "mpp6297"
NOTICE:  CREATE TABLE will create partition "mpp6297_1_prt_6" for table "mpp6297"
NOTICE:  CREATE TABLE will create partition "mpp6297_1_prt_7" for table "mpp6297"
NOTICE:  CREATE TABLE will create partition "mpp6297_1_prt_8" for table "mpp6297"
NOTICE:  CREATE TABLE will create partition "mpp6297_1_prt_9" for table "mpp6297"
-- two every clauses for this case
select 
pg_get_partition_def(
(select oid from pg_class 
where relname='mpp6297')::pg_catalog.oid, true);
               pg_get_partition_def               
--------------------------------------------------
 PARTITION BY RANGE(b)                           +
           (                                     +
           START (1) END (5) EVERY (1),          +
           START (5) EXCLUSIVE END (10) EVERY (1)+
           )
(1 row)

drop table mpp6297;
-- more fun with inclusivity/exclusivity (normal case)
create table mpp6297 
(a int, 
b int) 
partition by range (b)
(
start (1) inclusive end (10) exclusive every (1)
);
NOTICE:  Table doesn't have 'DISTRIBUTED BY' clause -- Using column named 'a' as the Greenplum Database data distribution key for this table.
HINT:  The 'DISTRIBUTED BY' clause determines the distribution of data. Make sure column(s) chosen are the optimal data distribution key to minimize skew.
NOTICE:  CREATE TABLE will create partition "mpp6297_1_prt_1" for table "mpp6297"
NOTICE:  CREATE TABLE will create partition "mpp6297_1_prt_2" for table "mpp6297"
NOTICE:  CREATE TABLE will create partition "mpp6297_1_prt_3" for table "mpp6297"
NOTICE:  CREATE TABLE will create partition "mpp6297_1_prt_4" for table "mpp6297"
NOTICE:  CREATE TABLE will create partition "mpp6297_1_prt_5" for table "mpp6297"
NOTICE:  CREATE TABLE will create partition "mpp6297_1_prt_6" for table "mpp6297"
NOTICE:  CREATE TABLE will create partition "mpp6297_1_prt_7" for table "mpp6297"
NOTICE:  CREATE TABLE will create partition "mpp6297_1_prt_8" for table "mpp6297"
NOTICE:  CREATE TABLE will create partition "mpp6297_1_prt_9" for table "mpp6297"
-- note that inclusive and exclusive attributes aren't listed here (because
-- default behavior)
select 
pg_get_partition_def(
(select oid from pg_class 
where relname='mpp6297')::pg_catalog.oid, true);
          pg_get_partition_def          
----------------------------------------
 PARTITION BY RANGE(b)                 +
           (                           +
           START (1) END (10) EVERY (1)+
           )
(1 row)

drop table mpp6297;
-- more fun with inclusivity/exclusivity (abnormal case)
create table mpp6297 
(a int, 
b int) 
partition by range (b)
(
start (1) exclusive end (10) inclusive every (1)
);
NOTICE:  Table doesn't have 'DISTRIBUTED BY' clause -- Using column named 'a' as the Greenplum Database data distribution key for this table.
HINT:  The 'DISTRIBUTED BY' clause determines the distribution of data. Make sure column(s) chosen are the optimal data distribution key to minimize skew.
NOTICE:  CREATE TABLE will create partition "mpp6297_1_prt_1" for table "mpp6297"
NOTICE:  CREATE TABLE will create partition "mpp6297_1_prt_2" for table "mpp6297"
NOTICE:  CREATE TABLE will create partition "mpp6297_1_prt_3" for table "mpp6297"
NOTICE:  CREATE TABLE will create partition "mpp6297_1_prt_4" for table "mpp6297"
NOTICE:  CREATE TABLE will create partition "mpp6297_1_prt_5" for table "mpp6297"
NOTICE:  CREATE TABLE will create partition "mpp6297_1_prt_6" for table "mpp6297"
NOTICE:  CREATE TABLE will create partition "mpp6297_1_prt_7" for table "mpp6297"
NOTICE:  CREATE TABLE will create partition "mpp6297_1_prt_8" for table "mpp6297"
NOTICE:  CREATE TABLE will create partition "mpp6297_1_prt_9" for table "mpp6297"
-- note that inclusive and exclusive attributes are listed here 
select 
pg_get_partition_def(
(select oid from pg_class 
where relname='mpp6297')::pg_catalog.oid, true);
                    pg_get_partition_def                    
------------------------------------------------------------
 PARTITION BY RANGE(b)                                     +
           (                                               +
           START (1) EXCLUSIVE END (10) INCLUSIVE EVERY (1)+
           )
(1 row)

alter table mpp6297 drop partition for (rank(3));
-- note that the every clause splits into two parts: 1-3 and 4-10 (and
-- inclusive/exclusive is listed correctly)
select
pg_get_partition_def(
(select oid from pg_class
where relname='mpp6297')::pg_catalog.oid, true);
               pg_get_partition_def                
---------------------------------------------------
 PARTITION BY RANGE(b)                            +
           (                                      +
           START (1) EXCLUSIVE END (3) EVERY (1), +
           START (4) END (10) INCLUSIVE EVERY (1) +
           )
(1 row)

drop table mpp6297;
-- we cannot merge adjacent EVERY clauses, even though the
-- inclusivity/exclusivity matches, because it is different from the
-- normal start inclusive/end exclusive
create table mpp6297 
(a int, 
b int) 
partition by range (b)
(
start (1) end (5) inclusive every (1),
start (5) exclusive end (10) every (1)
);
NOTICE:  Table doesn't have 'DISTRIBUTED BY' clause -- Using column named 'a' as the Greenplum Database data distribution key for this table.
HINT:  The 'DISTRIBUTED BY' clause determines the distribution of data. Make sure column(s) chosen are the optimal data distribution key to minimize skew.
NOTICE:  CREATE TABLE will create partition "mpp6297_1_prt_1" for table "mpp6297"
NOTICE:  CREATE TABLE will create partition "mpp6297_1_prt_2" for table "mpp6297"
NOTICE:  CREATE TABLE will create partition "mpp6297_1_prt_3" for table "mpp6297"
NOTICE:  CREATE TABLE will create partition "mpp6297_1_prt_4" for table "mpp6297"
NOTICE:  CREATE TABLE will create partition "mpp6297_1_prt_5" for table "mpp6297"
NOTICE:  CREATE TABLE will create partition "mpp6297_1_prt_6" for table "mpp6297"
NOTICE:  CREATE TABLE will create partition "mpp6297_1_prt_7" for table "mpp6297"
NOTICE:  CREATE TABLE will create partition "mpp6297_1_prt_8" for table "mpp6297"
NOTICE:  CREATE TABLE will create partition "mpp6297_1_prt_9" for table "mpp6297"
-- two every clauses for this case
select 
pg_get_partition_def(
(select oid from pg_class 
where relname='mpp6297')::pg_catalog.oid, true);
               pg_get_partition_def                
---------------------------------------------------
 PARTITION BY RANGE(b)                            +
           (                                      +
           START (1) END (5) INCLUSIVE EVERY (1), +
           START (5) EXCLUSIVE END (10) EVERY (1) +
           )
(1 row)

drop table mpp6297;
-- MPP-6589: SPLITting an "open" ended partition (ie, no start or end)
CREATE TABLE mpp6589a
(
  id bigint,
  day_dt date
)
DISTRIBUTED BY (id)
PARTITION BY RANGE(day_dt)
          (
          PARTITION p20090312  END ('2009-03-12'::date)
          );
NOTICE:  CREATE TABLE will create partition "mpp6589a_1_prt_p20090312" for table "mpp6589a"
select pg_get_partition_def('mpp6589a'::regclass,true);
                  pg_get_partition_def                   
---------------------------------------------------------
 PARTITION BY RANGE(day_dt)                             +
           (                                            +
           PARTITION p20090312  END ('03-12-2009'::date)+
           )
(1 row)

-- should work
ALTER TABLE mpp6589a 
SPLIT PARTITION p20090312 AT( '20090310' ) 
INTO( PARTITION p20090309, PARTITION p20090312_tmp);
NOTICE:  exchanged partition "p20090312" of relation "mpp6589a" with relation "pg_temp_4043580"
NOTICE:  dropped partition "p20090312" for relation "mpp6589a"
NOTICE:  CREATE TABLE will create partition "mpp6589a_1_prt_p20090309" for table "mpp6589a"
NOTICE:  CREATE TABLE will create partition "mpp6589a_1_prt_p20090312_tmp" for table "mpp6589a"
select pg_get_partition_def('mpp6589a'::regclass,true);
                                 pg_get_partition_def                                  
---------------------------------------------------------------------------------------
 PARTITION BY RANGE(day_dt)                                                           +
           (                                                                          +
           PARTITION p20090309  END ('03-10-2009'::date),                             +
           PARTITION p20090312_tmp START ('03-10-2009'::date) END ('03-12-2009'::date)+
           )
(1 row)

CREATE TABLE mpp6589i(a int, b int) 
partition by range (b) (start (1) end (3));
NOTICE:  Table doesn't have 'DISTRIBUTED BY' clause -- Using column named 'a' as the Greenplum Database data distribution key for this table.
HINT:  The 'DISTRIBUTED BY' clause determines the distribution of data. Make sure column(s) chosen are the optimal data distribution key to minimize skew.
NOTICE:  CREATE TABLE will create partition "mpp6589i_1_prt_1" for table "mpp6589i"
select pg_get_partition_def('mpp6589i'::regclass,true);
    pg_get_partition_def     
-----------------------------
 PARTITION BY RANGE(b)      +
           (                +
           START (1) END (3)+
           )
(1 row)

-- should fail (overlap)
ALTER TABLE mpp6589i ADD PARTITION start (2);
ERROR:  new partition overlaps existing partition
-- should fail (overlap) (not a real overlap, but a "point" hole)
ALTER TABLE mpp6589i ADD PARTITION start (3) exclusive;
ERROR:  new partition overlaps existing partition
-- should work - make sure can add an open-ended final partition
ALTER TABLE mpp6589i ADD PARTITION start (3);
NOTICE:  CREATE TABLE will create partition "mpp6589i_1_prt_r852860736" for table "mpp6589i"
select pg_get_partition_def('mpp6589i'::regclass,true);
     pg_get_partition_def      
-------------------------------
 PARTITION BY RANGE(b)        +
           (                  +
           START (1) END (3), +
           START (3)          +
           )
(1 row)

-- test open-ended SPLIT
CREATE TABLE mpp6589b
(
  id bigint,
  day_dt date
)
DISTRIBUTED BY (id)
PARTITION BY RANGE(day_dt)
          (
          PARTITION p20090312  START ('2008-03-12'::date)
          );
NOTICE:  CREATE TABLE will create partition "mpp6589b_1_prt_p20090312" for table "mpp6589b"
select pg_get_partition_def('mpp6589b'::regclass,true);
                   pg_get_partition_def                   
----------------------------------------------------------
 PARTITION BY RANGE(day_dt)                              +
           (                                             +
           PARTITION p20090312 START ('03-12-2008'::date)+
           )
(1 row)

-- should work
ALTER TABLE mpp6589b 
SPLIT PARTITION p20090312 AT( '20090310' ) 
INTO( PARTITION p20090309, PARTITION p20090312_tmp);
NOTICE:  exchanged partition "p20090312" of relation "mpp6589b" with relation "pg_temp_4043944"
NOTICE:  dropped partition "p20090312" for relation "mpp6589b"
NOTICE:  CREATE TABLE will create partition "mpp6589b_1_prt_p20090309" for table "mpp6589b"
NOTICE:  CREATE TABLE will create partition "mpp6589b_1_prt_p20090312_tmp" for table "mpp6589b"
select pg_get_partition_def('mpp6589b'::regclass,true);
                                pg_get_partition_def                                 
-------------------------------------------------------------------------------------
 PARTITION BY RANGE(day_dt)                                                         +
           (                                                                        +
           PARTITION p20090309 START ('03-12-2008'::date) END ('03-10-2009'::date), +
           PARTITION p20090312_tmp START ('03-10-2009'::date)                       +
           )
(1 row)

-- MPP-7191, MPP-7193: partitioned tables - fully-qualify storage type
-- if not specified (and not a template)
CREATE TABLE mpp5992 (a int, b date, c char,
                     d char(4), e varchar(20), f timestamp)
WITH (orientation=column,appendonly=true)
partition by range (b)
subpartition by list (a)
subpartition template (
subpartition l1 values (1,2,3,4,5),
subpartition l2 values (6,7,8,9,10) )
subpartition by list (e)
subpartition template (
subpartition ll1 values ('Engineering'),
subpartition ll2 values ('QA') )
subpartition by list (c)
subpartition template (
subpartition lll1 values ('M'),
subpartition lll2 values ('F') )
(
  start (date '2007-01-01')
  end (date '2010-01-01') every (interval '1 year')
);
NOTICE:  Table doesn't have 'DISTRIBUTED BY' clause -- Using column named 'a' as the Greenplum Database data distribution key for this table.
HINT:  The 'DISTRIBUTED BY' clause determines the distribution of data. Make sure column(s) chosen are the optimal data distribution key to minimize skew.
NOTICE:  CREATE TABLE will create partition "mpp5992_1_prt_1" for table "mpp5992"
NOTICE:  CREATE TABLE will create partition "mpp5992_1_prt_1_2_prt_l1" for table "mpp5992_1_prt_1"
NOTICE:  CREATE TABLE will create partition "mpp5992_1_prt_1_2_prt_l1_3_prt_ll1" for table "mpp5992_1_prt_1_2_prt_l1"
NOTICE:  CREATE TABLE will create partition "mpp5992_1_prt_1_2_prt_l1_3_prt_ll2" for table "mpp5992_1_prt_1_2_prt_l1"
NOTICE:  CREATE TABLE will create partition "mpp5992_1_prt_1_2_prt_l1_3_prt_ll1_4_prt_lll1" for table "mpp5992_1_prt_1_2_prt_l1_3_prt_ll1"
NOTICE:  CREATE TABLE will create partition "mpp5992_1_prt_1_2_prt_l1_3_prt_ll1_4_prt_lll2" for table "mpp5992_1_prt_1_2_prt_l1_3_prt_ll1"
NOTICE:  CREATE TABLE will create partition "mpp5992_1_prt_1_2_prt_l1_3_prt_ll2_4_prt_lll1" for table "mpp5992_1_prt_1_2_prt_l1_3_prt_ll2"
NOTICE:  CREATE TABLE will create partition "mpp5992_1_prt_1_2_prt_l1_3_prt_ll2_4_prt_lll2" for table "mpp5992_1_prt_1_2_prt_l1_3_prt_ll2"
NOTICE:  CREATE TABLE will create partition "mpp5992_1_prt_1_2_prt_l2" for table "mpp5992_1_prt_1"
NOTICE:  CREATE TABLE will create partition "mpp5992_1_prt_1_2_prt_l2_3_prt_ll1" for table "mpp5992_1_prt_1_2_prt_l2"
NOTICE:  CREATE TABLE will create partition "mpp5992_1_prt_1_2_prt_l2_3_prt_ll2" for table "mpp5992_1_prt_1_2_prt_l2"
NOTICE:  CREATE TABLE will create partition "mpp5992_1_prt_1_2_prt_l2_3_prt_ll1_4_prt_lll1" for table "mpp5992_1_prt_1_2_prt_l2_3_prt_ll1"
NOTICE:  CREATE TABLE will create partition "mpp5992_1_prt_1_2_prt_l2_3_prt_ll1_4_prt_lll2" for table "mpp5992_1_prt_1_2_prt_l2_3_prt_ll1"
NOTICE:  CREATE TABLE will create partition "mpp5992_1_prt_1_2_prt_l2_3_prt_ll2_4_prt_lll1" for table "mpp5992_1_prt_1_2_prt_l2_3_prt_ll2"
NOTICE:  CREATE TABLE will create partition "mpp5992_1_prt_1_2_prt_l2_3_prt_ll2_4_prt_lll2" for table "mpp5992_1_prt_1_2_prt_l2_3_prt_ll2"
NOTICE:  CREATE TABLE will create partition "mpp5992_1_prt_2" for table "mpp5992"
NOTICE:  CREATE TABLE will create partition "mpp5992_1_prt_2_2_prt_l1" for table "mpp5992_1_prt_2"
NOTICE:  CREATE TABLE will create partition "mpp5992_1_prt_2_2_prt_l1_3_prt_ll1" for table "mpp5992_1_prt_2_2_prt_l1"
NOTICE:  CREATE TABLE will create partition "mpp5992_1_prt_2_2_prt_l1_3_prt_ll2" for table "mpp5992_1_prt_2_2_prt_l1"
NOTICE:  CREATE TABLE will create partition "mpp5992_1_prt_2_2_prt_l1_3_prt_ll1_4_prt_lll1" for table "mpp5992_1_prt_2_2_prt_l1_3_prt_ll1"
NOTICE:  CREATE TABLE will create partition "mpp5992_1_prt_2_2_prt_l1_3_prt_ll1_4_prt_lll2" for table "mpp5992_1_prt_2_2_prt_l1_3_prt_ll1"
NOTICE:  CREATE TABLE will create partition "mpp5992_1_prt_2_2_prt_l1_3_prt_ll2_4_prt_lll1" for table "mpp5992_1_prt_2_2_prt_l1_3_prt_ll2"
NOTICE:  CREATE TABLE will create partition "mpp5992_1_prt_2_2_prt_l1_3_prt_ll2_4_prt_lll2" for table "mpp5992_1_prt_2_2_prt_l1_3_prt_ll2"
NOTICE:  CREATE TABLE will create partition "mpp5992_1_prt_2_2_prt_l2" for table "mpp5992_1_prt_2"
NOTICE:  CREATE TABLE will create partition "mpp5992_1_prt_2_2_prt_l2_3_prt_ll1" for table "mpp5992_1_prt_2_2_prt_l2"
NOTICE:  CREATE TABLE will create partition "mpp5992_1_prt_2_2_prt_l2_3_prt_ll2" for table "mpp5992_1_prt_2_2_prt_l2"
NOTICE:  CREATE TABLE will create partition "mpp5992_1_prt_2_2_prt_l2_3_prt_ll1_4_prt_lll1" for table "mpp5992_1_prt_2_2_prt_l2_3_prt_ll1"
NOTICE:  CREATE TABLE will create partition "mpp5992_1_prt_2_2_prt_l2_3_prt_ll1_4_prt_lll2" for table "mpp5992_1_prt_2_2_prt_l2_3_prt_ll1"
NOTICE:  CREATE TABLE will create partition "mpp5992_1_prt_2_2_prt_l2_3_prt_ll2_4_prt_lll1" for table "mpp5992_1_prt_2_2_prt_l2_3_prt_ll2"
NOTICE:  CREATE TABLE will create partition "mpp5992_1_prt_2_2_prt_l2_3_prt_ll2_4_prt_lll2" for table "mpp5992_1_prt_2_2_prt_l2_3_prt_ll2"
NOTICE:  CREATE TABLE will create partition "mpp5992_1_prt_3" for table "mpp5992"
NOTICE:  CREATE TABLE will create partition "mpp5992_1_prt_3_2_prt_l1" for table "mpp5992_1_prt_3"
NOTICE:  CREATE TABLE will create partition "mpp5992_1_prt_3_2_prt_l1_3_prt_ll1" for table "mpp5992_1_prt_3_2_prt_l1"
NOTICE:  CREATE TABLE will create partition "mpp5992_1_prt_3_2_prt_l1_3_prt_ll2" for table "mpp5992_1_prt_3_2_prt_l1"
NOTICE:  CREATE TABLE will create partition "mpp5992_1_prt_3_2_prt_l1_3_prt_ll1_4_prt_lll1" for table "mpp5992_1_prt_3_2_prt_l1_3_prt_ll1"
NOTICE:  CREATE TABLE will create partition "mpp5992_1_prt_3_2_prt_l1_3_prt_ll1_4_prt_lll2" for table "mpp5992_1_prt_3_2_prt_l1_3_prt_ll1"
NOTICE:  CREATE TABLE will create partition "mpp5992_1_prt_3_2_prt_l1_3_prt_ll2_4_prt_lll1" for table "mpp5992_1_prt_3_2_prt_l1_3_prt_ll2"
NOTICE:  CREATE TABLE will create partition "mpp5992_1_prt_3_2_prt_l1_3_prt_ll2_4_prt_lll2" for table "mpp5992_1_prt_3_2_prt_l1_3_prt_ll2"
NOTICE:  CREATE TABLE will create partition "mpp5992_1_prt_3_2_prt_l2" for table "mpp5992_1_prt_3"
NOTICE:  CREATE TABLE will create partition "mpp5992_1_prt_3_2_prt_l2_3_prt_ll1" for table "mpp5992_1_prt_3_2_prt_l2"
NOTICE:  CREATE TABLE will create partition "mpp5992_1_prt_3_2_prt_l2_3_prt_ll2" for table "mpp5992_1_prt_3_2_prt_l2"
NOTICE:  CREATE TABLE will create partition "mpp5992_1_prt_3_2_prt_l2_3_prt_ll1_4_prt_lll1" for table "mpp5992_1_prt_3_2_prt_l2_3_prt_ll1"
NOTICE:  CREATE TABLE will create partition "mpp5992_1_prt_3_2_prt_l2_3_prt_ll1_4_prt_lll2" for table "mpp5992_1_prt_3_2_prt_l2_3_prt_ll1"
NOTICE:  CREATE TABLE will create partition "mpp5992_1_prt_3_2_prt_l2_3_prt_ll2_4_prt_lll1" for table "mpp5992_1_prt_3_2_prt_l2_3_prt_ll2"
NOTICE:  CREATE TABLE will create partition "mpp5992_1_prt_3_2_prt_l2_3_prt_ll2_4_prt_lll2" for table "mpp5992_1_prt_3_2_prt_l2_3_prt_ll2"
-- Delete subpartition template
alter table mpp5992 alter partition for ('2008-01-01')
set subpartition template ();
NOTICE:  dropped level 2 subpartition template specification for relation "mpp5992"
alter table mpp5992 alter partition for ('2008-01-01')
alter partition for (1)
set subpartition template ();
NOTICE:  dropped level 3 subpartition template specification for relation "mpp5992"
alter table mpp5992 set subpartition template ();
NOTICE:  dropped level 1 subpartition template specification for relation "mpp5992"
-- Add subpartition template
alter table mpp5992 alter partition for ('2008-01-01')
alter partition for (1)
set subpartition template ( subpartition lll1 values ('M'),
subpartition lll2 values ('F'));
NOTICE:  adding level 3 subpartition template specification for relation "mpp5992"
alter table mpp5992 alter partition for ('2008-01-01')
set subpartition template (
subpartition ll1 values ('Engineering'),
subpartition ll2 values ('QA')
);
NOTICE:  adding level 2 subpartition template specification for relation "mpp5992"
alter table mpp5992 
set subpartition template (subpartition l1 values (1,2,3,4,5), 
subpartition l2 values (6,7,8,9,10) );
NOTICE:  adding level 1 subpartition template specification for relation "mpp5992"
alter table mpp5992 
set subpartition template (subpartition l1 values (1,2,3), 
subpartition l2 values (4,5,6), subpartition l3 values (7,8,9,10));
NOTICE:  replacing level 1 subpartition template specification for relation "mpp5992"
select * from pg_partition_templates where tablename='mpp5992';
 schemaname | tablename | partitionname | partitiontype | partitionlevel | partitionrank | partitionposition |         partitionlistvalues          | partitionrangestart | partitionstartinclusive | partitionrangeend | partitionendinclusive | partitioneveryclause | partitionisdefault |           partitionboundary            
------------+-----------+---------------+---------------+----------------+---------------+-------------------+--------------------------------------+---------------------+-------------------------+-------------------+-----------------------+----------------------+--------------------+----------------------------------------
 public     | mpp5992   | lll1          | list          |              3 |               |                 1 | 'M'::character(1)                    |                     |                         |                   |                       |                      | f                  | SUBPARTITION lll1 VALUES('M')
 public     | mpp5992   | lll2          | list          |              3 |               |                 2 | 'F'::character(1)                    |                     |                         |                   |                       |                      | f                  | SUBPARTITION lll2 VALUES('F')
 public     | mpp5992   | ll1           | list          |              2 |               |                 1 | 'Engineering'::character varying(20) |                     |                         |                   |                       |                      | f                  | SUBPARTITION ll1 VALUES('Engineering')
 public     | mpp5992   | ll2           | list          |              2 |               |                 2 | 'QA'::character varying(20)          |                     |                         |                   |                       |                      | f                  | SUBPARTITION ll2 VALUES('QA')
 public     | mpp5992   | l1            | list          |              1 |               |                 1 | 1, 2, 3                              |                     |                         |                   |                       |                      | f                  | SUBPARTITION l1 VALUES(1, 2, 3)
 public     | mpp5992   | l2            | list          |              1 |               |                 2 | 4, 5, 6                              |                     |                         |                   |                       |                      | f                  | SUBPARTITION l2 VALUES(4, 5, 6)
 public     | mpp5992   | l3            | list          |              1 |               |                 3 | 7, 8, 9, 10                          |                     |                         |                   |                       |                      | f                  | SUBPARTITION l3 VALUES(7, 8, 9, 10)
(7 rows)

-- Now we can add a new partition
alter table mpp5992 
add partition foo1 
start (date '2011-01-01') 
end (date '2012-01-01'); -- should inherit from parent storage option
NOTICE:  CREATE TABLE will create partition "mpp5992_1_prt_foo1" for table "mpp5992"
NOTICE:  CREATE TABLE will create partition "mpp5992_1_prt_foo1_2_prt_l1" for table "mpp5992_1_prt_foo1"
NOTICE:  CREATE TABLE will create partition "mpp5992_1_prt_foo1_2_prt_l1_3_prt_ll1" for table "mpp5992_1_prt_foo1_2_prt_l1"
NOTICE:  CREATE TABLE will create partition "mpp5992_1_prt_foo1_2_prt_l1_3_prt_ll2" for table "mpp5992_1_prt_foo1_2_prt_l1"
NOTICE:  CREATE TABLE will create partition "mpp5992_1_prt_foo1_2_prt_l1_3_prt_ll1_4_prt_lll1" for table "mpp5992_1_prt_foo1_2_prt_l1_3_prt_ll1"
NOTICE:  CREATE TABLE will create partition "mpp5992_1_prt_foo1_2_prt_l1_3_prt_ll1_4_prt_lll2" for table "mpp5992_1_prt_foo1_2_prt_l1_3_prt_ll1"
NOTICE:  CREATE TABLE will create partition "mpp5992_1_prt_foo1_2_prt_l1_3_prt_ll2_4_prt_lll1" for table "mpp5992_1_prt_foo1_2_prt_l1_3_prt_ll2"
NOTICE:  CREATE TABLE will create partition "mpp5992_1_prt_foo1_2_prt_l1_3_prt_ll2_4_prt_lll2" for table "mpp5992_1_prt_foo1_2_prt_l1_3_prt_ll2"
NOTICE:  CREATE TABLE will create partition "mpp5992_1_prt_foo1_2_prt_l2" for table "mpp5992_1_prt_foo1"
NOTICE:  CREATE TABLE will create partition "mpp5992_1_prt_foo1_2_prt_l2_3_prt_ll1" for table "mpp5992_1_prt_foo1_2_prt_l2"
NOTICE:  CREATE TABLE will create partition "mpp5992_1_prt_foo1_2_prt_l2_3_prt_ll2" for table "mpp5992_1_prt_foo1_2_prt_l2"
NOTICE:  CREATE TABLE will create partition "mpp5992_1_prt_foo1_2_prt_l2_3_prt_ll1_4_prt_lll1" for table "mpp5992_1_prt_foo1_2_prt_l2_3_prt_ll1"
NOTICE:  CREATE TABLE will create partition "mpp5992_1_prt_foo1_2_prt_l2_3_prt_ll1_4_prt_lll2" for table "mpp5992_1_prt_foo1_2_prt_l2_3_prt_ll1"
NOTICE:  CREATE TABLE will create partition "mpp5992_1_prt_foo1_2_prt_l2_3_prt_ll2_4_prt_lll1" for table "mpp5992_1_prt_foo1_2_prt_l2_3_prt_ll2"
NOTICE:  CREATE TABLE will create partition "mpp5992_1_prt_foo1_2_prt_l2_3_prt_ll2_4_prt_lll2" for table "mpp5992_1_prt_foo1_2_prt_l2_3_prt_ll2"
NOTICE:  CREATE TABLE will create partition "mpp5992_1_prt_foo1_2_prt_l3" for table "mpp5992_1_prt_foo1"
NOTICE:  CREATE TABLE will create partition "mpp5992_1_prt_foo1_2_prt_l3_3_prt_ll1" for table "mpp5992_1_prt_foo1_2_prt_l3"
NOTICE:  CREATE TABLE will create partition "mpp5992_1_prt_foo1_2_prt_l3_3_prt_ll2" for table "mpp5992_1_prt_foo1_2_prt_l3"
NOTICE:  CREATE TABLE will create partition "mpp5992_1_prt_foo1_2_prt_l3_3_prt_ll1_4_prt_lll1" for table "mpp5992_1_prt_foo1_2_prt_l3_3_prt_ll1"
NOTICE:  CREATE TABLE will create partition "mpp5992_1_prt_foo1_2_prt_l3_3_prt_ll1_4_prt_lll2" for table "mpp5992_1_prt_foo1_2_prt_l3_3_prt_ll1"
NOTICE:  CREATE TABLE will create partition "mpp5992_1_prt_foo1_2_prt_l3_3_prt_ll2_4_prt_lll1" for table "mpp5992_1_prt_foo1_2_prt_l3_3_prt_ll2"
NOTICE:  CREATE TABLE will create partition "mpp5992_1_prt_foo1_2_prt_l3_3_prt_ll2_4_prt_lll2" for table "mpp5992_1_prt_foo1_2_prt_l3_3_prt_ll2"
alter table mpp5992 
add partition foo2 
start (date '2012-01-01') 
end (date '2013-01-01') WITH (orientation=column,appendonly=true);
NOTICE:  CREATE TABLE will create partition "mpp5992_1_prt_foo2" for table "mpp5992"
NOTICE:  CREATE TABLE will create partition "mpp5992_1_prt_foo2_2_prt_l1" for table "mpp5992_1_prt_foo2"
NOTICE:  CREATE TABLE will create partition "mpp5992_1_prt_foo2_2_prt_l1_3_prt_ll1" for table "mpp5992_1_prt_foo2_2_prt_l1"
NOTICE:  CREATE TABLE will create partition "mpp5992_1_prt_foo2_2_prt_l1_3_prt_ll2" for table "mpp5992_1_prt_foo2_2_prt_l1"
NOTICE:  CREATE TABLE will create partition "mpp5992_1_prt_foo2_2_prt_l1_3_prt_ll1_4_prt_lll1" for table "mpp5992_1_prt_foo2_2_prt_l1_3_prt_ll1"
NOTICE:  CREATE TABLE will create partition "mpp5992_1_prt_foo2_2_prt_l1_3_prt_ll1_4_prt_lll2" for table "mpp5992_1_prt_foo2_2_prt_l1_3_prt_ll1"
NOTICE:  CREATE TABLE will create partition "mpp5992_1_prt_foo2_2_prt_l1_3_prt_ll2_4_prt_lll1" for table "mpp5992_1_prt_foo2_2_prt_l1_3_prt_ll2"
NOTICE:  CREATE TABLE will create partition "mpp5992_1_prt_foo2_2_prt_l1_3_prt_ll2_4_prt_lll2" for table "mpp5992_1_prt_foo2_2_prt_l1_3_prt_ll2"
NOTICE:  CREATE TABLE will create partition "mpp5992_1_prt_foo2_2_prt_l2" for table "mpp5992_1_prt_foo2"
NOTICE:  CREATE TABLE will create partition "mpp5992_1_prt_foo2_2_prt_l2_3_prt_ll1" for table "mpp5992_1_prt_foo2_2_prt_l2"
NOTICE:  CREATE TABLE will create partition "mpp5992_1_prt_foo2_2_prt_l2_3_prt_ll2" for table "mpp5992_1_prt_foo2_2_prt_l2"
NOTICE:  CREATE TABLE will create partition "mpp5992_1_prt_foo2_2_prt_l2_3_prt_ll1_4_prt_lll1" for table "mpp5992_1_prt_foo2_2_prt_l2_3_prt_ll1"
NOTICE:  CREATE TABLE will create partition "mpp5992_1_prt_foo2_2_prt_l2_3_prt_ll1_4_prt_lll2" for table "mpp5992_1_prt_foo2_2_prt_l2_3_prt_ll1"
NOTICE:  CREATE TABLE will create partition "mpp5992_1_prt_foo2_2_prt_l2_3_prt_ll2_4_prt_lll1" for table "mpp5992_1_prt_foo2_2_prt_l2_3_prt_ll2"
NOTICE:  CREATE TABLE will create partition "mpp5992_1_prt_foo2_2_prt_l2_3_prt_ll2_4_prt_lll2" for table "mpp5992_1_prt_foo2_2_prt_l2_3_prt_ll2"
NOTICE:  CREATE TABLE will create partition "mpp5992_1_prt_foo2_2_prt_l3" for table "mpp5992_1_prt_foo2"
NOTICE:  CREATE TABLE will create partition "mpp5992_1_prt_foo2_2_prt_l3_3_prt_ll1" for table "mpp5992_1_prt_foo2_2_prt_l3"
NOTICE:  CREATE TABLE will create partition "mpp5992_1_prt_foo2_2_prt_l3_3_prt_ll2" for table "mpp5992_1_prt_foo2_2_prt_l3"
NOTICE:  CREATE TABLE will create partition "mpp5992_1_prt_foo2_2_prt_l3_3_prt_ll1_4_prt_lll1" for table "mpp5992_1_prt_foo2_2_prt_l3_3_prt_ll1"
NOTICE:  CREATE TABLE will create partition "mpp5992_1_prt_foo2_2_prt_l3_3_prt_ll1_4_prt_lll2" for table "mpp5992_1_prt_foo2_2_prt_l3_3_prt_ll1"
NOTICE:  CREATE TABLE will create partition "mpp5992_1_prt_foo2_2_prt_l3_3_prt_ll2_4_prt_lll1" for table "mpp5992_1_prt_foo2_2_prt_l3_3_prt_ll2"
NOTICE:  CREATE TABLE will create partition "mpp5992_1_prt_foo2_2_prt_l3_3_prt_ll2_4_prt_lll2" for table "mpp5992_1_prt_foo2_2_prt_l3_3_prt_ll2"
alter table mpp5992 
add partition foo3 
start (date '2013-01-01') end (date '2014-01-01') WITH (appendonly=true);
NOTICE:  CREATE TABLE will create partition "mpp5992_1_prt_foo3" for table "mpp5992"
NOTICE:  CREATE TABLE will create partition "mpp5992_1_prt_foo3_2_prt_l1" for table "mpp5992_1_prt_foo3"
NOTICE:  CREATE TABLE will create partition "mpp5992_1_prt_foo3_2_prt_l1_3_prt_ll1" for table "mpp5992_1_prt_foo3_2_prt_l1"
NOTICE:  CREATE TABLE will create partition "mpp5992_1_prt_foo3_2_prt_l1_3_prt_ll2" for table "mpp5992_1_prt_foo3_2_prt_l1"
NOTICE:  CREATE TABLE will create partition "mpp5992_1_prt_foo3_2_prt_l1_3_prt_ll1_4_prt_lll1" for table "mpp5992_1_prt_foo3_2_prt_l1_3_prt_ll1"
NOTICE:  CREATE TABLE will create partition "mpp5992_1_prt_foo3_2_prt_l1_3_prt_ll1_4_prt_lll2" for table "mpp5992_1_prt_foo3_2_prt_l1_3_prt_ll1"
NOTICE:  CREATE TABLE will create partition "mpp5992_1_prt_foo3_2_prt_l1_3_prt_ll2_4_prt_lll1" for table "mpp5992_1_prt_foo3_2_prt_l1_3_prt_ll2"
NOTICE:  CREATE TABLE will create partition "mpp5992_1_prt_foo3_2_prt_l1_3_prt_ll2_4_prt_lll2" for table "mpp5992_1_prt_foo3_2_prt_l1_3_prt_ll2"
NOTICE:  CREATE TABLE will create partition "mpp5992_1_prt_foo3_2_prt_l2" for table "mpp5992_1_prt_foo3"
NOTICE:  CREATE TABLE will create partition "mpp5992_1_prt_foo3_2_prt_l2_3_prt_ll1" for table "mpp5992_1_prt_foo3_2_prt_l2"
NOTICE:  CREATE TABLE will create partition "mpp5992_1_prt_foo3_2_prt_l2_3_prt_ll2" for table "mpp5992_1_prt_foo3_2_prt_l2"
NOTICE:  CREATE TABLE will create partition "mpp5992_1_prt_foo3_2_prt_l2_3_prt_ll1_4_prt_lll1" for table "mpp5992_1_prt_foo3_2_prt_l2_3_prt_ll1"
NOTICE:  CREATE TABLE will create partition "mpp5992_1_prt_foo3_2_prt_l2_3_prt_ll1_4_prt_lll2" for table "mpp5992_1_prt_foo3_2_prt_l2_3_prt_ll1"
NOTICE:  CREATE TABLE will create partition "mpp5992_1_prt_foo3_2_prt_l2_3_prt_ll2_4_prt_lll1" for table "mpp5992_1_prt_foo3_2_prt_l2_3_prt_ll2"
NOTICE:  CREATE TABLE will create partition "mpp5992_1_prt_foo3_2_prt_l2_3_prt_ll2_4_prt_lll2" for table "mpp5992_1_prt_foo3_2_prt_l2_3_prt_ll2"
NOTICE:  CREATE TABLE will create partition "mpp5992_1_prt_foo3_2_prt_l3" for table "mpp5992_1_prt_foo3"
NOTICE:  CREATE TABLE will create partition "mpp5992_1_prt_foo3_2_prt_l3_3_prt_ll1" for table "mpp5992_1_prt_foo3_2_prt_l3"
NOTICE:  CREATE TABLE will create partition "mpp5992_1_prt_foo3_2_prt_l3_3_prt_ll2" for table "mpp5992_1_prt_foo3_2_prt_l3"
NOTICE:  CREATE TABLE will create partition "mpp5992_1_prt_foo3_2_prt_l3_3_prt_ll1_4_prt_lll1" for table "mpp5992_1_prt_foo3_2_prt_l3_3_prt_ll1"
NOTICE:  CREATE TABLE will create partition "mpp5992_1_prt_foo3_2_prt_l3_3_prt_ll1_4_prt_lll2" for table "mpp5992_1_prt_foo3_2_prt_l3_3_prt_ll1"
NOTICE:  CREATE TABLE will create partition "mpp5992_1_prt_foo3_2_prt_l3_3_prt_ll2_4_prt_lll1" for table "mpp5992_1_prt_foo3_2_prt_l3_3_prt_ll2"
NOTICE:  CREATE TABLE will create partition "mpp5992_1_prt_foo3_2_prt_l3_3_prt_ll2_4_prt_lll2" for table "mpp5992_1_prt_foo3_2_prt_l3_3_prt_ll2"
select pg_get_partition_def('mpp5992'::regclass,true, true);
                                                                              pg_get_partition_def                                                                              
--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 PARTITION BY RANGE(b)                                                                                                                                                         +
           SUBPARTITION BY LIST(a)                                                                                                                                             +
                   SUBPARTITION BY LIST(e)                                                                                                                                     +
                           SUBPARTITION BY LIST(c)                                                                                                                             +
           (                                                                                                                                                                   +
           START ('01-01-2007'::date) END ('01-01-2008'::date) EVERY ('@ 1 year'::interval) WITH (tablename='mpp5992_1_prt_1', orientation='column', appendonly='true' )       +
                     COLUMN a ENCODING (compresstype=none, blocksize=32768, compresslevel=0)                                                                                   +
                     COLUMN b ENCODING (compresstype=none, blocksize=32768, compresslevel=0)                                                                                   +
                     COLUMN c ENCODING (compresstype=none, blocksize=32768, compresslevel=0)                                                                                   +
                     COLUMN d ENCODING (compresstype=none, blocksize=32768, compresslevel=0)                                                                                   +
                     COLUMN e ENCODING (compresstype=none, blocksize=32768, compresslevel=0)                                                                                   +
                     COLUMN f ENCODING (compresstype=none, blocksize=32768, compresslevel=0)                                                                                   +
                   (                                                                                                                                                           +
                   SUBPARTITION l1 VALUES(1, 2, 3, 4, 5) WITH (tablename='mpp5992_1_prt_1_2_prt_l1', orientation='column', appendonly='true' )                                 +
                             COLUMN a ENCODING (compresstype=none, blocksize=32768, compresslevel=0)                                                                           +
                             COLUMN b ENCODING (compresstype=none, blocksize=32768, compresslevel=0)                                                                           +
                             COLUMN c ENCODING (compresstype=none, blocksize=32768, compresslevel=0)                                                                           +
                             COLUMN d ENCODING (compresstype=none, blocksize=32768, compresslevel=0)                                                                           +
                             COLUMN e ENCODING (compresstype=none, blocksize=32768, compresslevel=0)                                                                           +
                             COLUMN f ENCODING (compresstype=none, blocksize=32768, compresslevel=0)                                                                           +
                           (                                                                                                                                                   +
                           SUBPARTITION ll1 VALUES('Engineering') WITH (tablename='mpp5992_1_prt_1_2_prt_l1_3_prt_ll1', orientation='column', appendonly='true' )              +
                                     COLUMN a ENCODING (compresstype=none, blocksize=32768, compresslevel=0)                                                                   +
                                     COLUMN b ENCODING (compresstype=none, blocksize=32768, compresslevel=0)                                                                   +
                                     COLUMN c ENCODING (compresstype=none, blocksize=32768, compresslevel=0)                                                                   +
                                     COLUMN d ENCODING (compresstype=none, blocksize=32768, compresslevel=0)                                                                   +
                                     COLUMN e ENCODING (compresstype=none, blocksize=32768, compresslevel=0)                                                                   +
                                     COLUMN f ENCODING (compresstype=none, blocksize=32768, compresslevel=0)                                                                   +
                                   (                                                                                                                                           +
                                   SUBPARTITION lll1 VALUES('M') WITH (tablename='mpp5992_1_prt_1_2_prt_l1_3_prt_ll1_4_prt_lll1', orientation='column', appendonly='true' )    +
                                             COLUMN a ENCODING (compresstype=none, blocksize=32768, compresslevel=0)                                                           +
                                             COLUMN b ENCODING (compresstype=none, blocksize=32768, compresslevel=0)                                                           +
                                             COLUMN c ENCODING (compresstype=none, blocksize=32768, compresslevel=0)                                                           +
                                             COLUMN d ENCODING (compresstype=none, blocksize=32768, compresslevel=0)                                                           +
                                             COLUMN e ENCODING (compresstype=none, blocksize=32768, compresslevel=0)                                                           +
                                             COLUMN f ENCODING (compresstype=none, blocksize=32768, compresslevel=0),                                                          +
                                   SUBPARTITION lll2 VALUES('F') WITH (tablename='mpp5992_1_prt_1_2_prt_l1_3_prt_ll1_4_prt_lll2', orientation='column', appendonly='true' )    +
                                             COLUMN a ENCODING (compresstype=none, blocksize=32768, compresslevel=0)                                                           +
                                             COLUMN b ENCODING (compresstype=none, blocksize=32768, compresslevel=0)                                                           +
                                             COLUMN c ENCODING (compresstype=none, blocksize=32768, compresslevel=0)                                                           +
                                             COLUMN d ENCODING (compresstype=none, blocksize=32768, compresslevel=0)                                                           +
                                             COLUMN e ENCODING (compresstype=none, blocksize=32768, compresslevel=0)                                                           +
                                             COLUMN f ENCODING (compresstype=none, blocksize=32768, compresslevel=0)                                                           +
                                   ),                                                                                                                                          +
                           SUBPARTITION ll2 VALUES('QA') WITH (tablename='mpp5992_1_prt_1_2_prt_l1_3_prt_ll2', orientation='column', appendonly='true' )                       +
                                     COLUMN a ENCODING (compresstype=none, blocksize=32768, compresslevel=0)                                                                   +
                                     COLUMN b ENCODING (compresstype=none, blocksize=32768, compresslevel=0)                                                                   +
                                     COLUMN c ENCODING (compresstype=none, blocksize=32768, compresslevel=0)                                                                   +
                                     COLUMN d ENCODING (compresstype=none, blocksize=32768, compresslevel=0)                                                                   +
                                     COLUMN e ENCODING (compresstype=none, blocksize=32768, compresslevel=0)                                                                   +
                                     COLUMN f ENCODING (compresstype=none, blocksize=32768, compresslevel=0)                                                                   +
                                   (                                                                                                                                           +
                                   SUBPARTITION lll1 VALUES('M') WITH (tablename='mpp5992_1_prt_1_2_prt_l1_3_prt_ll2_4_prt_lll1', orientation='column', appendonly='true' )    +
                                             COLUMN a ENCODING (compresstype=none, blocksize=32768, compresslevel=0)                                                           +
                                             COLUMN b ENCODING (compresstype=none, blocksize=32768, compresslevel=0)                                                           +
                                             COLUMN c ENCODING (compresstype=none, blocksize=32768, compresslevel=0)                                                           +
                                             COLUMN d ENCODING (compresstype=none, blocksize=32768, compresslevel=0)                                                           +
                                             COLUMN e ENCODING (compresstype=none, blocksize=32768, compresslevel=0)                                                           +
                                             COLUMN f ENCODING (compresstype=none, blocksize=32768, compresslevel=0),                                                          +
                                   SUBPARTITION lll2 VALUES('F') WITH (tablename='mpp5992_1_prt_1_2_prt_l1_3_prt_ll2_4_prt_lll2', orientation='column', appendonly='true' )    +
                                             COLUMN a ENCODING (compresstype=none, blocksize=32768, compresslevel=0)                                                           +
                                             COLUMN b ENCODING (compresstype=none, blocksize=32768, compresslevel=0)                                                           +
                                             COLUMN c ENCODING (compresstype=none, blocksize=32768, compresslevel=0)                                                           +
                                             COLUMN d ENCODING (compresstype=none, blocksize=32768, compresslevel=0)                                                           +
                                             COLUMN e ENCODING (compresstype=none, blocksize=32768, compresslevel=0)                                                           +
                                             COLUMN f ENCODING (compresstype=none, blocksize=32768, compresslevel=0)                                                           +
                                   )                                                                                                                                           +
                           ),                                                                                                                                                  +
                   SUBPARTITION l2 VALUES(6, 7, 8, 9, 10) WITH (tablename='mpp5992_1_prt_1_2_prt_l2', orientation='column', appendonly='true' )                                +
                             COLUMN a ENCODING (compresstype=none, blocksize=32768, compresslevel=0)                                                                           +
                             COLUMN b ENCODING (compresstype=none, blocksize=32768, compresslevel=0)                                                                           +
                             COLUMN c ENCODING (compresstype=none, blocksize=32768, compresslevel=0)                                                                           +
                             COLUMN d ENCODING (compresstype=none, blocksize=32768, compresslevel=0)                                                                           +
                             COLUMN e ENCODING (compresstype=none, blocksize=32768, compresslevel=0)                                                                           +
                             COLUMN f ENCODING (compresstype=none, blocksize=32768, compresslevel=0)                                                                           +
                           (                                                                                                                                                   +
                           SUBPARTITION ll1 VALUES('Engineering') WITH (tablename='mpp5992_1_prt_1_2_prt_l2_3_prt_ll1', orientation='column', appendonly='true' )              +
                                     COLUMN a ENCODING (compresstype=none, blocksize=32768, compresslevel=0)                                                                   +
                                     COLUMN b ENCODING (compresstype=none, blocksize=32768, compresslevel=0)                                                                   +
                                     COLUMN c ENCODING (compresstype=none, blocksize=32768, compresslevel=0)                                                                   +
                                     COLUMN d ENCODING (compresstype=none, blocksize=32768, compresslevel=0)                                                                   +
                                     COLUMN e ENCODING (compresstype=none, blocksize=32768, compresslevel=0)                                                                   +
                                     COLUMN f ENCODING (compresstype=none, blocksize=32768, compresslevel=0)                                                                   +
                                   (                                                                                                                                           +
                                   SUBPARTITION lll1 VALUES('M') WITH (tablename='mpp5992_1_prt_1_2_prt_l2_3_prt_ll1_4_prt_lll1', orientation='column', appendonly='true' )    +
                                             COLUMN a ENCODING (compresstype=none, blocksize=32768, compresslevel=0)                                                           +
                                             COLUMN b ENCODING (compresstype=none, blocksize=32768, compresslevel=0)                                                           +
                                             COLUMN c ENCODING (compresstype=none, blocksize=32768, compresslevel=0)                                                           +
                                             COLUMN d ENCODING (compresstype=none, blocksize=32768, compresslevel=0)                                                           +
                                             COLUMN e ENCODING (compresstype=none, blocksize=32768, compresslevel=0)                                                           +
                                             COLUMN f ENCODING (compresstype=none, blocksize=32768, compresslevel=0),                                                          +
                                   SUBPARTITION lll2 VALUES('F') WITH (tablename='mpp5992_1_prt_1_2_prt_l2_3_prt_ll1_4_prt_lll2', orientation='column', appendonly='true' )    +
                                             COLUMN a ENCODING (compresstype=none, blocksize=32768, compresslevel=0)                                                           +
                                             COLUMN b ENCODING (compresstype=none, blocksize=32768, compresslevel=0)                                                           +
                                             COLUMN c ENCODING (compresstype=none, blocksize=32768, compresslevel=0)                                                           +
                                             COLUMN d ENCODING (compresstype=none, blocksize=32768, compresslevel=0)                                                           +
                                             COLUMN e ENCODING (compresstype=none, blocksize=32768, compresslevel=0)                                                           +
                                             COLUMN f ENCODING (compresstype=none, blocksize=32768, compresslevel=0)                                                           +
                                   ),                                                                                                                                          +
                           SUBPARTITION ll2 VALUES('QA') WITH (tablename='mpp5992_1_prt_1_2_prt_l2_3_prt_ll2', orientation='column', appendonly='true' )                       +
                                     COLUMN a ENCODING (compresstype=none, blocksize=32768, compresslevel=0)                                                                   +
                                     COLUMN b ENCODING (compresstype=none, blocksize=32768, compresslevel=0)                                                                   +
                                     COLUMN c ENCODING (compresstype=none, blocksize=32768, compresslevel=0)                                                                   +
                                     COLUMN d ENCODING (compresstype=none, blocksize=32768, compresslevel=0)                                                                   +
                                     COLUMN e ENCODING (compresstype=none, blocksize=32768, compresslevel=0)                                                                   +
                                     COLUMN f ENCODING (compresstype=none, blocksize=32768, compresslevel=0)                                                                   +
                                   (                                                                                                                                           +
                                   SUBPARTITION lll1 VALUES('M') WITH (tablename='mpp5992_1_prt_1_2_prt_l2_3_prt_ll2_4_prt_lll1', orientation='column', appendonly='true' )    +
                                             COLUMN a ENCODING (compresstype=none, blocksize=32768, compresslevel=0)                                                           +
                                             COLUMN b ENCODING (compresstype=none, blocksize=32768, compresslevel=0)                                                           +
                                             COLUMN c ENCODING (compresstype=none, blocksize=32768, compresslevel=0)                                                           +
                                             COLUMN d ENCODING (compresstype=none, blocksize=32768, compresslevel=0)                                                           +
                                             COLUMN e ENCODING (compresstype=none, blocksize=32768, compresslevel=0)                                                           +
                                             COLUMN f ENCODING (compresstype=none, blocksize=32768, compresslevel=0),                                                          +
                                   SUBPARTITION lll2 VALUES('F') WITH (tablename='mpp5992_1_prt_1_2_prt_l2_3_prt_ll2_4_prt_lll2', orientation='column', appendonly='true' )    +
                                             COLUMN a ENCODING (compresstype=none, blocksize=32768, compresslevel=0)                                                           +
                                             COLUMN b ENCODING (compresstype=none, blocksize=32768, compresslevel=0)                                                           +
                                             COLUMN c ENCODING (compresstype=none, blocksize=32768, compresslevel=0)                                                           +
                                             COLUMN d ENCODING (compresstype=none, blocksize=32768, compresslevel=0)                                                           +
                                             COLUMN e ENCODING (compresstype=none, blocksize=32768, compresslevel=0)                                                           +
                                             COLUMN f ENCODING (compresstype=none, blocksize=32768, compresslevel=0)                                                           +
                                   )                                                                                                                                           +
                           )                                                                                                                                                   +
                   ),                                                                                                                                                          +
           START ('01-01-2008'::date) END ('01-01-2009'::date) EVERY ('@ 1 year'::interval) WITH (tablename='mpp5992_1_prt_2', orientation='column', appendonly='true' )       +
                     COLUMN a ENCODING (compresstype=none, blocksize=32768, compresslevel=0)                                                                                   +
                     COLUMN b ENCODING (compresstype=none, blocksize=32768, compresslevel=0)                                                                                   +
                     COLUMN c ENCODING (compresstype=none, blocksize=32768, compresslevel=0)                                                                                   +
                     COLUMN d ENCODING (compresstype=none, blocksize=32768, compresslevel=0)                                                                                   +
                     COLUMN e ENCODING (compresstype=none, blocksize=32768, compresslevel=0)                                                                                   +
                     COLUMN f ENCODING (compresstype=none, blocksize=32768, compresslevel=0)                                                                                   +
                   (                                                                                                                                                           +
                   SUBPARTITION l1 VALUES(1, 2, 3, 4, 5) WITH (tablename='mpp5992_1_prt_2_2_prt_l1', orientation='column', appendonly='true' )                                 +
                             COLUMN a ENCODING (compresstype=none, blocksize=32768, compresslevel=0)                                                                           +
                             COLUMN b ENCODING (compresstype=none, blocksize=32768, compresslevel=0)                                                                           +
                             COLUMN c ENCODING (compresstype=none, blocksize=32768, compresslevel=0)                                                                           +
                             COLUMN d ENCODING (compresstype=none, blocksize=32768, compresslevel=0)                                                                           +
                             COLUMN e ENCODING (compresstype=none, blocksize=32768, compresslevel=0)                                                                           +
                             COLUMN f ENCODING (compresstype=none, blocksize=32768, compresslevel=0)                                                                           +
                           (                                                                                                                                                   +
                           SUBPARTITION ll1 VALUES('Engineering') WITH (tablename='mpp5992_1_prt_2_2_prt_l1_3_prt_ll1', orientation='column', appendonly='true' )              +
                                     COLUMN a ENCODING (compresstype=none, blocksize=32768, compresslevel=0)                                                                   +
                                     COLUMN b ENCODING (compresstype=none, blocksize=32768, compresslevel=0)                                                                   +
                                     COLUMN c ENCODING (compresstype=none, blocksize=32768, compresslevel=0)                                                                   +
                                     COLUMN d ENCODING (compresstype=none, blocksize=32768, compresslevel=0)                                                                   +
                                     COLUMN e ENCODING (compresstype=none, blocksize=32768, compresslevel=0)                                                                   +
                                     COLUMN f ENCODING (compresstype=none, blocksize=32768, compresslevel=0)                                                                   +
                                   (                                                                                                                                           +
                                   SUBPARTITION lll1 VALUES('M') WITH (tablename='mpp5992_1_prt_2_2_prt_l1_3_prt_ll1_4_prt_lll1', orientation='column', appendonly='true' )    +
                                             COLUMN a ENCODING (compresstype=none, blocksize=32768, compresslevel=0)                                                           +
                                             COLUMN b ENCODING (compresstype=none, blocksize=32768, compresslevel=0)                                                           +
                                             COLUMN c ENCODING (compresstype=none, blocksize=32768, compresslevel=0)                                                           +
                                             COLUMN d ENCODING (compresstype=none, blocksize=32768, compresslevel=0)                                                           +
                                             COLUMN e ENCODING (compresstype=none, blocksize=32768, compresslevel=0)                                                           +
                                             COLUMN f ENCODING (compresstype=none, blocksize=32768, compresslevel=0),                                                          +
                                   SUBPARTITION lll2 VALUES('F') WITH (tablename='mpp5992_1_prt_2_2_prt_l1_3_prt_ll1_4_prt_lll2', orientation='column', appendonly='true' )    +
                                             COLUMN a ENCODING (compresstype=none, blocksize=32768, compresslevel=0)                                                           +
                                             COLUMN b ENCODING (compresstype=none, blocksize=32768, compresslevel=0)                                                           +
                                             COLUMN c ENCODING (compresstype=none, blocksize=32768, compresslevel=0)                                                           +
                                             COLUMN d ENCODING (compresstype=none, blocksize=32768, compresslevel=0)                                                           +
                                             COLUMN e ENCODING (compresstype=none, blocksize=32768, compresslevel=0)                                                           +
                                             COLUMN f ENCODING (compresstype=none, blocksize=32768, compresslevel=0)                                                           +
                                   ),                                                                                                                                          +
                           SUBPARTITION ll2 VALUES('QA') WITH (tablename='mpp5992_1_prt_2_2_prt_l1_3_prt_ll2', orientation='column', appendonly='true' )                       +
                                     COLUMN a ENCODING (compresstype=none, blocksize=32768, compresslevel=0)                                                                   +
                                     COLUMN b ENCODING (compresstype=none, blocksize=32768, compresslevel=0)                                                                   +
                                     COLUMN c ENCODING (compresstype=none, blocksize=32768, compresslevel=0)                                                                   +
                                     COLUMN d ENCODING (compresstype=none, blocksize=32768, compresslevel=0)                                                                   +
                                     COLUMN e ENCODING (compresstype=none, blocksize=32768, compresslevel=0)                                                                   +
                                     COLUMN f ENCODING (compresstype=none, blocksize=32768, compresslevel=0)                                                                   +
                                   (                                                                                                                                           +
                                   SUBPARTITION lll1 VALUES('M') WITH (tablename='mpp5992_1_prt_2_2_prt_l1_3_prt_ll2_4_prt_lll1', orientation='column', appendonly='true' )    +
                                             COLUMN a ENCODING (compresstype=none, blocksize=32768, compresslevel=0)                                                           +
                                             COLUMN b ENCODING (compresstype=none, blocksize=32768, compresslevel=0)                                                           +
                                             COLUMN c ENCODING (compresstype=none, blocksize=32768, compresslevel=0)                                                           +
                                             COLUMN d ENCODING (compresstype=none, blocksize=32768, compresslevel=0)                                                           +
                                             COLUMN e ENCODING (compresstype=none, blocksize=32768, compresslevel=0)                                                           +
                                             COLUMN f ENCODING (compresstype=none, blocksize=32768, compresslevel=0),                                                          +
                                   SUBPARTITION lll2 VALUES('F') WITH (tablename='mpp5992_1_prt_2_2_prt_l1_3_prt_ll2_4_prt_lll2', orientation='column', appendonly='true' )    +
                                             COLUMN a ENCODING (compresstype=none, blocksize=32768, compresslevel=0)                                                           +
                                             COLUMN b ENCODING (compresstype=none, blocksize=32768, compresslevel=0)                                                           +
                                             COLUMN c ENCODING (compresstype=none, blocksize=32768, compresslevel=0)                                                           +
                                             COLUMN d ENCODING (compresstype=none, blocksize=32768, compresslevel=0)                                                           +
                                             COLUMN e ENCODING (compresstype=none, blocksize=32768, compresslevel=0)                                                           +
                                             COLUMN f ENCODING (compresstype=none, blocksize=32768, compresslevel=0)                                                           +
                                   )                                                                                                                                           +
                           ),                                                                                                                                                  +
                   SUBPARTITION l2 VALUES(6, 7, 8, 9, 10) WITH (tablename='mpp5992_1_prt_2_2_prt_l2', orientation='column', appendonly='true' )                                +
                             COLUMN a ENCODING (compresstype=none, blocksize=32768, compresslevel=0)                                                                           +
                             COLUMN b ENCODING (compresstype=none, blocksize=32768, compresslevel=0)                                                                           +
                             COLUMN c ENCODING (compresstype=none, blocksize=32768, compresslevel=0)                                                                           +
                             COLUMN d ENCODING (compresstype=none, blocksize=32768, compresslevel=0)                                                                           +
                             COLUMN e ENCODING (compresstype=none, blocksize=32768, compresslevel=0)                                                                           +
                             COLUMN f ENCODING (compresstype=none, blocksize=32768, compresslevel=0)                                                                           +
                           (                                                                                                                                                   +
                           SUBPARTITION ll1 VALUES('Engineering') WITH (tablename='mpp5992_1_prt_2_2_prt_l2_3_prt_ll1', orientation='column', appendonly='true' )              +
                                     COLUMN a ENCODING (compresstype=none, blocksize=32768, compresslevel=0)                                                                   +
                                     COLUMN b ENCODING (compresstype=none, blocksize=32768, compresslevel=0)                                                                   +
                                     COLUMN c ENCODING (compresstype=none, blocksize=32768, compresslevel=0)                                                                   +
                                     COLUMN d ENCODING (compresstype=none, blocksize=32768, compresslevel=0)                                                                   +
                                     COLUMN e ENCODING (compresstype=none, blocksize=32768, compresslevel=0)                                                                   +
                                     COLUMN f ENCODING (compresstype=none, blocksize=32768, compresslevel=0)                                                                   +
                                   (                                                                                                                                           +
                                   SUBPARTITION lll1 VALUES('M') WITH (tablename='mpp5992_1_prt_2_2_prt_l2_3_prt_ll1_4_prt_lll1', orientation='column', appendonly='true' )    +
                                             COLUMN a ENCODING (compresstype=none, blocksize=32768, compresslevel=0)                                                           +
                                             COLUMN b ENCODING (compresstype=none, blocksize=32768, compresslevel=0)                                                           +
                                             COLUMN c ENCODING (compresstype=none, blocksize=32768, compresslevel=0)                                                           +
                                             COLUMN d ENCODING (compresstype=none, blocksize=32768, compresslevel=0)                                                           +
                                             COLUMN e ENCODING (compresstype=none, blocksize=32768, compresslevel=0)                                                           +
                                             COLUMN f ENCODING (compresstype=none, blocksize=32768, compresslevel=0),                                                          +
                                   SUBPARTITION lll2 VALUES('F') WITH (tablename='mpp5992_1_prt_2_2_prt_l2_3_prt_ll1_4_prt_lll2', orientation='column', appendonly='true' )    +
                                             COLUMN a ENCODING (compresstype=none, blocksize=32768, compresslevel=0)                                                           +
                                             COLUMN b ENCODING (compresstype=none, blocksize=32768, compresslevel=0)                                                           +
                                             COLUMN c ENCODING (compresstype=none, blocksize=32768, compresslevel=0)                                                           +
                                             COLUMN d ENCODING (compresstype=none, blocksize=32768, compresslevel=0)                                                           +
                                             COLUMN e ENCODING (compresstype=none, blocksize=32768, compresslevel=0)                                                           +
                                             COLUMN f ENCODING (compresstype=none, blocksize=32768, compresslevel=0)                                                           +
                                   ),                                                                                                                                          +
                           SUBPARTITION ll2 VALUES('QA') WITH (tablename='mpp5992_1_prt_2_2_prt_l2_3_prt_ll2', orientation='column', appendonly='true' )                       +
                                     COLUMN a ENCODING (compresstype=none, blocksize=32768, compresslevel=0)                                                                   +
                                     COLUMN b ENCODING (compresstype=none, blocksize=32768, compresslevel=0)                                                                   +
                                     COLUMN c ENCODING (compresstype=none, blocksize=32768, compresslevel=0)                                                                   +
                                     COLUMN d ENCODING (compresstype=none, blocksize=32768, compresslevel=0)                                                                   +
                                     COLUMN e ENCODING (compresstype=none, blocksize=32768, compresslevel=0)                                                                   +
                                     COLUMN f ENCODING (compresstype=none, blocksize=32768, compresslevel=0)                                                                   +
                                   (                                                                                                                                           +
                                   SUBPARTITION lll1 VALUES('M') WITH (tablename='mpp5992_1_prt_2_2_prt_l2_3_prt_ll2_4_prt_lll1', orientation='column', appendonly='true' )    +
                                             COLUMN a ENCODING (compresstype=none, blocksize=32768, compresslevel=0)                                                           +
                                             COLUMN b ENCODING (compresstype=none, blocksize=32768, compresslevel=0)                                                           +
                                             COLUMN c ENCODING (compresstype=none, blocksize=32768, compresslevel=0)                                                           +
                                             COLUMN d ENCODING (compresstype=none, blocksize=32768, compresslevel=0)                                                           +
                                             COLUMN e ENCODING (compresstype=none, blocksize=32768, compresslevel=0)                                                           +
                                             COLUMN f ENCODING (compresstype=none, blocksize=32768, compresslevel=0),                                                          +
                                   SUBPARTITION lll2 VALUES('F') WITH (tablename='mpp5992_1_prt_2_2_prt_l2_3_prt_ll2_4_prt_lll2', orientation='column', appendonly='true' )    +
                                             COLUMN a ENCODING (compresstype=none, blocksize=32768, compresslevel=0)                                                           +
                                             COLUMN b ENCODING (compresstype=none, blocksize=32768, compresslevel=0)                                                           +
                                             COLUMN c ENCODING (compresstype=none, blocksize=32768, compresslevel=0)                                                           +
                                             COLUMN d ENCODING (compresstype=none, blocksize=32768, compresslevel=0)                                                           +
                                             COLUMN e ENCODING (compresstype=none, blocksize=32768, compresslevel=0)                                                           +
                                             COLUMN f ENCODING (compresstype=none, blocksize=32768, compresslevel=0)                                                           +
                                   )                                                                                                                                           +
                           )                                                                                                                                                   +
                   ),                                                                                                                                                          +
           START ('01-01-2009'::date) END ('01-01-2010'::date) EVERY ('@ 1 year'::interval) WITH (tablename='mpp5992_1_prt_3', orientation='column', appendonly='true' )       +
                     COLUMN a ENCODING (compresstype=none, blocksize=32768, compresslevel=0)                                                                                   +
                     COLUMN b ENCODING (compresstype=none, blocksize=32768, compresslevel=0)                                                                                   +
                     COLUMN c ENCODING (compresstype=none, blocksize=32768, compresslevel=0)                                                                                   +
                     COLUMN d ENCODING (compresstype=none, blocksize=32768, compresslevel=0)                                                                                   +
                     COLUMN e ENCODING (compresstype=none, blocksize=32768, compresslevel=0)                                                                                   +
                     COLUMN f ENCODING (compresstype=none, blocksize=32768, compresslevel=0)                                                                                   +
                   (                                                                                                                                                           +
                   SUBPARTITION l1 VALUES(1, 2, 3, 4, 5) WITH (tablename='mpp5992_1_prt_3_2_prt_l1', orientation='column', appendonly='true' )                                 +
                             COLUMN a ENCODING (compresstype=none, blocksize=32768, compresslevel=0)                                                                           +
                             COLUMN b ENCODING (compresstype=none, blocksize=32768, compresslevel=0)                                                                           +
                             COLUMN c ENCODING (compresstype=none, blocksize=32768, compresslevel=0)                                                                           +
                             COLUMN d ENCODING (compresstype=none, blocksize=32768, compresslevel=0)                                                                           +
                             COLUMN e ENCODING (compresstype=none, blocksize=32768, compresslevel=0)                                                                           +
                             COLUMN f ENCODING (compresstype=none, blocksize=32768, compresslevel=0)                                                                           +
                           (                                                                                                                                                   +
                           SUBPARTITION ll1 VALUES('Engineering') WITH (tablename='mpp5992_1_prt_3_2_prt_l1_3_prt_ll1', orientation='column', appendonly='true' )              +
                                     COLUMN a ENCODING (compresstype=none, blocksize=32768, compresslevel=0)                                                                   +
                                     COLUMN b ENCODING (compresstype=none, blocksize=32768, compresslevel=0)                                                                   +
                                     COLUMN c ENCODING (compresstype=none, blocksize=32768, compresslevel=0)                                                                   +
                                     COLUMN d ENCODING (compresstype=none, blocksize=32768, compresslevel=0)                                                                   +
                                     COLUMN e ENCODING (compresstype=none, blocksize=32768, compresslevel=0)                                                                   +
                                     COLUMN f ENCODING (compresstype=none, blocksize=32768, compresslevel=0)                                                                   +
                                   (                                                                                                                                           +
                                   SUBPARTITION lll1 VALUES('M') WITH (tablename='mpp5992_1_prt_3_2_prt_l1_3_prt_ll1_4_prt_lll1', orientation='column', appendonly='true' )    +
                                             COLUMN a ENCODING (compresstype=none, blocksize=32768, compresslevel=0)                                                           +
                                             COLUMN b ENCODING (compresstype=none, blocksize=32768, compresslevel=0)                                                           +
                                             COLUMN c ENCODING (compresstype=none, blocksize=32768, compresslevel=0)                                                           +
                                             COLUMN d ENCODING (compresstype=none, blocksize=32768, compresslevel=0)                                                           +
                                             COLUMN e ENCODING (compresstype=none, blocksize=32768, compresslevel=0)                                                           +
                                             COLUMN f ENCODING (compresstype=none, blocksize=32768, compresslevel=0),                                                          +
                                   SUBPARTITION lll2 VALUES('F') WITH (tablename='mpp5992_1_prt_3_2_prt_l1_3_prt_ll1_4_prt_lll2', orientation='column', appendonly='true' )    +
                                             COLUMN a ENCODING (compresstype=none, blocksize=32768, compresslevel=0)                                                           +
                                             COLUMN b ENCODING (compresstype=none, blocksize=32768, compresslevel=0)                                                           +
                                             COLUMN c ENCODING (compresstype=none, blocksize=32768, compresslevel=0)                                                           +
                                             COLUMN d ENCODING (compresstype=none, blocksize=32768, compresslevel=0)                                                           +
                                             COLUMN e ENCODING (compresstype=none, blocksize=32768, compresslevel=0)                                                           +
                                             COLUMN f ENCODING (compresstype=none, blocksize=32768, compresslevel=0)                                                           +
                                   ),                                                                                                                                          +
                           SUBPARTITION ll2 VALUES('QA') WITH (tablename='mpp5992_1_prt_3_2_prt_l1_3_prt_ll2', orientation='column', appendonly='true' )                       +
                                     COLUMN a ENCODING (compresstype=none, blocksize=32768, compresslevel=0)                                                                   +
                                     COLUMN b ENCODING (compresstype=none, blocksize=32768, compresslevel=0)                                                                   +
                                     COLUMN c ENCODING (compresstype=none, blocksize=32768, compresslevel=0)                                                                   +
                                     COLUMN d ENCODING (compresstype=none, blocksize=32768, compresslevel=0)                                                                   +
                                     COLUMN e ENCODING (compresstype=none, blocksize=32768, compresslevel=0)                                                                   +
                                     COLUMN f ENCODING (compresstype=none, blocksize=32768, compresslevel=0)                                                                   +
                                   (                                                                                                                                           +
                                   SUBPARTITION lll1 VALUES('M') WITH (tablename='mpp5992_1_prt_3_2_prt_l1_3_prt_ll2_4_prt_lll1', orientation='column', appendonly='true' )    +
                                             COLUMN a ENCODING (compresstype=none, blocksize=32768, compresslevel=0)                                                           +
                                             COLUMN b ENCODING (compresstype=none, blocksize=32768, compresslevel=0)                                                           +
                                             COLUMN c ENCODING (compresstype=none, blocksize=32768, compresslevel=0)                                                           +
                                             COLUMN d ENCODING (compresstype=none, blocksize=32768, compresslevel=0)                                                           +
                                             COLUMN e ENCODING (compresstype=none, blocksize=32768, compresslevel=0)                                                           +
                                             COLUMN f ENCODING (compresstype=none, blocksize=32768, compresslevel=0),                                                          +
                                   SUBPARTITION lll2 VALUES('F') WITH (tablename='mpp5992_1_prt_3_2_prt_l1_3_prt_ll2_4_prt_lll2', orientation='column', appendonly='true' )    +
                                             COLUMN a ENCODING (compresstype=none, blocksize=32768, compresslevel=0)                                                           +
                                             COLUMN b ENCODING (compresstype=none, blocksize=32768, compresslevel=0)                                                           +
                                             COLUMN c ENCODING (compresstype=none, blocksize=32768, compresslevel=0)                                                           +
                                             COLUMN d ENCODING (compresstype=none, blocksize=32768, compresslevel=0)                                                           +
                                             COLUMN e ENCODING (compresstype=none, blocksize=32768, compresslevel=0)                                                           +
                                             COLUMN f ENCODING (compresstype=none, blocksize=32768, compresslevel=0)                                                           +
                                   )                                                                                                                                           +
                           ),                                                                                                                                                  +
                   SUBPARTITION l2 VALUES(6, 7, 8, 9, 10) WITH (tablename='mpp5992_1_prt_3_2_prt_l2', orientation='column', appendonly='true' )                                +
                             COLUMN a ENCODING (compresstype=none, blocksize=32768, compresslevel=0)                                                                           +
                             COLUMN b ENCODING (compresstype=none, blocksize=32768, compresslevel=0)                                                                           +
                             COLUMN c ENCODING (compresstype=none, blocksize=32768, compresslevel=0)                                                                           +
                             COLUMN d ENCODING (compresstype=none, blocksize=32768, compresslevel=0)                                                                           +
                             COLUMN e ENCODING (compresstype=none, blocksize=32768, compresslevel=0)                                                                           +
                             COLUMN f ENCODING (compresstype=none, blocksize=32768, compresslevel=0)                                                                           +
                           (                                                                                                                                                   +
                           SUBPARTITION ll1 VALUES('Engineering') WITH (tablename='mpp5992_1_prt_3_2_prt_l2_3_prt_ll1', orientation='column', appendonly='true' )              +
                                     COLUMN a ENCODING (compresstype=none, blocksize=32768, compresslevel=0)                                                                   +
                                     COLUMN b ENCODING (compresstype=none, blocksize=32768, compresslevel=0)                                                                   +
                                     COLUMN c ENCODING (compresstype=none, blocksize=32768, compresslevel=0)                                                                   +
                                     COLUMN d ENCODING (compresstype=none, blocksize=32768, compresslevel=0)                                                                   +
                                     COLUMN e ENCODING (compresstype=none, blocksize=32768, compresslevel=0)                                                                   +
                                     COLUMN f ENCODING (compresstype=none, blocksize=32768, compresslevel=0)                                                                   +
                                   (                                                                                                                                           +
                                   SUBPARTITION lll1 VALUES('M') WITH (tablename='mpp5992_1_prt_3_2_prt_l2_3_prt_ll1_4_prt_lll1', orientation='column', appendonly='true' )    +
                                             COLUMN a ENCODING (compresstype=none, blocksize=32768, compresslevel=0)                                                           +
                                             COLUMN b ENCODING (compresstype=none, blocksize=32768, compresslevel=0)                                                           +
                                             COLUMN c ENCODING (compresstype=none, blocksize=32768, compresslevel=0)                                                           +
                                             COLUMN d ENCODING (compresstype=none, blocksize=32768, compresslevel=0)                                                           +
                                             COLUMN e ENCODING (compresstype=none, blocksize=32768, compresslevel=0)                                                           +
                                             COLUMN f ENCODING (compresstype=none, blocksize=32768, compresslevel=0),                                                          +
                                   SUBPARTITION lll2 VALUES('F') WITH (tablename='mpp5992_1_prt_3_2_prt_l2_3_prt_ll1_4_prt_lll2', orientation='column', appendonly='true' )    +
                                             COLUMN a ENCODING (compresstype=none, blocksize=32768, compresslevel=0)                                                           +
                                             COLUMN b ENCODING (compresstype=none, blocksize=32768, compresslevel=0)                                                           +
                                             COLUMN c ENCODING (compresstype=none, blocksize=32768, compresslevel=0)                                                           +
                                             COLUMN d ENCODING (compresstype=none, blocksize=32768, compresslevel=0)                                                           +
                                             COLUMN e ENCODING (compresstype=none, blocksize=32768, compresslevel=0)                                                           +
                                             COLUMN f ENCODING (compresstype=none, blocksize=32768, compresslevel=0)                                                           +
                                   ),                                                                                                                                          +
                           SUBPARTITION ll2 VALUES('QA') WITH (tablename='mpp5992_1_prt_3_2_prt_l2_3_prt_ll2', orientation='column', appendonly='true' )                       +
                                     COLUMN a ENCODING (compresstype=none, blocksize=32768, compresslevel=0)                                                                   +
                                     COLUMN b ENCODING (compresstype=none, blocksize=32768, compresslevel=0)                                                                   +
                                     COLUMN c ENCODING (compresstype=none, blocksize=32768, compresslevel=0)                                                                   +
                                     COLUMN d ENCODING (compresstype=none, blocksize=32768, compresslevel=0)                                                                   +
                                     COLUMN e ENCODING (compresstype=none, blocksize=32768, compresslevel=0)                                                                   +
                                     COLUMN f ENCODING (compresstype=none, blocksize=32768, compresslevel=0)                                                                   +
                                   (                                                                                                                                           +
                                   SUBPARTITION lll1 VALUES('M') WITH (tablename='mpp5992_1_prt_3_2_prt_l2_3_prt_ll2_4_prt_lll1', orientation='column', appendonly='true' )    +
                                             COLUMN a ENCODING (compresstype=none, blocksize=32768, compresslevel=0)                                                           +
                                             COLUMN b ENCODING (compresstype=none, blocksize=32768, compresslevel=0)                                                           +
                                             COLUMN c ENCODING (compresstype=none, blocksize=32768, compresslevel=0)                                                           +
                                             COLUMN d ENCODING (compresstype=none, blocksize=32768, compresslevel=0)                                                           +
                                             COLUMN e ENCODING (compresstype=none, blocksize=32768, compresslevel=0)                                                           +
                                             COLUMN f ENCODING (compresstype=none, blocksize=32768, compresslevel=0),                                                          +
                                   SUBPARTITION lll2 VALUES('F') WITH (tablename='mpp5992_1_prt_3_2_prt_l2_3_prt_ll2_4_prt_lll2', orientation='column', appendonly='true' )    +
                                             COLUMN a ENCODING (compresstype=none, blocksize=32768, compresslevel=0)                                                           +
                                             COLUMN b ENCODING (compresstype=none, blocksize=32768, compresslevel=0)                                                           +
                                             COLUMN c ENCODING (compresstype=none, blocksize=32768, compresslevel=0)                                                           +
                                             COLUMN d ENCODING (compresstype=none, blocksize=32768, compresslevel=0)                                                           +
                                             COLUMN e ENCODING (compresstype=none, blocksize=32768, compresslevel=0)                                                           +
                                             COLUMN f ENCODING (compresstype=none, blocksize=32768, compresslevel=0)                                                           +
                                   )                                                                                                                                           +
                           )                                                                                                                                                   +
                   ),                                                                                                                                                          +
           PARTITION foo1 START ('01-01-2011'::date) END ('01-01-2012'::date) WITH (tablename='mpp5992_1_prt_foo1', appendonly='false')                                        +
                   (                                                                                                                                                           +
                   SUBPARTITION l1 VALUES(1, 2, 3) WITH (tablename='mpp5992_1_prt_foo1_2_prt_l1', appendonly='false')                                                          +
                           (                                                                                                                                                   +
                           SUBPARTITION ll1 VALUES('Engineering') WITH (tablename='mpp5992_1_prt_foo1_2_prt_l1_3_prt_ll1', appendonly='false')                                 +
                                   (                                                                                                                                           +
                                   SUBPARTITION lll1 VALUES('M') WITH (tablename='mpp5992_1_prt_foo1_2_prt_l1_3_prt_ll1_4_prt_lll1', appendonly='false'),                      +
                                   SUBPARTITION lll2 VALUES('F') WITH (tablename='mpp5992_1_prt_foo1_2_prt_l1_3_prt_ll1_4_prt_lll2', appendonly='false')                       +
                                   ),                                                                                                                                          +
                           SUBPARTITION ll2 VALUES('QA') WITH (tablename='mpp5992_1_prt_foo1_2_prt_l1_3_prt_ll2', appendonly='false')                                          +
                                   (                                                                                                                                           +
                                   SUBPARTITION lll1 VALUES('M') WITH (tablename='mpp5992_1_prt_foo1_2_prt_l1_3_prt_ll2_4_prt_lll1', appendonly='false'),                      +
                                   SUBPARTITION lll2 VALUES('F') WITH (tablename='mpp5992_1_prt_foo1_2_prt_l1_3_prt_ll2_4_prt_lll2', appendonly='false')                       +
                                   )                                                                                                                                           +
                           ),                                                                                                                                                  +
                   SUBPARTITION l2 VALUES(4, 5, 6) WITH (tablename='mpp5992_1_prt_foo1_2_prt_l2', appendonly='false')                                                          +
                           (                                                                                                                                                   +
                           SUBPARTITION ll1 VALUES('Engineering') WITH (tablename='mpp5992_1_prt_foo1_2_prt_l2_3_prt_ll1', appendonly='false')                                 +
                                   (                                                                                                                                           +
                                   SUBPARTITION lll1 VALUES('M') WITH (tablename='mpp5992_1_prt_foo1_2_prt_l2_3_prt_ll1_4_prt_lll1', appendonly='false'),                      +
                                   SUBPARTITION lll2 VALUES('F') WITH (tablename='mpp5992_1_prt_foo1_2_prt_l2_3_prt_ll1_4_prt_lll2', appendonly='false')                       +
                                   ),                                                                                                                                          +
                           SUBPARTITION ll2 VALUES('QA') WITH (tablename='mpp5992_1_prt_foo1_2_prt_l2_3_prt_ll2', appendonly='false')                                          +
                                   (                                                                                                                                           +
                                   SUBPARTITION lll1 VALUES('M') WITH (tablename='mpp5992_1_prt_foo1_2_prt_l2_3_prt_ll2_4_prt_lll1', appendonly='false'),                      +
                                   SUBPARTITION lll2 VALUES('F') WITH (tablename='mpp5992_1_prt_foo1_2_prt_l2_3_prt_ll2_4_prt_lll2', appendonly='false')                       +
                                   )                                                                                                                                           +
                           ),                                                                                                                                                  +
                   SUBPARTITION l3 VALUES(7, 8, 9, 10) WITH (tablename='mpp5992_1_prt_foo1_2_prt_l3', appendonly='false')                                                      +
                           (                                                                                                                                                   +
                           SUBPARTITION ll1 VALUES('Engineering') WITH (tablename='mpp5992_1_prt_foo1_2_prt_l3_3_prt_ll1', appendonly='false')                                 +
                                   (                                                                                                                                           +
                                   SUBPARTITION lll1 VALUES('M') WITH (tablename='mpp5992_1_prt_foo1_2_prt_l3_3_prt_ll1_4_prt_lll1', appendonly='false'),                      +
                                   SUBPARTITION lll2 VALUES('F') WITH (tablename='mpp5992_1_prt_foo1_2_prt_l3_3_prt_ll1_4_prt_lll2', appendonly='false')                       +
                                   ),                                                                                                                                          +
                           SUBPARTITION ll2 VALUES('QA') WITH (tablename='mpp5992_1_prt_foo1_2_prt_l3_3_prt_ll2', appendonly='false')                                          +
                                   (                                                                                                                                           +
                                   SUBPARTITION lll1 VALUES('M') WITH (tablename='mpp5992_1_prt_foo1_2_prt_l3_3_prt_ll2_4_prt_lll1', appendonly='false'),                      +
                                   SUBPARTITION lll2 VALUES('F') WITH (tablename='mpp5992_1_prt_foo1_2_prt_l3_3_prt_ll2_4_prt_lll2', appendonly='false')                       +
                                   )                                                                                                                                           +
                           )                                                                                                                                                   +
                   ),                                                                                                                                                          +
           PARTITION foo2 START ('01-01-2012'::date) END ('01-01-2013'::date) WITH (tablename='mpp5992_1_prt_foo2', orientation='column', appendonly='true' )                  +
                     COLUMN a ENCODING (compresstype=none, blocksize=32768, compresslevel=0)                                                                                   +
                     COLUMN b ENCODING (compresstype=none, blocksize=32768, compresslevel=0)                                                                                   +
                     COLUMN c ENCODING (compresstype=none, blocksize=32768, compresslevel=0)                                                                                   +
                     COLUMN d ENCODING (compresstype=none, blocksize=32768, compresslevel=0)                                                                                   +
                     COLUMN e ENCODING (compresstype=none, blocksize=32768, compresslevel=0)                                                                                   +
                     COLUMN f ENCODING (compresstype=none, blocksize=32768, compresslevel=0)                                                                                   +
                   (                                                                                                                                                           +
                   SUBPARTITION l1 VALUES(1, 2, 3) WITH (tablename='mpp5992_1_prt_foo2_2_prt_l1', orientation='column', appendonly='true' )                                    +
                             COLUMN a ENCODING (compresstype=none, blocksize=32768, compresslevel=0)                                                                           +
                             COLUMN b ENCODING (compresstype=none, blocksize=32768, compresslevel=0)                                                                           +
                             COLUMN c ENCODING (compresstype=none, blocksize=32768, compresslevel=0)                                                                           +
                             COLUMN d ENCODING (compresstype=none, blocksize=32768, compresslevel=0)                                                                           +
                             COLUMN e ENCODING (compresstype=none, blocksize=32768, compresslevel=0)                                                                           +
                             COLUMN f ENCODING (compresstype=none, blocksize=32768, compresslevel=0)                                                                           +
                           (                                                                                                                                                   +
                           SUBPARTITION ll1 VALUES('Engineering') WITH (tablename='mpp5992_1_prt_foo2_2_prt_l1_3_prt_ll1', orientation='column', appendonly='true' )           +
                                     COLUMN a ENCODING (compresstype=none, blocksize=32768, compresslevel=0)                                                                   +
                                     COLUMN b ENCODING (compresstype=none, blocksize=32768, compresslevel=0)                                                                   +
                                     COLUMN c ENCODING (compresstype=none, blocksize=32768, compresslevel=0)                                                                   +
                                     COLUMN d ENCODING (compresstype=none, blocksize=32768, compresslevel=0)                                                                   +
                                     COLUMN e ENCODING (compresstype=none, blocksize=32768, compresslevel=0)                                                                   +
                                     COLUMN f ENCODING (compresstype=none, blocksize=32768, compresslevel=0)                                                                   +
                                   (                                                                                                                                           +
                                   SUBPARTITION lll1 VALUES('M') WITH (tablename='mpp5992_1_prt_foo2_2_prt_l1_3_prt_ll1_4_prt_lll1', orientation='column', appendonly='true' ) +
                                             COLUMN a ENCODING (compresstype=none, blocksize=32768, compresslevel=0)                                                           +
                                             COLUMN b ENCODING (compresstype=none, blocksize=32768, compresslevel=0)                                                           +
                                             COLUMN c ENCODING (compresstype=none, blocksize=32768, compresslevel=0)                                                           +
                                             COLUMN d ENCODING (compresstype=none, blocksize=32768, compresslevel=0)                                                           +
                                             COLUMN e ENCODING (compresstype=none, blocksize=32768, compresslevel=0)                                                           +
                                             COLUMN f ENCODING (compresstype=none, blocksize=32768, compresslevel=0),                                                          +
                                   SUBPARTITION lll2 VALUES('F') WITH (tablename='mpp5992_1_prt_foo2_2_prt_l1_3_prt_ll1_4_prt_lll2', orientation='column', appendonly='true' ) +
                                             COLUMN a ENCODING (compresstype=none, blocksize=32768, compresslevel=0)                                                           +
                                             COLUMN b ENCODING (compresstype=none, blocksize=32768, compresslevel=0)                                                           +
                                             COLUMN c ENCODING (compresstype=none, blocksize=32768, compresslevel=0)                                                           +
                                             COLUMN d ENCODING (compresstype=none, blocksize=32768, compresslevel=0)                                                           +
                                             COLUMN e ENCODING (compresstype=none, blocksize=32768, compresslevel=0)                                                           +
                                             COLUMN f ENCODING (compresstype=none, blocksize=32768, compresslevel=0)                                                           +
                                   ),                                                                                                                                          +
                           SUBPARTITION ll2 VALUES('QA') WITH (tablename='mpp5992_1_prt_foo2_2_prt_l1_3_prt_ll2', orientation='column', appendonly='true' )                    +
                                     COLUMN a ENCODING (compresstype=none, blocksize=32768, compresslevel=0)                                                                   +
                                     COLUMN b ENCODING (compresstype=none, blocksize=32768, compresslevel=0)                                                                   +
                                     COLUMN c ENCODING (compresstype=none, blocksize=32768, compresslevel=0)                                                                   +
                                     COLUMN d ENCODING (compresstype=none, blocksize=32768, compresslevel=0)                                                                   +
                                     COLUMN e ENCODING (compresstype=none, blocksize=32768, compresslevel=0)                                                                   +
                                     COLUMN f ENCODING (compresstype=none, blocksize=32768, compresslevel=0)                                                                   +
                                   (                                                                                                                                           +
                                   SUBPARTITION lll1 VALUES('M') WITH (tablename='mpp5992_1_prt_foo2_2_prt_l1_3_prt_ll2_4_prt_lll1', orientation='column', appendonly='true' ) +
                                             COLUMN a ENCODING (compresstype=none, blocksize=32768, compresslevel=0)                                                           +
                                             COLUMN b ENCODING (compresstype=none, blocksize=32768, compresslevel=0)                                                           +
                                             COLUMN c ENCODING (compresstype=none, blocksize=32768, compresslevel=0)                                                           +
                                             COLUMN d ENCODING (compresstype=none, blocksize=32768, compresslevel=0)                                                           +
                                             COLUMN e ENCODING (compresstype=none, blocksize=32768, compresslevel=0)                                                           +
                                             COLUMN f ENCODING (compresstype=none, blocksize=32768, compresslevel=0),                                                          +
                                   SUBPARTITION lll2 VALUES('F') WITH (tablename='mpp5992_1_prt_foo2_2_prt_l1_3_prt_ll2_4_prt_lll2', orientation='column', appendonly='true' ) +
                                             COLUMN a ENCODING (compresstype=none, blocksize=32768, compresslevel=0)                                                           +
                                             COLUMN b ENCODING (compresstype=none, blocksize=32768, compresslevel=0)                                                           +
                                             COLUMN c ENCODING (compresstype=none, blocksize=32768, compresslevel=0)                                                           +
                                             COLUMN d ENCODING (compresstype=none, blocksize=32768, compresslevel=0)                                                           +
                                             COLUMN e ENCODING (compresstype=none, blocksize=32768, compresslevel=0)                                                           +
                                             COLUMN f ENCODING (compresstype=none, blocksize=32768, compresslevel=0)                                                           +
                                   )                                                                                                                                           +
                           ),                                                                                                                                                  +
                   SUBPARTITION l2 VALUES(4, 5, 6) WITH (tablename='mpp5992_1_prt_foo2_2_prt_l2', orientation='column', appendonly='true' )                                    +
                             COLUMN a ENCODING (compresstype=none, blocksize=32768, compresslevel=0)                                                                           +
                             COLUMN b ENCODING (compresstype=none, blocksize=32768, compresslevel=0)                                                                           +
                             COLUMN c ENCODING (compresstype=none, blocksize=32768, compresslevel=0)                                                                           +
                             COLUMN d ENCODING (compresstype=none, blocksize=32768, compresslevel=0)                                                                           +
                             COLUMN e ENCODING (compresstype=none, blocksize=32768, compresslevel=0)                                                                           +
                             COLUMN f ENCODING (compresstype=none, blocksize=32768, compresslevel=0)                                                                           +
                           (                                                                                                                                                   +
                           SUBPARTITION ll1 VALUES('Engineering') WITH (tablename='mpp5992_1_prt_foo2_2_prt_l2_3_prt_ll1', orientation='column', appendonly='true' )           +
                                     COLUMN a ENCODING (compresstype=none, blocksize=32768, compresslevel=0)                                                                   +
                                     COLUMN b ENCODING (compresstype=none, blocksize=32768, compresslevel=0)                                                                   +
                                     COLUMN c ENCODING (compresstype=none, blocksize=32768, compresslevel=0)                                                                   +
                                     COLUMN d ENCODING (compresstype=none, blocksize=32768, compresslevel=0)                                                                   +
                                     COLUMN e ENCODING (compresstype=none, blocksize=32768, compresslevel=0)                                                                   +
                                     COLUMN f ENCODING (compresstype=none, blocksize=32768, compresslevel=0)                                                                   +
                                   (                                                                                                                                           +
                                   SUBPARTITION lll1 VALUES('M') WITH (tablename='mpp5992_1_prt_foo2_2_prt_l2_3_prt_ll1_4_prt_lll1', orientation='column', appendonly='true' ) +
                                             COLUMN a ENCODING (compresstype=none, blocksize=32768, compresslevel=0)                                                           +
                                             COLUMN b ENCODING (compresstype=none, blocksize=32768, compresslevel=0)                                                           +
                                             COLUMN c ENCODING (compresstype=none, blocksize=32768, compresslevel=0)                                                           +
                                             COLUMN d ENCODING (compresstype=none, blocksize=32768, compresslevel=0)                                                           +
                                             COLUMN e ENCODING (compresstype=none, blocksize=32768, compresslevel=0)                                                           +
                                             COLUMN f ENCODING (compresstype=none, blocksize=32768, compresslevel=0),                                                          +
                                   SUBPARTITION lll2 VALUES('F') WITH (tablename='mpp5992_1_prt_foo2_2_prt_l2_3_prt_ll1_4_prt_lll2', orientation='column', appendonly='true' ) +
                                             COLUMN a ENCODING (compresstype=none, blocksize=32768, compresslevel=0)                                                           +
                                             COLUMN b ENCODING (compresstype=none, blocksize=32768, compresslevel=0)                                                           +
                                             COLUMN c ENCODING (compresstype=none, blocksize=32768, compresslevel=0)                                                           +
                                             COLUMN d ENCODING (compresstype=none, blocksize=32768, compresslevel=0)                                                           +
                                             COLUMN e ENCODING (compresstype=none, blocksize=32768, compresslevel=0)                                                           +
                                             COLUMN f ENCODING (compresstype=none, blocksize=32768, compresslevel=0)                                                           +
                                   ),                                                                                                                                          +
                           SUBPARTITION ll2 VALUES('QA') WITH (tablename='mpp5992_1_prt_foo2_2_prt_l2_3_prt_ll2', orientation='column', appendonly='true' )                    +
                                     COLUMN a ENCODING (compresstype=none, blocksize=32768, compresslevel=0)                                                                   +
                                     COLUMN b ENCODING (compresstype=none, blocksize=32768, compresslevel=0)                                                                   +
                                     COLUMN c ENCODING (compresstype=none, blocksize=32768, compresslevel=0)                                                                   +
                                     COLUMN d ENCODING (compresstype=none, blocksize=32768, compresslevel=0)                                                                   +
                                     COLUMN e ENCODING (compresstype=none, blocksize=32768, compresslevel=0)                                                                   +
                                     COLUMN f ENCODING (compresstype=none, blocksize=32768, compresslevel=0)                                                                   +
                                   (                                                                                                                                           +
                                   SUBPARTITION lll1 VALUES('M') WITH (tablename='mpp5992_1_prt_foo2_2_prt_l2_3_prt_ll2_4_prt_lll1', orientation='column', appendonly='true' ) +
                                             COLUMN a ENCODING (compresstype=none, blocksize=32768, compresslevel=0)                                                           +
                                             COLUMN b ENCODING (compresstype=none, blocksize=32768, compresslevel=0)                                                           +
                                             COLUMN c ENCODING (compresstype=none, blocksize=32768, compresslevel=0)                                                           +
                                             COLUMN d ENCODING (compresstype=none, blocksize=32768, compresslevel=0)                                                           +
                                             COLUMN e ENCODING (compresstype=none, blocksize=32768, compresslevel=0)                                                           +
                                             COLUMN f ENCODING (compresstype=none, blocksize=32768, compresslevel=0),                                                          +
                                   SUBPARTITION lll2 VALUES('F') WITH (tablename='mpp5992_1_prt_foo2_2_prt_l2_3_prt_ll2_4_prt_lll2', orientation='column', appendonly='true' ) +
                                             COLUMN a ENCODING (compresstype=none, blocksize=32768, compresslevel=0)                                                           +
                                             COLUMN b ENCODING (compresstype=none, blocksize=32768, compresslevel=0)                                                           +
                                             COLUMN c ENCODING (compresstype=none, blocksize=32768, compresslevel=0)                                                           +
                                             COLUMN d ENCODING (compresstype=none, blocksize=32768, compresslevel=0)                                                           +
                                             COLUMN e ENCODING (compresstype=none, blocksize=32768, compresslevel=0)                                                           +
                                             COLUMN f ENCODING (compresstype=none, blocksize=32768, compresslevel=0)                                                           +
                                   )                                                                                                                                           +
                           ),                                                                                                                                                  +
                   SUBPARTITION l3 VALUES(7, 8, 9, 10) WITH (tablename='mpp5992_1_prt_foo2_2_prt_l3', orientation='column', appendonly='true' )                                +
                             COLUMN a ENCODING (compresstype=none, blocksize=32768, compresslevel=0)                                                                           +
                             COLUMN b ENCODING (compresstype=none, blocksize=32768, compresslevel=0)                                                                           +
                             COLUMN c ENCODING (compresstype=none, blocksize=32768, compresslevel=0)                                                                           +
                             COLUMN d ENCODING (compresstype=none, blocksize=32768, compresslevel=0)                                                                           +
                             COLUMN e ENCODING (compresstype=none, blocksize=32768, compresslevel=0)                                                                           +
                             COLUMN f ENCODING (compresstype=none, blocksize=32768, compresslevel=0)                                                                           +
                           (                                                                                                                                                   +
                           SUBPARTITION ll1 VALUES('Engineering') WITH (tablename='mpp5992_1_prt_foo2_2_prt_l3_3_prt_ll1', orientation='column', appendonly='true' )           +
                                     COLUMN a ENCODING (compresstype=none, blocksize=32768, compresslevel=0)                                                                   +
                                     COLUMN b ENCODING (compresstype=none, blocksize=32768, compresslevel=0)                                                                   +
                                     COLUMN c ENCODING (compresstype=none, blocksize=32768, compresslevel=0)                                                                   +
                                     COLUMN d ENCODING (compresstype=none, blocksize=32768, compresslevel=0)                                                                   +
                                     COLUMN e ENCODING (compresstype=none, blocksize=32768, compresslevel=0)                                                                   +
                                     COLUMN f ENCODING (compresstype=none, blocksize=32768, compresslevel=0)                                                                   +
                                   (                                                                                                                                           +
                                   SUBPARTITION lll1 VALUES('M') WITH (tablename='mpp5992_1_prt_foo2_2_prt_l3_3_prt_ll1_4_prt_lll1', orientation='column', appendonly='true' ) +
                                             COLUMN a ENCODING (compresstype=none, blocksize=32768, compresslevel=0)                                                           +
                                             COLUMN b ENCODING (compresstype=none, blocksize=32768, compresslevel=0)                                                           +
                                             COLUMN c ENCODING (compresstype=none, blocksize=32768, compresslevel=0)                                                           +
                                             COLUMN d ENCODING (compresstype=none, blocksize=32768, compresslevel=0)                                                           +
                                             COLUMN e ENCODING (compresstype=none, blocksize=32768, compresslevel=0)                                                           +
                                             COLUMN f ENCODING (compresstype=none, blocksize=32768, compresslevel=0),                                                          +
                                   SUBPARTITION lll2 VALUES('F') WITH (tablename='mpp5992_1_prt_foo2_2_prt_l3_3_prt_ll1_4_prt_lll2', orientation='column', appendonly='true' ) +
                                             COLUMN a ENCODING (compresstype=none, blocksize=32768, compresslevel=0)                                                           +
                                             COLUMN b ENCODING (compresstype=none, blocksize=32768, compresslevel=0)                                                           +
                                             COLUMN c ENCODING (compresstype=none, blocksize=32768, compresslevel=0)                                                           +
                                             COLUMN d ENCODING (compresstype=none, blocksize=32768, compresslevel=0)                                                           +
                                             COLUMN e ENCODING (compresstype=none, blocksize=32768, compresslevel=0)                                                           +
                                             COLUMN f ENCODING (compresstype=none, blocksize=32768, compresslevel=0)                                                           +
                                   ),                                                                                                                                          +
                           SUBPARTITION ll2 VALUES('QA') WITH (tablename='mpp5992_1_prt_foo2_2_prt_l3_3_prt_ll2', orientation='column', appendonly='true' )                    +
                                     COLUMN a ENCODING (compresstype=none, blocksize=32768, compresslevel=0)                                                                   +
                                     COLUMN b ENCODING (compresstype=none, blocksize=32768, compresslevel=0)                                                                   +
                                     COLUMN c ENCODING (compresstype=none, blocksize=32768, compresslevel=0)                                                                   +
                                     COLUMN d ENCODING (compresstype=none, blocksize=32768, compresslevel=0)                                                                   +
                                     COLUMN e ENCODING (compresstype=none, blocksize=32768, compresslevel=0)                                                                   +
                                     COLUMN f ENCODING (compresstype=none, blocksize=32768, compresslevel=0)                                                                   +
                                   (                                                                                                                                           +
                                   SUBPARTITION lll1 VALUES('M') WITH (tablename='mpp5992_1_prt_foo2_2_prt_l3_3_prt_ll2_4_prt_lll1', orientation='column', appendonly='true' ) +
                                             COLUMN a ENCODING (compresstype=none, blocksize=32768, compresslevel=0)                                                           +
                                             COLUMN b ENCODING (compresstype=none, blocksize=32768, compresslevel=0)                                                           +
                                             COLUMN c ENCODING (compresstype=none, blocksize=32768, compresslevel=0)                                                           +
                                             COLUMN d ENCODING (compresstype=none, blocksize=32768, compresslevel=0)                                                           +
                                             COLUMN e ENCODING (compresstype=none, blocksize=32768, compresslevel=0)                                                           +
                                             COLUMN f ENCODING (compresstype=none, blocksize=32768, compresslevel=0),                                                          +
                                   SUBPARTITION lll2 VALUES('F') WITH (tablename='mpp5992_1_prt_foo2_2_prt_l3_3_prt_ll2_4_prt_lll2', orientation='column', appendonly='true' ) +
                                             COLUMN a ENCODING (compresstype=none, blocksize=32768, compresslevel=0)                                                           +
                                             COLUMN b ENCODING (compresstype=none, blocksize=32768, compresslevel=0)                                                           +
                                             COLUMN c ENCODING (compresstype=none, blocksize=32768, compresslevel=0)                                                           +
                                             COLUMN d ENCODING (compresstype=none, blocksize=32768, compresslevel=0)                                                           +
                                             COLUMN e ENCODING (compresstype=none, blocksize=32768, compresslevel=0)                                                           +
                                             COLUMN f ENCODING (compresstype=none, blocksize=32768, compresslevel=0)                                                           +
                                   )                                                                                                                                           +
                           )                                                                                                                                                   +
                   ),                                                                                                                                                          +
           PARTITION foo3 START ('01-01-2013'::date) END ('01-01-2014'::date) WITH (tablename='mpp5992_1_prt_foo3', appendonly='true' )                                        +
                   (                                                                                                                                                           +
                   SUBPARTITION l1 VALUES(1, 2, 3) WITH (tablename='mpp5992_1_prt_foo3_2_prt_l1', appendonly='true' )                                                          +
                           (                                                                                                                                                   +
                           SUBPARTITION ll1 VALUES('Engineering') WITH (tablename='mpp5992_1_prt_foo3_2_prt_l1_3_prt_ll1', appendonly='true' )                                 +
                                   (                                                                                                                                           +
                                   SUBPARTITION lll1 VALUES('M') WITH (tablename='mpp5992_1_prt_foo3_2_prt_l1_3_prt_ll1_4_prt_lll1', appendonly='true' ),                      +
                                   SUBPARTITION lll2 VALUES('F') WITH (tablename='mpp5992_1_prt_foo3_2_prt_l1_3_prt_ll1_4_prt_lll2', appendonly='true' )                       +
                                   ),                                                                                                                                          +
                           SUBPARTITION ll2 VALUES('QA') WITH (tablename='mpp5992_1_prt_foo3_2_prt_l1_3_prt_ll2', appendonly='true' )                                          +
                                   (                                                                                                                                           +
                                   SUBPARTITION lll1 VALUES('M') WITH (tablename='mpp5992_1_prt_foo3_2_prt_l1_3_prt_ll2_4_prt_lll1', appendonly='true' ),                      +
                                   SUBPARTITION lll2 VALUES('F') WITH (tablename='mpp5992_1_prt_foo3_2_prt_l1_3_prt_ll2_4_prt_lll2', appendonly='true' )                       +
                                   )                                                                                                                                           +
                           ),                                                                                                                                                  +
                   SUBPARTITION l2 VALUES(4, 5, 6) WITH (tablename='mpp5992_1_prt_foo3_2_prt_l2', appendonly='true' )                                                          +
                           (                                                                                                                                                   +
                           SUBPARTITION ll1 VALUES('Engineering') WITH (tablename='mpp5992_1_prt_foo3_2_prt_l2_3_prt_ll1', appendonly='true' )                                 +
                                   (                                                                                                                                           +
                                   SUBPARTITION lll1 VALUES('M') WITH (tablename='mpp5992_1_prt_foo3_2_prt_l2_3_prt_ll1_4_prt_lll1', appendonly='true' ),                      +
                                   SUBPARTITION lll2 VALUES('F') WITH (tablename='mpp5992_1_prt_foo3_2_prt_l2_3_prt_ll1_4_prt_lll2', appendonly='true' )                       +
                                   ),                                                                                                                                          +
                           SUBPARTITION ll2 VALUES('QA') WITH (tablename='mpp5992_1_prt_foo3_2_prt_l2_3_prt_ll2', appendonly='true' )                                          +
                                   (                                                                                                                                           +
                                   SUBPARTITION lll1 VALUES('M') WITH (tablename='mpp5992_1_prt_foo3_2_prt_l2_3_prt_ll2_4_prt_lll1', appendonly='true' ),                      +
                                   SUBPARTITION lll2 VALUES('F') WITH (tablename='mpp5992_1_prt_foo3_2_prt_l2_3_prt_ll2_4_prt_lll2', appendonly='true' )                       +
                                   )                                                                                                                                           +
                           ),                                                                                                                                                  +
                   SUBPARTITION l3 VALUES(7, 8, 9, 10) WITH (tablename='mpp5992_1_prt_foo3_2_prt_l3', appendonly='true' )                                                      +
                           (                                                                                                                                                   +
                           SUBPARTITION ll1 VALUES('Engineering') WITH (tablename='mpp5992_1_prt_foo3_2_prt_l3_3_prt_ll1', appendonly='true' )                                 +
                                   (                                                                                                                                           +
                                   SUBPARTITION lll1 VALUES('M') WITH (tablename='mpp5992_1_prt_foo3_2_prt_l3_3_prt_ll1_4_prt_lll1', appendonly='true' ),                      +
                                   SUBPARTITION lll2 VALUES('F') WITH (tablename='mpp5992_1_prt_foo3_2_prt_l3_3_prt_ll1_4_prt_lll2', appendonly='true' )                       +
                                   ),                                                                                                                                          +
                           SUBPARTITION ll2 VALUES('QA') WITH (tablename='mpp5992_1_prt_foo3_2_prt_l3_3_prt_ll2', appendonly='true' )                                          +
                                   (                                                                                                                                           +
                                   SUBPARTITION lll1 VALUES('M') WITH (tablename='mpp5992_1_prt_foo3_2_prt_l3_3_prt_ll2_4_prt_lll1', appendonly='true' ),                      +
                                   SUBPARTITION lll2 VALUES('F') WITH (tablename='mpp5992_1_prt_foo3_2_prt_l3_3_prt_ll2_4_prt_lll2', appendonly='true' )                       +
                                   )                                                                                                                                           +
                           )                                                                                                                                                   +
                   )                                                                                                                                                           +
           )
(1 row)

-- MPP-10223: split subpartitions
CREATE TABLE MPP10223pk
(
rnc VARCHAR(100),
wbts VARCHAR(100),
axc VARCHAR(100),
vptt VARCHAR(100),
vcct VARCHAR(100),
agg_level CHAR(5),
period_start_time TIMESTAMP WITH TIME ZONE,
load_time TIMESTAMP WITH TIME ZONE DEFAULT now(),
interval INTEGER,
totcellsegress double precision,
totcellsingress double precision,
 
  CONSTRAINT "axc_vcct1_atmvcct_pk_test2" 
PRIMARY KEY (rnc,wbts,axc,vptt,vcct,agg_level,period_start_time)
)
 
DISTRIBUTED BY (rnc,wbts,axc,vptt,vcct)
 
PARTITION BY LIST (AGG_LEVEL)
  SUBPARTITION BY RANGE (PERIOD_START_TIME)
(
  PARTITION min15part  VALUES ('15min')
    (
       SUBPARTITION P_FUTURE  START (date '2001-01-01') INCLUSIVE,
       SUBPARTITION P_ENDPART START (date '2999-12-30') INCLUSIVE
                              END (date '2999-12-31') EXCLUSIVE
    ),
  PARTITION hourpart   VALUES ('hour')
    (
               SUBPARTITION P20100622 START (date '2010-06-22') INCLUSIVE,
               SUBPARTITION P20100623 START (date '2010-06-23') INCLUSIVE,
               SUBPARTITION P20100624 START (date '2010-06-24') INCLUSIVE,
               SUBPARTITION P20100625 START (date '2010-06-25') INCLUSIVE,
               SUBPARTITION P20100626 START (date '2010-06-26') INCLUSIVE,
               SUBPARTITION P_FUTURE  START (date '2001-01-01') INCLUSIVE,
               SUBPARTITION P_ENDPART START (date '2999-12-30') INCLUSIVE
                                      END (date '2999-12-31') EXCLUSIVE
    ),
  PARTITION daypart    VALUES ('day')
    (
               SUBPARTITION P20100622 START (date '2010-06-22') INCLUSIVE,
               SUBPARTITION P20100623 START (date '2010-06-23') INCLUSIVE,
               SUBPARTITION P20100624 START (date '2010-06-24') INCLUSIVE,
               SUBPARTITION P20100625 START (date '2010-06-25') INCLUSIVE,
               SUBPARTITION P20100626 START (date '2010-06-26') INCLUSIVE,
               SUBPARTITION P_FUTURE  START (date '2001-01-01') INCLUSIVE,
               SUBPARTITION P_ENDPART START (date '2999-12-30') INCLUSIVE
                                      END (date '2999-12-31') EXCLUSIVE
    )
);
NOTICE:  CREATE TABLE will create partition "mpp10223pk_1_prt_min15part" for table "mpp10223pk"
NOTICE:  CREATE TABLE will create partition "mpp10223pk_1_prt_min15part_2_prt_p_future" for table "mpp10223pk_1_prt_min15part"
NOTICE:  CREATE TABLE will create partition "mpp10223pk_1_prt_min15part_2_prt_p_endpart" for table "mpp10223pk_1_prt_min15part"
NOTICE:  CREATE TABLE will create partition "mpp10223pk_1_prt_hourpart" for table "mpp10223pk"
NOTICE:  CREATE TABLE will create partition "mpp10223pk_1_prt_hourpart_2_prt_p_future" for table "mpp10223pk_1_prt_hourpart"
NOTICE:  CREATE TABLE will create partition "mpp10223pk_1_prt_hourpart_2_prt_p20100622" for table "mpp10223pk_1_prt_hourpart"
NOTICE:  CREATE TABLE will create partition "mpp10223pk_1_prt_hourpart_2_prt_p20100623" for table "mpp10223pk_1_prt_hourpart"
NOTICE:  CREATE TABLE will create partition "mpp10223pk_1_prt_hourpart_2_prt_p20100624" for table "mpp10223pk_1_prt_hourpart"
NOTICE:  CREATE TABLE will create partition "mpp10223pk_1_prt_hourpart_2_prt_p20100625" for table "mpp10223pk_1_prt_hourpart"
NOTICE:  CREATE TABLE will create partition "mpp10223pk_1_prt_hourpart_2_prt_p20100626" for table "mpp10223pk_1_prt_hourpart"
NOTICE:  CREATE TABLE will create partition "mpp10223pk_1_prt_hourpart_2_prt_p_endpart" for table "mpp10223pk_1_prt_hourpart"
NOTICE:  CREATE TABLE will create partition "mpp10223pk_1_prt_daypart" for table "mpp10223pk"
NOTICE:  CREATE TABLE will create partition "mpp10223pk_1_prt_daypart_2_prt_p_future" for table "mpp10223pk_1_prt_daypart"
NOTICE:  CREATE TABLE will create partition "mpp10223pk_1_prt_daypart_2_prt_p20100622" for table "mpp10223pk_1_prt_daypart"
NOTICE:  CREATE TABLE will create partition "mpp10223pk_1_prt_daypart_2_prt_p20100623" for table "mpp10223pk_1_prt_daypart"
NOTICE:  CREATE TABLE will create partition "mpp10223pk_1_prt_daypart_2_prt_p20100624" for table "mpp10223pk_1_prt_daypart"
NOTICE:  CREATE TABLE will create partition "mpp10223pk_1_prt_daypart_2_prt_p20100625" for table "mpp10223pk_1_prt_daypart"
NOTICE:  CREATE TABLE will create partition "mpp10223pk_1_prt_daypart_2_prt_p20100626" for table "mpp10223pk_1_prt_daypart"
NOTICE:  CREATE TABLE will create partition "mpp10223pk_1_prt_daypart_2_prt_p_endpart" for table "mpp10223pk_1_prt_daypart"
-- MPP-10421: works -- can re-use name for non-DEFAULT partitions, and
-- primary key problems fixed
ALTER TABLE MPP10223pk
 ALTER PARTITION min15part 
SPLIT PARTITION  P_FUTURE AT ('2010-06-25') 
INTO (PARTITION P20010101, PARTITION P_FUTURE);
NOTICE:  exchanged partition "p_future" of partition "min15part" of relation "mpp10223pk" with relation "pg_temp_530246"
NOTICE:  dropped partition "p_future" for partition "min15part" of relation "mpp10223pk"
NOTICE:  CREATE TABLE will create partition "mpp10223pk_1_prt_min15part_2_prt_p20010101" for table "mpp10223pk_1_prt_min15part"
NOTICE:  CREATE TABLE will create partition "mpp10223pk_1_prt_min15part_2_prt_p_future" for table "mpp10223pk_1_prt_min15part"
drop table mpp10223pk;
-- rebuild the table without a primary key
CREATE TABLE MPP10223
(
rnc VARCHAR(100),
wbts VARCHAR(100),
axc VARCHAR(100),
vptt VARCHAR(100),
vcct VARCHAR(100),
agg_level CHAR(5),
period_start_time TIMESTAMP WITH TIME ZONE,
load_time TIMESTAMP WITH TIME ZONE DEFAULT now(),
interval INTEGER,
totcellsegress double precision,
totcellsingress double precision
)
 
DISTRIBUTED BY (rnc,wbts,axc,vptt,vcct)
 
PARTITION BY LIST (AGG_LEVEL)
  SUBPARTITION BY RANGE (PERIOD_START_TIME)
(
  PARTITION min15part  VALUES ('15min')
    (
       SUBPARTITION P_FUTURE  START (date '2001-01-01') INCLUSIVE,
       SUBPARTITION P_ENDPART START (date '2999-12-30') INCLUSIVE
                              END (date '2999-12-31') EXCLUSIVE
    ),
  PARTITION hourpart   VALUES ('hour')
    (
               SUBPARTITION P20100622 START (date '2010-06-22') INCLUSIVE,
               SUBPARTITION P20100623 START (date '2010-06-23') INCLUSIVE,
               SUBPARTITION P20100624 START (date '2010-06-24') INCLUSIVE,
               SUBPARTITION P20100625 START (date '2010-06-25') INCLUSIVE,
               SUBPARTITION P20100626 START (date '2010-06-26') INCLUSIVE,
               SUBPARTITION P_FUTURE  START (date '2001-01-01') INCLUSIVE,
               SUBPARTITION P_ENDPART START (date '2999-12-30') INCLUSIVE
                                      END (date '2999-12-31') EXCLUSIVE
    ),
  PARTITION daypart    VALUES ('day')
    (
               SUBPARTITION P20100622 START (date '2010-06-22') INCLUSIVE,
               SUBPARTITION P20100623 START (date '2010-06-23') INCLUSIVE,
               SUBPARTITION P20100624 START (date '2010-06-24') INCLUSIVE,
               SUBPARTITION P20100625 START (date '2010-06-25') INCLUSIVE,
               SUBPARTITION P20100626 START (date '2010-06-26') INCLUSIVE,
               SUBPARTITION P_FUTURE  START (date '2001-01-01') INCLUSIVE,
               SUBPARTITION P_ENDPART START (date '2999-12-30') INCLUSIVE
                                      END (date '2999-12-31') EXCLUSIVE
    )
);
NOTICE:  CREATE TABLE will create partition "mpp10223_1_prt_min15part" for table "mpp10223"
NOTICE:  CREATE TABLE will create partition "mpp10223_1_prt_min15part_2_prt_p_future" for table "mpp10223_1_prt_min15part"
NOTICE:  CREATE TABLE will create partition "mpp10223_1_prt_min15part_2_prt_p_endpart" for table "mpp10223_1_prt_min15part"
NOTICE:  CREATE TABLE will create partition "mpp10223_1_prt_hourpart" for table "mpp10223"
NOTICE:  CREATE TABLE will create partition "mpp10223_1_prt_hourpart_2_prt_p_future" for table "mpp10223_1_prt_hourpart"
NOTICE:  CREATE TABLE will create partition "mpp10223_1_prt_hourpart_2_prt_p20100622" for table "mpp10223_1_prt_hourpart"
NOTICE:  CREATE TABLE will create partition "mpp10223_1_prt_hourpart_2_prt_p20100623" for table "mpp10223_1_prt_hourpart"
NOTICE:  CREATE TABLE will create partition "mpp10223_1_prt_hourpart_2_prt_p20100624" for table "mpp10223_1_prt_hourpart"
NOTICE:  CREATE TABLE will create partition "mpp10223_1_prt_hourpart_2_prt_p20100625" for table "mpp10223_1_prt_hourpart"
NOTICE:  CREATE TABLE will create partition "mpp10223_1_prt_hourpart_2_prt_p20100626" for table "mpp10223_1_prt_hourpart"
NOTICE:  CREATE TABLE will create partition "mpp10223_1_prt_hourpart_2_prt_p_endpart" for table "mpp10223_1_prt_hourpart"
NOTICE:  CREATE TABLE will create partition "mpp10223_1_prt_daypart" for table "mpp10223"
NOTICE:  CREATE TABLE will create partition "mpp10223_1_prt_daypart_2_prt_p_future" for table "mpp10223_1_prt_daypart"
NOTICE:  CREATE TABLE will create partition "mpp10223_1_prt_daypart_2_prt_p20100622" for table "mpp10223_1_prt_daypart"
NOTICE:  CREATE TABLE will create partition "mpp10223_1_prt_daypart_2_prt_p20100623" for table "mpp10223_1_prt_daypart"
NOTICE:  CREATE TABLE will create partition "mpp10223_1_prt_daypart_2_prt_p20100624" for table "mpp10223_1_prt_daypart"
NOTICE:  CREATE TABLE will create partition "mpp10223_1_prt_daypart_2_prt_p20100625" for table "mpp10223_1_prt_daypart"
NOTICE:  CREATE TABLE will create partition "mpp10223_1_prt_daypart_2_prt_p20100626" for table "mpp10223_1_prt_daypart"
NOTICE:  CREATE TABLE will create partition "mpp10223_1_prt_daypart_2_prt_p_endpart" for table "mpp10223_1_prt_daypart"
-- this works
ALTER TABLE MPP10223
 ALTER PARTITION min15part 
SPLIT PARTITION  P_FUTURE AT ('2010-06-25') 
INTO (PARTITION P20010101, PARTITION P_FUTURE2);
NOTICE:  exchanged partition "p_future" of partition "min15part" of relation "mpp10223" with relation "pg_temp_4050688"
NOTICE:  dropped partition "p_future" for partition "min15part" of relation "mpp10223"
NOTICE:  CREATE TABLE will create partition "mpp10223_1_prt_min15part_2_prt_p20010101" for table "mpp10223_1_prt_min15part"
NOTICE:  CREATE TABLE will create partition "mpp10223_1_prt_min15part_2_prt_p_future2" for table "mpp10223_1_prt_min15part"
select pg_get_partition_def('mpp10223'::regclass,true);
                                                                            pg_get_partition_def                                                                            
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 PARTITION BY LIST(agg_level)                                                                                                                                              +
           SUBPARTITION BY RANGE(period_start_time)                                                                                                                        +
           (                                                                                                                                                               +
           PARTITION min15part VALUES('15min')                                                                                                                             +
                   (                                                                                                                                                       +
                   SUBPARTITION p_future2 START ('Fri Jun 25 00:00:00 2010 PDT'::timestamp with time zone) END ('Mon Dec 30 00:00:00 2999 PST'::timestamp with time zone), +
                   SUBPARTITION p20010101 START ('Mon Jan 01 00:00:00 2001 PST'::timestamp with time zone) END ('Fri Jun 25 00:00:00 2010 PDT'::timestamp with time zone), +
                   SUBPARTITION p_endpart START ('Mon Dec 30 00:00:00 2999 PST'::timestamp with time zone) END ('Tue Dec 31 00:00:00 2999 PST'::timestamp with time zone)  +
                   ),                                                                                                                                                      +
           PARTITION hourpart VALUES('hour ')                                                                                                                              +
                   (                                                                                                                                                       +
                   SUBPARTITION p_future START ('Mon Jan 01 00:00:00 2001 PST'::timestamp with time zone) END ('Tue Jun 22 00:00:00 2010 PDT'::timestamp with time zone),  +
                   SUBPARTITION p20100622 START ('Tue Jun 22 00:00:00 2010 PDT'::timestamp with time zone) END ('Wed Jun 23 00:00:00 2010 PDT'::timestamp with time zone), +
                   SUBPARTITION p20100623 START ('Wed Jun 23 00:00:00 2010 PDT'::timestamp with time zone) END ('Thu Jun 24 00:00:00 2010 PDT'::timestamp with time zone), +
                   SUBPARTITION p20100624 START ('Thu Jun 24 00:00:00 2010 PDT'::timestamp with time zone) END ('Fri Jun 25 00:00:00 2010 PDT'::timestamp with time zone), +
                   SUBPARTITION p20100625 START ('Fri Jun 25 00:00:00 2010 PDT'::timestamp with time zone) END ('Sat Jun 26 00:00:00 2010 PDT'::timestamp with time zone), +
                   SUBPARTITION p20100626 START ('Sat Jun 26 00:00:00 2010 PDT'::timestamp with time zone) END ('Mon Dec 30 00:00:00 2999 PST'::timestamp with time zone), +
                   SUBPARTITION p_endpart START ('Mon Dec 30 00:00:00 2999 PST'::timestamp with time zone) END ('Tue Dec 31 00:00:00 2999 PST'::timestamp with time zone)  +
                   ),                                                                                                                                                      +
           PARTITION daypart VALUES('day  ')                                                                                                                               +
                   (                                                                                                                                                       +
                   SUBPARTITION p_future START ('Mon Jan 01 00:00:00 2001 PST'::timestamp with time zone) END ('Tue Jun 22 00:00:00 2010 PDT'::timestamp with time zone),  +
                   SUBPARTITION p20100622 START ('Tue Jun 22 00:00:00 2010 PDT'::timestamp with time zone) END ('Wed Jun 23 00:00:00 2010 PDT'::timestamp with time zone), +
                   SUBPARTITION p20100623 START ('Wed Jun 23 00:00:00 2010 PDT'::timestamp with time zone) END ('Thu Jun 24 00:00:00 2010 PDT'::timestamp with time zone), +
                   SUBPARTITION p20100624 START ('Thu Jun 24 00:00:00 2010 PDT'::timestamp with time zone) END ('Fri Jun 25 00:00:00 2010 PDT'::timestamp with time zone), +
                   SUBPARTITION p20100625 START ('Fri Jun 25 00:00:00 2010 PDT'::timestamp with time zone) END ('Sat Jun 26 00:00:00 2010 PDT'::timestamp with time zone), +
                   SUBPARTITION p20100626 START ('Sat Jun 26 00:00:00 2010 PDT'::timestamp with time zone) END ('Mon Dec 30 00:00:00 2999 PST'::timestamp with time zone), +
                   SUBPARTITION p_endpart START ('Mon Dec 30 00:00:00 2999 PST'::timestamp with time zone) END ('Tue Dec 31 00:00:00 2999 PST'::timestamp with time zone)  +
                   )                                                                                                                                                       +
           )
(1 row)

-- simpler version
create table mpp10223b (a int, b int , d int)
partition by range (b)
subpartition by range (d)
(partition p1 start (1) end (10)
(subpartition sp2 start (20) end (30)));
NOTICE:  Table doesn't have 'DISTRIBUTED BY' clause -- Using column named 'a' as the Greenplum Database data distribution key for this table.
HINT:  The 'DISTRIBUTED BY' clause determines the distribution of data. Make sure column(s) chosen are the optimal data distribution key to minimize skew.
NOTICE:  CREATE TABLE will create partition "mpp10223b_1_prt_p1" for table "mpp10223b"
NOTICE:  CREATE TABLE will create partition "mpp10223b_1_prt_p1_2_prt_sp2" for table "mpp10223b_1_prt_p1"
-- MPP-10421: allow re-use sp2 for non-DEFAULT partition
alter table mpp10223b alter partition p1 
split partition for (rank(1) ) at (25)
into (partition sp2, partition sp3);
NOTICE:  exchanged partition "sp2" of partition "p1" of relation "mpp10223b" with relation "pg_temp_4051659"
NOTICE:  dropped partition "sp2" for partition "p1" of relation "mpp10223b"
NOTICE:  CREATE TABLE will create partition "mpp10223b_1_prt_p1_2_prt_sp2" for table "mpp10223b_1_prt_p1"
NOTICE:  CREATE TABLE will create partition "mpp10223b_1_prt_p1_2_prt_sp3" for table "mpp10223b_1_prt_p1"
select partitiontablename,partitionposition,partitionrangestart,
       partitionrangeend from pg_partitions where tablename = 'mpp10223b'
           order by partitionposition;
      partitiontablename      | partitionposition | partitionrangestart | partitionrangeend 
------------------------------+-------------------+---------------------+-------------------
 mpp10223b_1_prt_p1           |                 1 | 1                   | 10
 mpp10223b_1_prt_p1_2_prt_sp2 |                 1 | 20                  | 25
 mpp10223b_1_prt_p1_2_prt_sp3 |                 2 | 25                  | 30
(3 rows)

select pg_get_partition_def('mpp10223b'::regclass,true);
                   pg_get_partition_def                   
----------------------------------------------------------
 PARTITION BY RANGE(b)                                   +
           SUBPARTITION BY RANGE(d)                      +
           (                                             +
           PARTITION p1 START (1) END (10)               +
                   (                                     +
                   SUBPARTITION sp2 START (20) END (25), +
                   SUBPARTITION sp3 START (25) END (30)  +
                   )                                     +
           )
(1 row)

-- MPP-10480: dump templates (but don't use "foo")
create table MPP10480 (a int, b int, d int)
partition by range (b)
subpartition by range(d)
subpartition template (start (1) end (10) every (1))
(start (20) end (30) every (1));
NOTICE:  Table doesn't have 'DISTRIBUTED BY' clause -- Using column named 'a' as the Greenplum Database data distribution key for this table.
HINT:  The 'DISTRIBUTED BY' clause determines the distribution of data. Make sure column(s) chosen are the optimal data distribution key to minimize skew.
NOTICE:  CREATE TABLE will create partition "mpp10480_1_prt_1" for table "mpp10480"
NOTICE:  CREATE TABLE will create partition "mpp10480_1_prt_1_2_prt_1" for table "mpp10480_1_prt_1"
NOTICE:  CREATE TABLE will create partition "mpp10480_1_prt_1_2_prt_2" for table "mpp10480_1_prt_1"
NOTICE:  CREATE TABLE will create partition "mpp10480_1_prt_1_2_prt_3" for table "mpp10480_1_prt_1"
NOTICE:  CREATE TABLE will create partition "mpp10480_1_prt_1_2_prt_4" for table "mpp10480_1_prt_1"
NOTICE:  CREATE TABLE will create partition "mpp10480_1_prt_1_2_prt_5" for table "mpp10480_1_prt_1"
NOTICE:  CREATE TABLE will create partition "mpp10480_1_prt_1_2_prt_6" for table "mpp10480_1_prt_1"
NOTICE:  CREATE TABLE will create partition "mpp10480_1_prt_1_2_prt_7" for table "mpp10480_1_prt_1"
NOTICE:  CREATE TABLE will create partition "mpp10480_1_prt_1_2_prt_8" for table "mpp10480_1_prt_1"
NOTICE:  CREATE TABLE will create partition "mpp10480_1_prt_1_2_prt_9" for table "mpp10480_1_prt_1"
NOTICE:  CREATE TABLE will create partition "mpp10480_1_prt_2" for table "mpp10480"
NOTICE:  CREATE TABLE will create partition "mpp10480_1_prt_2_2_prt_1" for table "mpp10480_1_prt_2"
NOTICE:  CREATE TABLE will create partition "mpp10480_1_prt_2_2_prt_2" for table "mpp10480_1_prt_2"
NOTICE:  CREATE TABLE will create partition "mpp10480_1_prt_2_2_prt_3" for table "mpp10480_1_prt_2"
NOTICE:  CREATE TABLE will create partition "mpp10480_1_prt_2_2_prt_4" for table "mpp10480_1_prt_2"
NOTICE:  CREATE TABLE will create partition "mpp10480_1_prt_2_2_prt_5" for table "mpp10480_1_prt_2"
NOTICE:  CREATE TABLE will create partition "mpp10480_1_prt_2_2_prt_6" for table "mpp10480_1_prt_2"
NOTICE:  CREATE TABLE will create partition "mpp10480_1_prt_2_2_prt_7" for table "mpp10480_1_prt_2"
NOTICE:  CREATE TABLE will create partition "mpp10480_1_prt_2_2_prt_8" for table "mpp10480_1_prt_2"
NOTICE:  CREATE TABLE will create partition "mpp10480_1_prt_2_2_prt_9" for table "mpp10480_1_prt_2"
NOTICE:  CREATE TABLE will create partition "mpp10480_1_prt_3" for table "mpp10480"
NOTICE:  CREATE TABLE will create partition "mpp10480_1_prt_3_2_prt_1" for table "mpp10480_1_prt_3"
NOTICE:  CREATE TABLE will create partition "mpp10480_1_prt_3_2_prt_2" for table "mpp10480_1_prt_3"
NOTICE:  CREATE TABLE will create partition "mpp10480_1_prt_3_2_prt_3" for table "mpp10480_1_prt_3"
NOTICE:  CREATE TABLE will create partition "mpp10480_1_prt_3_2_prt_4" for table "mpp10480_1_prt_3"
NOTICE:  CREATE TABLE will create partition "mpp10480_1_prt_3_2_prt_5" for table "mpp10480_1_prt_3"
NOTICE:  CREATE TABLE will create partition "mpp10480_1_prt_3_2_prt_6" for table "mpp10480_1_prt_3"
NOTICE:  CREATE TABLE will create partition "mpp10480_1_prt_3_2_prt_7" for table "mpp10480_1_prt_3"
NOTICE:  CREATE TABLE will create partition "mpp10480_1_prt_3_2_prt_8" for table "mpp10480_1_prt_3"
NOTICE:  CREATE TABLE will create partition "mpp10480_1_prt_3_2_prt_9" for table "mpp10480_1_prt_3"
NOTICE:  CREATE TABLE will create partition "mpp10480_1_prt_4" for table "mpp10480"
NOTICE:  CREATE TABLE will create partition "mpp10480_1_prt_4_2_prt_1" for table "mpp10480_1_prt_4"
NOTICE:  CREATE TABLE will create partition "mpp10480_1_prt_4_2_prt_2" for table "mpp10480_1_prt_4"
NOTICE:  CREATE TABLE will create partition "mpp10480_1_prt_4_2_prt_3" for table "mpp10480_1_prt_4"
NOTICE:  CREATE TABLE will create partition "mpp10480_1_prt_4_2_prt_4" for table "mpp10480_1_prt_4"
NOTICE:  CREATE TABLE will create partition "mpp10480_1_prt_4_2_prt_5" for table "mpp10480_1_prt_4"
NOTICE:  CREATE TABLE will create partition "mpp10480_1_prt_4_2_prt_6" for table "mpp10480_1_prt_4"
NOTICE:  CREATE TABLE will create partition "mpp10480_1_prt_4_2_prt_7" for table "mpp10480_1_prt_4"
NOTICE:  CREATE TABLE will create partition "mpp10480_1_prt_4_2_prt_8" for table "mpp10480_1_prt_4"
NOTICE:  CREATE TABLE will create partition "mpp10480_1_prt_4_2_prt_9" for table "mpp10480_1_prt_4"
NOTICE:  CREATE TABLE will create partition "mpp10480_1_prt_5" for table "mpp10480"
NOTICE:  CREATE TABLE will create partition "mpp10480_1_prt_5_2_prt_1" for table "mpp10480_1_prt_5"
NOTICE:  CREATE TABLE will create partition "mpp10480_1_prt_5_2_prt_2" for table "mpp10480_1_prt_5"
NOTICE:  CREATE TABLE will create partition "mpp10480_1_prt_5_2_prt_3" for table "mpp10480_1_prt_5"
NOTICE:  CREATE TABLE will create partition "mpp10480_1_prt_5_2_prt_4" for table "mpp10480_1_prt_5"
NOTICE:  CREATE TABLE will create partition "mpp10480_1_prt_5_2_prt_5" for table "mpp10480_1_prt_5"
NOTICE:  CREATE TABLE will create partition "mpp10480_1_prt_5_2_prt_6" for table "mpp10480_1_prt_5"
NOTICE:  CREATE TABLE will create partition "mpp10480_1_prt_5_2_prt_7" for table "mpp10480_1_prt_5"
NOTICE:  CREATE TABLE will create partition "mpp10480_1_prt_5_2_prt_8" for table "mpp10480_1_prt_5"
NOTICE:  CREATE TABLE will create partition "mpp10480_1_prt_5_2_prt_9" for table "mpp10480_1_prt_5"
NOTICE:  CREATE TABLE will create partition "mpp10480_1_prt_6" for table "mpp10480"
NOTICE:  CREATE TABLE will create partition "mpp10480_1_prt_6_2_prt_1" for table "mpp10480_1_prt_6"
NOTICE:  CREATE TABLE will create partition "mpp10480_1_prt_6_2_prt_2" for table "mpp10480_1_prt_6"
NOTICE:  CREATE TABLE will create partition "mpp10480_1_prt_6_2_prt_3" for table "mpp10480_1_prt_6"
NOTICE:  CREATE TABLE will create partition "mpp10480_1_prt_6_2_prt_4" for table "mpp10480_1_prt_6"
NOTICE:  CREATE TABLE will create partition "mpp10480_1_prt_6_2_prt_5" for table "mpp10480_1_prt_6"
NOTICE:  CREATE TABLE will create partition "mpp10480_1_prt_6_2_prt_6" for table "mpp10480_1_prt_6"
NOTICE:  CREATE TABLE will create partition "mpp10480_1_prt_6_2_prt_7" for table "mpp10480_1_prt_6"
NOTICE:  CREATE TABLE will create partition "mpp10480_1_prt_6_2_prt_8" for table "mpp10480_1_prt_6"
NOTICE:  CREATE TABLE will create partition "mpp10480_1_prt_6_2_prt_9" for table "mpp10480_1_prt_6"
NOTICE:  CREATE TABLE will create partition "mpp10480_1_prt_7" for table "mpp10480"
NOTICE:  CREATE TABLE will create partition "mpp10480_1_prt_7_2_prt_1" for table "mpp10480_1_prt_7"
NOTICE:  CREATE TABLE will create partition "mpp10480_1_prt_7_2_prt_2" for table "mpp10480_1_prt_7"
NOTICE:  CREATE TABLE will create partition "mpp10480_1_prt_7_2_prt_3" for table "mpp10480_1_prt_7"
NOTICE:  CREATE TABLE will create partition "mpp10480_1_prt_7_2_prt_4" for table "mpp10480_1_prt_7"
NOTICE:  CREATE TABLE will create partition "mpp10480_1_prt_7_2_prt_5" for table "mpp10480_1_prt_7"
NOTICE:  CREATE TABLE will create partition "mpp10480_1_prt_7_2_prt_6" for table "mpp10480_1_prt_7"
NOTICE:  CREATE TABLE will create partition "mpp10480_1_prt_7_2_prt_7" for table "mpp10480_1_prt_7"
NOTICE:  CREATE TABLE will create partition "mpp10480_1_prt_7_2_prt_8" for table "mpp10480_1_prt_7"
NOTICE:  CREATE TABLE will create partition "mpp10480_1_prt_7_2_prt_9" for table "mpp10480_1_prt_7"
NOTICE:  CREATE TABLE will create partition "mpp10480_1_prt_8" for table "mpp10480"
NOTICE:  CREATE TABLE will create partition "mpp10480_1_prt_8_2_prt_1" for table "mpp10480_1_prt_8"
NOTICE:  CREATE TABLE will create partition "mpp10480_1_prt_8_2_prt_2" for table "mpp10480_1_prt_8"
NOTICE:  CREATE TABLE will create partition "mpp10480_1_prt_8_2_prt_3" for table "mpp10480_1_prt_8"
NOTICE:  CREATE TABLE will create partition "mpp10480_1_prt_8_2_prt_4" for table "mpp10480_1_prt_8"
NOTICE:  CREATE TABLE will create partition "mpp10480_1_prt_8_2_prt_5" for table "mpp10480_1_prt_8"
NOTICE:  CREATE TABLE will create partition "mpp10480_1_prt_8_2_prt_6" for table "mpp10480_1_prt_8"
NOTICE:  CREATE TABLE will create partition "mpp10480_1_prt_8_2_prt_7" for table "mpp10480_1_prt_8"
NOTICE:  CREATE TABLE will create partition "mpp10480_1_prt_8_2_prt_8" for table "mpp10480_1_prt_8"
NOTICE:  CREATE TABLE will create partition "mpp10480_1_prt_8_2_prt_9" for table "mpp10480_1_prt_8"
NOTICE:  CREATE TABLE will create partition "mpp10480_1_prt_9" for table "mpp10480"
NOTICE:  CREATE TABLE will create partition "mpp10480_1_prt_9_2_prt_1" for table "mpp10480_1_prt_9"
NOTICE:  CREATE TABLE will create partition "mpp10480_1_prt_9_2_prt_2" for table "mpp10480_1_prt_9"
NOTICE:  CREATE TABLE will create partition "mpp10480_1_prt_9_2_prt_3" for table "mpp10480_1_prt_9"
NOTICE:  CREATE TABLE will create partition "mpp10480_1_prt_9_2_prt_4" for table "mpp10480_1_prt_9"
NOTICE:  CREATE TABLE will create partition "mpp10480_1_prt_9_2_prt_5" for table "mpp10480_1_prt_9"
NOTICE:  CREATE TABLE will create partition "mpp10480_1_prt_9_2_prt_6" for table "mpp10480_1_prt_9"
NOTICE:  CREATE TABLE will create partition "mpp10480_1_prt_9_2_prt_7" for table "mpp10480_1_prt_9"
NOTICE:  CREATE TABLE will create partition "mpp10480_1_prt_9_2_prt_8" for table "mpp10480_1_prt_9"
NOTICE:  CREATE TABLE will create partition "mpp10480_1_prt_9_2_prt_9" for table "mpp10480_1_prt_9"
NOTICE:  CREATE TABLE will create partition "mpp10480_1_prt_10" for table "mpp10480"
NOTICE:  CREATE TABLE will create partition "mpp10480_1_prt_10_2_prt_1" for table "mpp10480_1_prt_10"
NOTICE:  CREATE TABLE will create partition "mpp10480_1_prt_10_2_prt_2" for table "mpp10480_1_prt_10"
NOTICE:  CREATE TABLE will create partition "mpp10480_1_prt_10_2_prt_3" for table "mpp10480_1_prt_10"
NOTICE:  CREATE TABLE will create partition "mpp10480_1_prt_10_2_prt_4" for table "mpp10480_1_prt_10"
NOTICE:  CREATE TABLE will create partition "mpp10480_1_prt_10_2_prt_5" for table "mpp10480_1_prt_10"
NOTICE:  CREATE TABLE will create partition "mpp10480_1_prt_10_2_prt_6" for table "mpp10480_1_prt_10"
NOTICE:  CREATE TABLE will create partition "mpp10480_1_prt_10_2_prt_7" for table "mpp10480_1_prt_10"
NOTICE:  CREATE TABLE will create partition "mpp10480_1_prt_10_2_prt_8" for table "mpp10480_1_prt_10"
NOTICE:  CREATE TABLE will create partition "mpp10480_1_prt_10_2_prt_9" for table "mpp10480_1_prt_10"
select pg_get_partition_template_def('MPP10480'::regclass, true, true);
                    pg_get_partition_template_def                    
---------------------------------------------------------------------
 ALTER TABLE mpp10480                                               +
 SET SUBPARTITION TEMPLATE                                          +
           (                                                        +
           START (1) END (2) EVERY (1) WITH (tablename='mpp10480'), +
           START (2) END (3) EVERY (1) WITH (tablename='mpp10480'), +
           START (3) END (4) EVERY (1) WITH (tablename='mpp10480'), +
           START (4) END (5) EVERY (1) WITH (tablename='mpp10480'), +
           START (5) END (6) EVERY (1) WITH (tablename='mpp10480'), +
           START (6) END (7) EVERY (1) WITH (tablename='mpp10480'), +
           START (7) END (8) EVERY (1) WITH (tablename='mpp10480'), +
           START (8) END (9) EVERY (1) WITH (tablename='mpp10480'), +
           START (9) END (10) EVERY (1) WITH (tablename='mpp10480') +
           )                                                        +
 
(1 row)

-- MPP-10421: fix SPLIT of partitions with PRIMARY KEY constraint/indexes
CREATE TABLE mpp10321a
(
        rnc VARCHAR(100),
        wbts VARCHAR(100),
        axc VARCHAR(100),
        vptt VARCHAR(100),
        vcct VARCHAR(100),
        agg_level CHAR(5),
        period_start_time TIMESTAMP WITH TIME ZONE,
        load_time TIMESTAMP WITH TIME ZONE DEFAULT now(),
        interval INTEGER,
        totcellsegress double precision,
        totcellsingress double precision,
  CONSTRAINT "mpp10321a_pk"
PRIMARY KEY (rnc,wbts,axc,vptt,vcct,agg_level,period_start_time)
)
DISTRIBUTED BY (rnc,wbts,axc,vptt,vcct)
PARTITION BY LIST (AGG_LEVEL)
  SUBPARTITION BY RANGE (PERIOD_START_TIME)
(
  PARTITION min15part  VALUES ('15min')
    (
         SUBPARTITION P_FUTURE  START (date '2001-01-01') INCLUSIVE,
         SUBPARTITION P_ENDPART START (date '2999-12-30') INCLUSIVE
                                END (date '2999-12-31') EXCLUSIVE
    ),
  PARTITION hourpart   VALUES ('hour')
    (
          SUBPARTITION P20100622 START (date '2010-06-22') INCLUSIVE,
          SUBPARTITION P_ENDPART START (date '2999-12-30') INCLUSIVE
                                 END (date '2999-12-31') EXCLUSIVE
    )
);
NOTICE:  CREATE TABLE will create partition "mpp10321a_1_prt_min15part" for table "mpp10321a"
NOTICE:  CREATE TABLE will create partition "mpp10321a_1_prt_hourpart" for table "mpp10321a"
NOTICE:  CREATE TABLE will create partition "mpp10321a_1_prt_min15part_2_prt_p_future" for table "mpp10321a_1_prt_min15part"
NOTICE:  CREATE TABLE will create partition "mpp10321a_1_prt_min15part_2_prt_p_endpart" for table "mpp10321a_1_prt_min15part"
NOTICE:  CREATE TABLE will create partition "mpp10321a_1_prt_hourpart_2_prt_p20100622" for table "mpp10321a_1_prt_hourpart"
NOTICE:  CREATE TABLE will create partition "mpp10321a_1_prt_hourpart_2_prt_p_endpart" for table "mpp10321a_1_prt_hourpart"
ALTER TABLE mpp10321a
ALTER PARTITION min15part
SPLIT PARTITION  P_FUTURE AT ('2010-06-25')
INTO (PARTITION P20010101, PARTITION P_FUTURE);
NOTICE:  exchanged partition "p_future" of partition "min15part" of relation "mpp10321a" with relation "pg_temp_4055957"
NOTICE:  dropped partition "p_future" for partition "min15part" of relation "mpp10321a"
NOTICE:  CREATE TABLE will create partition "mpp10321a_1_prt_min15part_2_prt_p20010101" for table "mpp10321a_1_prt_min15part"
NOTICE:  CREATE TABLE will create partition "mpp10321a_1_prt_min15part_2_prt_p_future" for table "mpp10321a_1_prt_min15part"
DROP TABLE mpp10321a;
-- test for default partition with boundary spec
create table bhagp_range (a int, b int) 
distributed by (a) 
partition by range (b) 
( 
  default partition x 
  start (0) inclusive 
  end (2) exclusive 
  every (1) 
);
ERROR:  invalid use of boundary specification for DEFAULT partition "x"
LINE 5:   default partition x 
          ^
create table bhagp_list (a int, b int) 
distributed by (a) 
partition by list (b) 
( 
  default partition x 
  values (1,2)
);
ERROR:  invalid use of boundary specification for DEFAULT partition "x"
LINE 5:   default partition x 
          ^
-- more coverage tests
-- bad partition by type
create table cov1 (a int, b int)
distributed by (a)
partition by (b)
(
start (1) end (10) every (1)
);
ERROR:  PARTITION BY must specify RANGE or LIST
-- bad partition by type
create table cov1 (a int, b int)
distributed by (a)
partition by funky (b)
(
start (1) end (10) every (1)
);
ERROR:  PARTITION BY must specify RANGE or LIST
drop table cov1;
ERROR:  table "cov1" does not exist
create table cov1 (a int, b int)
distributed by (a)
partition by range (b)
(
start (1) end (10) every (1)
);
NOTICE:  CREATE TABLE will create partition "cov1_1_prt_1" for table "cov1"
NOTICE:  CREATE TABLE will create partition "cov1_1_prt_2" for table "cov1"
NOTICE:  CREATE TABLE will create partition "cov1_1_prt_3" for table "cov1"
NOTICE:  CREATE TABLE will create partition "cov1_1_prt_4" for table "cov1"
NOTICE:  CREATE TABLE will create partition "cov1_1_prt_5" for table "cov1"
NOTICE:  CREATE TABLE will create partition "cov1_1_prt_6" for table "cov1"
NOTICE:  CREATE TABLE will create partition "cov1_1_prt_7" for table "cov1"
NOTICE:  CREATE TABLE will create partition "cov1_1_prt_8" for table "cov1"
NOTICE:  CREATE TABLE will create partition "cov1_1_prt_9" for table "cov1"
-- syntax error
alter table cov1 drop partition for (funky(1));
ERROR:  syntax error at or near ")"
LINE 1: alter table cov1 drop partition for (funky(1));
                                                     ^
-- no rank for default
alter table cov1 drop default partition for (rank(1));
ERROR:  cannot specify a name, rank, or value for a DEFAULT partition in this context
-- no default
alter table cov1 split default partition at (9);
ERROR:  DEFAULT partition of relation "cov1" does not exist
alter table cov1 drop default partition;
ERROR:  DEFAULT partition of relation "cov1" does not exist
-- cannot add except by name
alter table cov1 add partition for (rank(1));
ERROR:  can only ADD a partition by name
-- bad template
alter table cov1 set subpartition template (values (1,2) (values (2,3)));
ERROR:  template cannot contain specification for child partition
-- create and drop default partition in one statement!
alter table cov1 add default partition def1, drop default partition;
NOTICE:  CREATE TABLE will create partition "cov1_1_prt_def1" for table "cov1"
NOTICE:  dropped partition "def1" for relation "cov1"
drop table cov1;
-- every 5 (1) now disallowed...
create table cov1 (a int, b int)
distributed by (a)
partition by range (b)
(
start (1) end(20) every 5 (1)
);
ERROR:  syntax error at or near "5"
LINE 5: start (1) end(20) every 5 (1)
                                ^
drop table if exists cov1;
NOTICE:  table "cov1" does not exist, skipping
create table cov1 (a int, b int)
distributed by (a)
partition by list (b)
(
partition p1 values (1,2,3,4,5,6,7,8)
);
NOTICE:  CREATE TABLE will create partition "cov1_1_prt_p1" for table "cov1"
-- bad split
alter table cov1 split partition p1 at (5,50);
ERROR:  AT clause parameter is not a member of the target partition specification
-- good split
alter table cov1 split partition p1 at (5,6,7) 
into (partition p1, partition p2);
NOTICE:  exchanged partition "p1" of relation "cov1" with relation "pg_temp_4057081"
NOTICE:  dropped partition "p1" for relation "cov1"
NOTICE:  CREATE TABLE will create partition "cov1_1_prt_p1" for table "cov1"
NOTICE:  CREATE TABLE will create partition "cov1_1_prt_p2" for table "cov1"
select partitionboundary from pg_partitions where tablename = 'cov1';
         partitionboundary          
------------------------------------
 PARTITION p1 VALUES(1, 2, 3, 4, 8)
 PARTITION p2 VALUES(5, 6, 7)
(2 rows)

drop table cov1;
-- MPP-11120
--  ADD PARTITION didn't explicitly specify the distribution policy in the
-- CreateStmt distributedBy field and as such we followed the behaviour encoded
-- in transformDistributedBy(). Unfortunately, it chooses to set the
-- distribution policy to that of the primary key if the distribution policy
-- is not explicitly set.
create table test_table (
	a	int,
	b	int,
	c	int,
	primary key (a,b,c)
)
distributed by (a)
partition by range (b)
(
	default partition default_partition,
	partition p1 start (1) end (2)
);
NOTICE:  CREATE TABLE will create partition "test_table_1_prt_default_partition" for table "test_table"
NOTICE:  CREATE TABLE will create partition "test_table_1_prt_p1" for table "test_table"
insert into test_table values(1,2,3);
select * from test_table; -- expected: (1,2,3)
 a | b | c 
---+---+---
 1 | 2 | 3
(1 row)

delete from test_table where a=1 and b=2 and c=3; -- this should delete the row in test_table
select * from test_table; -- expected, no rows
 a | b | c 
---+---+---
(0 rows)

insert into test_table values(1,2,3); -- reinsert data
-- all partitions should have same distribution policy
select relname, distkey as distribution_attributes from
gp_distribution_policy p, pg_class c
where p.localoid = c.oid and relname like 'test_table%' order by p.localoid;
              relname               | distribution_attributes 
------------------------------------+-------------------------
 test_table                         | 1
 test_table_1_prt_default_partition | 1
 test_table_1_prt_p1                | 1
(3 rows)

alter table test_table split default partition
        start (3)
	end (4)
	into (partition p2, partition default_partition);
NOTICE:  exchanged partition "default_partition" of relation "test_table" with relation "pg_temp_4057318"
NOTICE:  dropped partition "default_partition" for relation "test_table"
NOTICE:  CREATE TABLE will create partition "test_table_1_prt_p2" for table "test_table"
NOTICE:  CREATE TABLE will create partition "test_table_1_prt_default_partition" for table "test_table"
select relname, distkey as distribution_attributes from
gp_distribution_policy p, pg_class c where p.localoid = c.oid and 
relname like 'test_table%' order by p.localoid;
              relname               | distribution_attributes 
------------------------------------+-------------------------
 test_table                         | 1
 test_table_1_prt_p1                | 1
 test_table_1_prt_p2                | 1
 test_table_1_prt_default_partition | 1
(4 rows)

delete from test_table where a=1 and b=2 and c=3; -- this should delete the row in test_table
select * from test_table; -- expected, no rows! But we see the row. Wrong results!
 a | b | c 
---+---+---
(0 rows)

alter table test_table drop partition default_partition;
alter table test_table add partition foo start(10) end(20);
NOTICE:  CREATE TABLE will create partition "test_table_1_prt_foo" for table "test_table"
select relname, distkey as distribution_attributes from
gp_distribution_policy p, pg_class c where p.localoid = c.oid and
relname like 'test_table%' order by p.localoid;
       relname        | distribution_attributes 
----------------------+-------------------------
 test_table           | 1
 test_table_1_prt_p1  | 1
 test_table_1_prt_p2  | 1
 test_table_1_prt_foo | 1
(4 rows)

drop table test_table;
-- MPP-6979: EXCHANGE partitions - fix namespaces if they differ
-- new schema
create schema mpp6979dummy;
create table mpp6979part(a int, b int) 
partition by range(b) 
(
start (1) end (10) every (1)
);
NOTICE:  Table doesn't have 'DISTRIBUTED BY' clause -- Using column named 'a' as the Greenplum Database data distribution key for this table.
HINT:  The 'DISTRIBUTED BY' clause determines the distribution of data. Make sure column(s) chosen are the optimal data distribution key to minimize skew.
NOTICE:  CREATE TABLE will create partition "mpp6979part_1_prt_1" for table "mpp6979part"
NOTICE:  CREATE TABLE will create partition "mpp6979part_1_prt_2" for table "mpp6979part"
NOTICE:  CREATE TABLE will create partition "mpp6979part_1_prt_3" for table "mpp6979part"
NOTICE:  CREATE TABLE will create partition "mpp6979part_1_prt_4" for table "mpp6979part"
NOTICE:  CREATE TABLE will create partition "mpp6979part_1_prt_5" for table "mpp6979part"
NOTICE:  CREATE TABLE will create partition "mpp6979part_1_prt_6" for table "mpp6979part"
NOTICE:  CREATE TABLE will create partition "mpp6979part_1_prt_7" for table "mpp6979part"
NOTICE:  CREATE TABLE will create partition "mpp6979part_1_prt_8" for table "mpp6979part"
NOTICE:  CREATE TABLE will create partition "mpp6979part_1_prt_9" for table "mpp6979part"
-- append-only table in new schema 
create table mpp6979dummy.mpp6979tab(like mpp6979part) with (appendonly=true);
NOTICE:  table doesn't have 'DISTRIBUTED BY' clause, defaulting to distribution columns from LIKE table
-- check that table and all parts in public schema
select schemaname, tablename, partitionschemaname, partitiontablename
from pg_partitions 
where tablename like ('mpp6979%');
 schemaname |  tablename  | partitionschemaname | partitiontablename  
------------+-------------+---------------------+---------------------
 public     | mpp6979part | public              | mpp6979part_1_prt_1
 public     | mpp6979part | public              | mpp6979part_1_prt_2
 public     | mpp6979part | public              | mpp6979part_1_prt_3
 public     | mpp6979part | public              | mpp6979part_1_prt_4
 public     | mpp6979part | public              | mpp6979part_1_prt_5
 public     | mpp6979part | public              | mpp6979part_1_prt_6
 public     | mpp6979part | public              | mpp6979part_1_prt_7
 public     | mpp6979part | public              | mpp6979part_1_prt_8
 public     | mpp6979part | public              | mpp6979part_1_prt_9
(9 rows)

-- note that we have heap partitions in public, and ao table in mpp6979dummy
select nspname, relname, relstorage from pg_class pc, pg_namespace ns 
where
pc.relnamespace=ns.oid and relname like ('mpp6979%');
   nspname    |       relname       | relstorage 
--------------+---------------------+------------
 public       | mpp6979part_1_prt_1 | h
 public       | mpp6979part_1_prt_2 | h
 public       | mpp6979part_1_prt_3 | h
 public       | mpp6979part_1_prt_4 | h
 public       | mpp6979part_1_prt_5 | h
 public       | mpp6979part_1_prt_6 | h
 public       | mpp6979part_1_prt_7 | h
 public       | mpp6979part_1_prt_8 | h
 public       | mpp6979part_1_prt_9 | h
 public       | mpp6979part         | h
 mpp6979dummy | mpp6979tab          | a
(11 rows)

-- exchange the partition with the ao table.  
-- Now we have an ao partition and mpp6979tab is heap!
alter table mpp6979part exchange partition for (rank(1)) 
with table mpp6979dummy.mpp6979tab;
-- after the exchange, all partitions are still in public
select schemaname, tablename, partitionschemaname, partitiontablename
from pg_partitions 
where tablename like ('mpp6979%');
 schemaname |  tablename  | partitionschemaname | partitiontablename  
------------+-------------+---------------------+---------------------
 public     | mpp6979part | public              | mpp6979part_1_prt_1
 public     | mpp6979part | public              | mpp6979part_1_prt_2
 public     | mpp6979part | public              | mpp6979part_1_prt_3
 public     | mpp6979part | public              | mpp6979part_1_prt_4
 public     | mpp6979part | public              | mpp6979part_1_prt_5
 public     | mpp6979part | public              | mpp6979part_1_prt_6
 public     | mpp6979part | public              | mpp6979part_1_prt_7
 public     | mpp6979part | public              | mpp6979part_1_prt_8
 public     | mpp6979part | public              | mpp6979part_1_prt_9
(9 rows)

-- the rank 1 partition is ao, but still in public, and 
-- table mpp6979tab is now heap, but still in mpp6979dummy
select nspname, relname, relstorage from pg_class pc, pg_namespace ns 
where
pc.relnamespace=ns.oid and relname like ('mpp6979%');
   nspname    |       relname       | relstorage 
--------------+---------------------+------------
 public       | mpp6979part_1_prt_2 | h
 public       | mpp6979part_1_prt_3 | h
 public       | mpp6979part_1_prt_4 | h
 public       | mpp6979part_1_prt_5 | h
 public       | mpp6979part_1_prt_6 | h
 public       | mpp6979part_1_prt_7 | h
 public       | mpp6979part_1_prt_8 | h
 public       | mpp6979part_1_prt_9 | h
 public       | mpp6979part         | h
 public       | mpp6979part_1_prt_1 | a
 mpp6979dummy | mpp6979tab          | h
(11 rows)

drop table mpp6979part;
drop table mpp6979dummy.mpp6979tab;
drop schema mpp6979dummy;
-- MPP-7898:
create table parent_s
    (a int, b text) 
    distributed by (a);
    
insert into parent_s values
    (1, 'one');
-- Try to create a table that mixes inheritance and partitioning.
-- Correct behavior: ERROR
create table child_r
    ( c int, d int) 
    inherits (parent_s)
    partition by range(d) 
    (
        start (0) 
        end (2) 
        every (1)
    );
ERROR:  cannot mix inheritance with partitioning
 -- If (incorrectly) the previous statement works, the next one is 
 -- likely to fail with in unexpected internal error.  This is residual 
 -- issue MPP-7898.
insert into child_r values
    (0, 'from r', 0, 0);
ERROR:  relation "child_r" does not exist
LINE 1: insert into child_r values
                    ^
drop table if exists parent_s cascade; --ignore
drop table if exists child_r cascade; --ignore
NOTICE:  table "child_r" does not exist, skipping
create table parent_r
    ( a int, b text, c int, d int ) 
    distributed by (a)
    partition by range(d) 
    (
        start (0) 
        end (2) 
        every (1)
    );
NOTICE:  CREATE TABLE will create partition "parent_r_1_prt_1" for table "parent_r"
NOTICE:  CREATE TABLE will create partition "parent_r_1_prt_2" for table "parent_r"
 
insert into parent_r values
    (0, 'from r', 0, 0);
create table parent_s
    ( a int, b text, c int, d int ) 
    distributed by (a);
    
insert into parent_s values
    (1, 'from s', 555, 555);
create table child_t
    ( )
    inherits (parent_s)
    distributed by (a);
insert into child_t values
    (0, 'from t', 666, 666);
-- Try to exchange in the child and parent.  
-- Correct behavior: ERROR in both cases.
alter table parent_r exchange partition for (1) with table child_t;
ERROR:  cannot exchange table "child_t" as it inherits other table(s)
alter table parent_r exchange partition for (1) with table parent_s;
ERROR:  cannot EXCHANGE table "parent_s" as it has child table(s)
drop table child_t cascade; --ignore
drop table parent_s cascade; --ignore
drop table parent_r cascade; --ignore
-- MPP-7898 end.
-- ( MPP-13750 
CREATE TABLE s (id int, date date, amt decimal(10,2), units int) 
DISTRIBUTED BY (id) 
PARTITION BY RANGE (date) 
( START (date '2008-01-01') INCLUSIVE 
   END (date '2008-01-02') EXCLUSIVE 
   EVERY (INTERVAL '1 day') );
NOTICE:  CREATE TABLE will create partition "s_1_prt_1" for table "s"
create index s_i on s(amt) 
  where (id > 1)
  ;
NOTICE:  building index for child partition "s_1_prt_1"
create index s_j on s(units)
  where (id <= 1)
  ;
NOTICE:  building index for child partition "s_1_prt_1"
create index s_i_expr on s(log(units));
NOTICE:  building index for child partition "s_1_prt_1"
alter table s add partition s_test 
    start(date '2008-01-03') end (date '2008-01-05');
NOTICE:  CREATE TABLE will create partition "s_1_prt_s_test" for table "s"
alter table s split partition for (date '2008-01-03') at (date '2008-01-04')
  into (partition s_test, partition s_test2);
NOTICE:  exchanged partition "s_test" of relation "s" with relation "pg_temp_4058400"
NOTICE:  dropped partition "s_test" for relation "s"
NOTICE:  CREATE TABLE will create partition "s_1_prt_s_test" for table "s"
NOTICE:  CREATE TABLE will create partition "s_1_prt_s_test2" for table "s"
select 
    relname, 
    (select count(distinct content) - 1 
     from gp_segment_configuration) - count(*) as missing, 
    count(distinct relid) oid_count 
from (
    select gp_execution_segment(), oid, relname 
    from gp_dist_random('pg_class') 
    ) seg_class(segid, relid, relname) 
where relname ~ '^s_' 
group by relname; 
          relname          | missing | oid_count 
---------------------------+---------+-----------
 s_1_prt_1_amt_idx         |       0 |         1
 s_1_prt_1_units_idx       |       0 |         1
 s_1_prt_s_test2_log_idx   |       0 |         1
 s_1_prt_s_test_log_idx1   |       0 |         1
 s_i_expr                  |       0 |         1
 s_j                       |       0 |         1
 s_1_prt_s_test2_amt_idx   |       0 |         1
 s_1_prt_s_test2_units_idx |       0 |         1
 s_1_prt_s_test_amt_idx1   |       0 |         1
 s_1_prt_s_test_units_idx1 |       0 |         1
 s_1_prt_1                 |       0 |         1
 s_1_prt_1_log_idx         |       0 |         1
 s_1_prt_s_test            |       0 |         1
 s_1_prt_s_test2           |       0 |         1
 s_i                       |       0 |         1
(15 rows)

drop table s cascade;
--   MPP-13750 )
-- MPP-13806 start
drop table if exists mpp13806;
NOTICE:  table "mpp13806" does not exist, skipping
 CREATE TABLE mpp13806 (id int, date date, amt decimal(10,2))
 DISTRIBUTED BY (id)
 PARTITION BY RANGE (date)
 ( START (date '2008-01-01') INCLUSIVE
	END (date '2008-01-05') EXCLUSIVE
	EVERY (INTERVAL '1 day') );
NOTICE:  CREATE TABLE will create partition "mpp13806_1_prt_1" for table "mpp13806"
NOTICE:  CREATE TABLE will create partition "mpp13806_1_prt_2" for table "mpp13806"
NOTICE:  CREATE TABLE will create partition "mpp13806_1_prt_3" for table "mpp13806"
NOTICE:  CREATE TABLE will create partition "mpp13806_1_prt_4" for table "mpp13806"
 
-- Adding unbound partition right before the start  used to fail
alter table mpp13806 add partition test end (date '2008-01-01') exclusive;
NOTICE:  CREATE TABLE will create partition "mpp13806_1_prt_test" for table "mpp13806"
 
drop table if exists mpp13806;
 CREATE TABLE mpp13806 (id int, date date, amt decimal(10,2))
 DISTRIBUTED BY (id)
 PARTITION BY RANGE (date)
 ( START (date '2008-01-01') EXCLUSIVE
	END (date '2008-01-05') EXCLUSIVE
	EVERY (INTERVAL '1 day') );
NOTICE:  CREATE TABLE will create partition "mpp13806_1_prt_1" for table "mpp13806"
NOTICE:  CREATE TABLE will create partition "mpp13806_1_prt_2" for table "mpp13806"
NOTICE:  CREATE TABLE will create partition "mpp13806_1_prt_3" for table "mpp13806"
NOTICE:  CREATE TABLE will create partition "mpp13806_1_prt_4" for table "mpp13806"
-- For good measure, test the opposite case
alter table mpp13806 add partition test end (date '2008-01-01') inclusive;
NOTICE:  CREATE TABLE will create partition "mpp13806_1_prt_test" for table "mpp13806"
drop table mpp13806;
-- MPP-13806 end
-- MPP-14471 start
-- No unenforceable PK/UK constraints!  (UNIQUE INDEXes still allowed; tested above)
drop table if exists tc cascade;
NOTICE:  table "tc" does not exist, skipping
drop table if exists cc cascade;
NOTICE:  table "cc" does not exist, skipping
drop table if exists at cascade;
NOTICE:  table "at" does not exist, skipping
create table tc
    (a int, b int, c int, primary key(a) )
    distributed by (a)
    partition by range (b)
    ( 
        default partition d,
        start (0) inclusive end(100) inclusive every (50)
    );
ERROR:  PRIMARY KEY constraint must contain all columns in the partition key
HINT:  Include column "b" in the PRIMARY KEY constraint or create a part-wise UNIQUE index after creating the table instead.
create table cc
    (a int primary key, b int, c int)
    distributed by (a)
    partition by range (b)
    ( 
        default partition d,
        start (0) inclusive end(100) inclusive every (50)
    );
ERROR:  PRIMARY KEY constraint must contain all columns in the partition key
HINT:  Include column "b" in the PRIMARY KEY constraint or create a part-wise UNIQUE index after creating the table instead.
create table at
    (a int, b int, c int)
    distributed by (a)
    partition by range (b)
    ( 
        default partition d,
        start (0) inclusive end(100) inclusive every (50)
    );
NOTICE:  CREATE TABLE will create partition "at_1_prt_d" for table "at"
NOTICE:  CREATE TABLE will create partition "at_1_prt_2" for table "at"
NOTICE:  CREATE TABLE will create partition "at_1_prt_3" for table "at"
alter table at
    add primary key (a);
ERROR:  PRIMARY KEY constraint must contain all columns in the partition key of relation "at"
HINT:  Include the partition key or create a part-wise UNIQUE index instead.
-- MPP-14471 end
-- MPP-17606 (using table "at" from above)
alter table at
    alter column b
	type numeric;
ERROR:  cannot alter type of a column used in a partitioning key
	
-- MPP-17606 end
-- MPP-17707 start
create table mpp17707
( d int, p int ,x text)
with (appendonly = true)
distributed by (d)
partition by range (p)
(start (0) end (3) every (2));
NOTICE:  CREATE TABLE will create partition "mpp17707_1_prt_1" for table "mpp17707"
NOTICE:  CREATE TABLE will create partition "mpp17707_1_prt_2" for table "mpp17707"
-- Create a expression index on the partitioned table
create index idx_abc on mpp17707(upper(x));
NOTICE:  building index for child partition "mpp17707_1_prt_1"
NOTICE:  building index for child partition "mpp17707_1_prt_2"
-- split partition 1 of table
alter table mpp17707 split partition for (0) at (1)
	into (partition x1, partition x2);
NOTICE:  CREATE TABLE will create partition "mpp17707_1_prt_x1" for table "mpp17707"
NOTICE:  CREATE TABLE will create partition "mpp17707_1_prt_x2" for table "mpp17707"
-- MPP-17707 end
-- MPP-17814 start
drop table if exists plst2 cascade;
NOTICE:  table "plst2" does not exist, skipping
-- positive; bug was that it failed whereas it should succeed
create table plst2
    (            
        a integer not null,
        b integer not null,
        c integer
    )                                                                                                                   
    distributed by (b) 
    partition by list (a,c)
    (
        partition p1 values ( (1, 2), (3, 4) ),
        partition p2 values ( (5, 6) ),
        partition p3 values ( (2, 1) )
    );
NOTICE:  CREATE TABLE will create partition "plst2_1_prt_p1" for table "plst2"
NOTICE:  CREATE TABLE will create partition "plst2_1_prt_p2" for table "plst2"
NOTICE:  CREATE TABLE will create partition "plst2_1_prt_p3" for table "plst2"
drop table if exists plst2 cascade;
--negative; test legitimate failure
create table plst2
    (            
        a integer not null,
        b integer not null,
        c integer
    )                                                                                                                   
    distributed by (b) 
    partition by list (a,c)
    (
        partition p1 values ( (1, 2), (3, 4) ),
        partition p2 values ( (5, 6) ),
        partition p3 values ( (1, 2) )
    );
ERROR:  duplicate VALUES in partition "p3"
LINE 12:         partition p3 values ( (1, 2) )
                              ^
-- postive; make sure inner part duplicates are accepted and quietly removed.
drop table if exists plst2;
NOTICE:  table "plst2" does not exist, skipping
create table plst2
    ( a int, b int)
    distributed by (a)
    partition by list (a, b) 
        (
            partition p0 values ((1,2), (3,4)),
            partition p1 values ((4,3), (2,1)),
            partition p2 values ((4,4),(5,5),(4,4),(5,5),(4,4),(5,5)),
            partition p3 values ((4,5),(5,6))
        );
NOTICE:  CREATE TABLE will create partition "plst2_1_prt_p0" for table "plst2"
NOTICE:  CREATE TABLE will create partition "plst2_1_prt_p1" for table "plst2"
NOTICE:  CREATE TABLE will create partition "plst2_1_prt_p2" for table "plst2"
NOTICE:  CREATE TABLE will create partition "plst2_1_prt_p3" for table "plst2"
-- positive; make sure legitimate alters work.
alter table plst2 add partition p4 values ((5,4),(6,5));
NOTICE:  CREATE TABLE will create partition "plst2_1_prt_p4" for table "plst2"
alter table plst2 add partition p5 values ((7,8),(7,8));
NOTICE:  CREATE TABLE will create partition "plst2_1_prt_p5" for table "plst2"
select conrelid::regclass, consrc  
from pg_constraint 
where conrelid in (
    select parchildrelid::regclass
    from pg_partition_rule
    where paroid in (
        select oid 
        from pg_partition 
        where parrelid = 'plst2'::regclass
        )
    );
    conrelid    |                      consrc                      
----------------+--------------------------------------------------
 plst2_1_prt_p0 | (((a = 1) AND (b = 2)) OR ((a = 3) AND (b = 4)))
 plst2_1_prt_p1 | (((a = 4) AND (b = 3)) OR ((a = 2) AND (b = 1)))
 plst2_1_prt_p2 | (((a = 4) AND (b = 4)) OR ((a = 5) AND (b = 5)))
 plst2_1_prt_p3 | (((a = 4) AND (b = 5)) OR ((a = 5) AND (b = 6)))
 plst2_1_prt_p4 | (((a = 5) AND (b = 4)) OR ((a = 6) AND (b = 5)))
 plst2_1_prt_p5 | ((a = 7) AND (b = 8))
(6 rows)

-- negative; make sure conflicting alters fail.
alter table plst2 add partition p6 values ((7,8),(2,1));
ERROR:  new partition definition overlaps existing partition "p5" of relation "plst2"
drop table if exists plst2;
-- MPP-17814 end
-- MPP-18441
create table s_heap (i1 int, t1 text, t2 text, i2 int, i3 int, n1 numeric, b1 bool)
partition by list (t1)
     (partition abc values('abc0', 'abc1', 'abc2'));
NOTICE:  Table doesn't have 'DISTRIBUTED BY' clause -- Using column named 'i1' as the Greenplum Database data distribution key for this table.
HINT:  The 'DISTRIBUTED BY' clause determines the distribution of data. Make sure column(s) chosen are the optimal data distribution key to minimize skew.
NOTICE:  CREATE TABLE will create partition "s_heap_1_prt_abc" for table "s_heap"
insert into s_heap (t1, i1, i2, i3, n1, b1) select 'abc0', 1, 1, 1, 2.3, true
    from generate_series(1, 5);
alter table s_heap drop column t2;
alter table s_heap drop column i3;
-- create co table for exchange
create table s_heap_ex_abc (i1 int, t1 text, f1 float, i2 int, n1 numeric, b1 bool)
    WITH (appendonly=true, orientation=column, compresstype=zlib);
NOTICE:  Table doesn't have 'DISTRIBUTED BY' clause -- Using column named 'i1' as the Greenplum Database data distribution key for this table.
HINT:  The 'DISTRIBUTED BY' clause determines the distribution of data. Make sure column(s) chosen are the optimal data distribution key to minimize skew.
alter table s_heap_ex_abc drop column f1;
insert into s_heap_ex_abc select 1, 'abc1', 2, 2, true from generate_series(1, 5);
-- exchange partition
alter table s_heap exchange partition abc with table s_heap_ex_abc;
alter table s_heap exchange partition abc with table s_heap_ex_abc;
drop table s_heap, s_heap_ex_abc;
-- MPP-18441 end
-- MPP-18443
create table s_heap (i1 int, t1 text, i2 int , i3 int, n1 numeric,b1 bool)
partition by list (t1)
    (partition def values('def0', 'def1', 'def2', 'def3', 'def4', 'def5', 'def6', 'def7', 'def8', 'def9'));
NOTICE:  Table doesn't have 'DISTRIBUTED BY' clause -- Using column named 'i1' as the Greenplum Database data distribution key for this table.
HINT:  The 'DISTRIBUTED BY' clause determines the distribution of data. Make sure column(s) chosen are the optimal data distribution key to minimize skew.
NOTICE:  CREATE TABLE will create partition "s_heap_1_prt_def" for table "s_heap"
insert into s_heap(t1, i1, i2, i3, n1, b1)
    select 'def0', 1, 1, 1, 2.3 , true from generate_series(1, 5);
alter table s_heap drop column i3;
create index s_heap_index on s_heap (i2);
NOTICE:  building index for child partition "s_heap_1_prt_def"
alter table s_heap split partition def
    at ('def0', 'def1', 'def2', 'def3', 'def4') into (partition def5, partition def0);
NOTICE:  exchanged partition "def" of relation "s_heap" with relation "pg_temp_4060677"
NOTICE:  dropped partition "def" for relation "s_heap"
NOTICE:  CREATE TABLE will create partition "s_heap_1_prt_def5" for table "s_heap"
NOTICE:  CREATE TABLE will create partition "s_heap_1_prt_def0" for table "s_heap"
select * from s_heap_1_prt_def0;
 i1 |  t1  | i2 | n1  | b1 
----+------+----+-----+----
  1 | def0 |  1 | 2.3 | t
  1 | def0 |  1 | 2.3 | t
  1 | def0 |  1 | 2.3 | t
  1 | def0 |  1 | 2.3 | t
  1 | def0 |  1 | 2.3 | t
(5 rows)

drop table s_heap;
-- MPP-18443 end
-- MPP-18445
create table s_heap_ao ( i1 int, t1 text, i2 int , i3 int, n1 numeric,b1 bool)
partition by list (t1)
    (partition def values('def0', 'def1', 'def2', 'def3', 'def4', 'def5', 'def6', 'def7', 'def8', 'def9')
        with (appendonly=true, orientation=row));
NOTICE:  Table doesn't have 'DISTRIBUTED BY' clause -- Using column named 'i1' as the Greenplum Database data distribution key for this table.
HINT:  The 'DISTRIBUTED BY' clause determines the distribution of data. Make sure column(s) chosen are the optimal data distribution key to minimize skew.
NOTICE:  CREATE TABLE will create partition "s_heap_ao_1_prt_def" for table "s_heap_ao"
insert into s_heap_ao(t1, i1, i2, i3, n1, b1)
    select 'def4', 1, 1, 1, 2.3, true from generate_series(1, 2);
insert into s_heap_ao(t1, i1, i2, i3, n1, b1)
    select 'def5', 1, 1, 1, 2.3, true from generate_series(1, 2);
alter table s_heap_ao drop column i3;
create index s_heap_ao_index on s_heap_ao (i2);
NOTICE:  building index for child partition "s_heap_ao_1_prt_def"
alter table s_heap_ao split partition def
    at ('def0', 'def1', 'def2', 'def3', 'def4') into (partition def5, partition def0);
NOTICE:  exchanged partition "def" of relation "s_heap_ao" with relation "pg_temp_4061000"
NOTICE:  dropped partition "def" for relation "s_heap_ao"
NOTICE:  CREATE TABLE will create partition "s_heap_ao_1_prt_def5" for table "s_heap_ao"
NOTICE:  CREATE TABLE will create partition "s_heap_ao_1_prt_def0" for table "s_heap_ao"
select * from s_heap_ao_1_prt_def0;
 i1 |  t1  | i2 | n1  | b1 
----+------+----+-----+----
  1 | def4 |  1 | 2.3 | t
  1 | def4 |  1 | 2.3 | t
(2 rows)

drop table s_heap_ao;
-- MPP-18445 end
-- MPP-18456
create table s_heap_co (i1 int, t1 text, i2 int, i3 int, n1 numeric, b1 bool)
partition by list (t1)
    (partition def values('def0', 'def1', 'def2', 'def3', 'def4', 'def5', 'def6', 'def7', 'def8', 'def9')
        with (appendonly=true, orientation=column));
NOTICE:  Table doesn't have 'DISTRIBUTED BY' clause -- Using column named 'i1' as the Greenplum Database data distribution key for this table.
HINT:  The 'DISTRIBUTED BY' clause determines the distribution of data. Make sure column(s) chosen are the optimal data distribution key to minimize skew.
NOTICE:  CREATE TABLE will create partition "s_heap_co_1_prt_def" for table "s_heap_co"
insert into s_heap_co(t1, i1, i2, i3, n1, b1)
    select 'def4', 1,1, 1, 2.3, true from generate_series(1, 2);
insert into s_heap_co(t1, i1, i2, i3, n1, b1)
    select 'def5', 1,1, 1, 2.3, true from generate_series(1, 2);
alter table s_heap_co drop column i3;
create index s_heap_co_index on s_heap_co (i2);
NOTICE:  building index for child partition "s_heap_co_1_prt_def"
alter table s_heap_co split partition def
    at ('def0', 'def1', 'def2', 'def3', 'def4') into (partition def5, partition def0);
NOTICE:  exchanged partition "def" of relation "s_heap_co" with relation "pg_temp_4061341"
NOTICE:  dropped partition "def" for relation "s_heap_co"
NOTICE:  CREATE TABLE will create partition "s_heap_co_1_prt_def5" for table "s_heap_co"
NOTICE:  CREATE TABLE will create partition "s_heap_co_1_prt_def0" for table "s_heap_co"
select * from s_heap_co_1_prt_def0;
 i1 |  t1  | i2 | n1  | b1 
----+------+----+-----+----
  1 | def4 |  1 | 2.3 | t
  1 | def4 |  1 | 2.3 | t
(2 rows)

drop table s_heap_co;
-- MPP-18456 end
-- MPP-18457, MPP-18415
CREATE TABLE non_ws_phone_leads (
    lead_key integer NOT NULL ENCODING (compresstype=zlib,compresslevel=1,blocksize=32768),
    source_system_lead_id character varying(60) NOT NULL ENCODING (compresstype=zlib,compresslevel=1,blocksize=32768),
    dim_event_type_key smallint NOT NULL ENCODING (compresstype=zlib,compresslevel=1,blocksize=32768),
    dim_site_key integer NOT NULL ENCODING (compresstype=zlib,compresslevel=1,blocksize=32768),
    dim_date_key integer NOT NULL ENCODING (compresstype=zlib,compresslevel=1,blocksize=32768),
    dim_time_key integer NOT NULL ENCODING (compresstype=zlib,compresslevel=1,blocksize=32768),
    dim_phone_number_key integer NOT NULL ENCODING (compresstype=zlib,compresslevel=1,blocksize=32768),
    duration_second smallint NOT NULL ENCODING (compresstype=zlib,compresslevel=1,blocksize=32768),
    dim_program_key smallint NOT NULL ENCODING (compresstype=zlib,compresslevel=1,blocksize=32768),
    dim_call_status_key integer NOT NULL ENCODING (compresstype=zlib,compresslevel=1,blocksize=32768),
    dim_phone_department_set_key smallint NOT NULL ENCODING (compresstype=zlib,compresslevel=1,blocksize=32768),
    dim_phone_channel_set_key smallint NOT NULL ENCODING (compresstype=zlib,compresslevel=1,blocksize=32768),
    dim_phone_provider_key smallint NOT NULL ENCODING (compresstype=zlib,compresslevel=1,blocksize=32768),
    dim_phone_ad_set_key smallint NOT NULL ENCODING (compresstype=zlib,compresslevel=1,blocksize=32768)
)
WITH (appendonly=true, compresstype=zlib, orientation=column) DISTRIBUTED BY (dim_site_key ,dim_date_key) PARTITION BY RANGE(dim_date_key) 
          (
          PARTITION p_max START (2451545) END (9999999) WITH (tablename='non_ws_phone_leads_1_prt_p_max', orientation=column, appendonly=true ) 
                    COLUMN lead_key ENCODING (compresstype=zlib, compresslevel=1, blocksize=32768) 
                    COLUMN source_system_lead_id ENCODING (compresstype=zlib, compresslevel=1, blocksize=32768) 
                    COLUMN dim_event_type_key ENCODING (compresstype=zlib, compresslevel=1, blocksize=32768) 
                    COLUMN dim_site_key ENCODING (compresstype=zlib, compresslevel=1, blocksize=32768) 
                    COLUMN dim_date_key ENCODING (compresstype=zlib, compresslevel=1, blocksize=32768) 
                    COLUMN dim_time_key ENCODING (compresstype=zlib, compresslevel=1, blocksize=32768) 
                    COLUMN dim_phone_number_key ENCODING (compresstype=zlib, compresslevel=1, blocksize=32768) 
                    COLUMN duration_second ENCODING (compresstype=zlib, compresslevel=1, blocksize=32768) 
                    COLUMN dim_program_key ENCODING (compresstype=zlib, compresslevel=1, blocksize=32768) 
                    COLUMN dim_call_status_key ENCODING (compresstype=zlib, compresslevel=1, blocksize=32768) 
                    COLUMN dim_phone_department_set_key ENCODING (compresstype=zlib, compresslevel=1, blocksize=32768) 
                    COLUMN dim_phone_channel_set_key ENCODING (compresstype=zlib, compresslevel=1, blocksize=32768) 
                    COLUMN dim_phone_provider_key ENCODING (compresstype=zlib, compresslevel=1, blocksize=32768) 
                    COLUMN dim_phone_ad_set_key ENCODING (compresstype=zlib, compresslevel=1, blocksize=32768)
          );
NOTICE:  CREATE TABLE will create partition "non_ws_phone_leads_1_prt_p_max" for table "non_ws_phone_leads"
INSERT INTO non_ws_phone_leads VALUES (63962490, 'CA6qOEyxOmNJUQC7', 5058, 999901, 2455441, 40435, 999904, 207, 79, 2, 9901, 9901, 1, 9901);
CREATE TABLE dim_phone_numbers (
    dim_phone_number_key integer NOT NULL,
    media_tracker_description character varying(40) NOT NULL,
    formatted_phone_number character varying(20) NOT NULL,
    source_system_phone_number_id character varying(100) NOT NULL,
    last_modified_date timestamp without time zone NOT NULL
) DISTRIBUTED BY (dim_phone_number_key);
ALTER TABLE ONLY dim_phone_numbers
    ADD CONSTRAINT dim_phone_numbers_pk1 PRIMARY KEY (dim_phone_number_key);
INSERT INTO dim_phone_numbers VALUES (999902, 'test', '800-123-4568', '8001234568', '2012-09-25 13:34:35.037637');
INSERT INTO dim_phone_numbers VALUES (999904, 'test', '(800) 123-4570', '8001234570', '2012-09-25 13:34:35.148104');
INSERT INTO dim_phone_numbers VALUES (999903, 'test', '(800) 123-4569', '8001234569', '2012-09-25 13:34:35.093523');
INSERT INTO dim_phone_numbers VALUES (999901, 'test', '(800)123-4567', '8001234567', '2012-09-25 13:34:34.781042');
INSERT INTO dim_phone_numbers SELECT gs.*, dim_phone_numbers.media_tracker_description, dim_phone_numbers.formatted_phone_number, dim_phone_numbers.source_system_phone_number_id, dim_phone_numbers.last_modified_date FROM dim_phone_numbers, generate_series(1,100000) gs WHERE dim_phone_numbers.dim_phone_number_key = 999901;
ANALYZE dim_phone_numbers;  
-- Table NON_WS_PHONE_LEADS has two distribution keys
-- Equality condition with constant on one distribution key
-- Redistribute over Append
SELECT pl.duration_Second , pl.dim_program_Key, PL.DIM_SITE_KEY, PL.DIM_DATE_KEY
FROM NON_WS_PHONE_LEADS PL
LEFT outer JOIN DIM_PHONE_NUMBERS DPN
ON PL.DIM_PHONE_NUMBER_KEY = DPN.DIM_PHONE_NUMBER_KEY
WHERE pl.SOURCE_SYSTEM_LEAD_ID = 'CA6qOEyxOmNJUQC7'
AND PL.DIM_DATE_KEY = 2455441;
 duration_second | dim_program_key | dim_site_key | dim_date_key 
-----------------+-----------------+--------------+--------------
             207 |              79 |       999901 |      2455441
(1 row)

-- Table NON_WS_PHONE_LEADS has two distribution keys
-- Equality conditions with constants on all distribution keys
-- Redistribute over Append
SELECT pl.duration_Second , pl.dim_program_Key, PL.DIM_SITE_KEY, PL.DIM_DATE_KEY
FROM NON_WS_PHONE_LEADS PL
LEFT outer JOIN DIM_PHONE_NUMBERS DPN
ON PL.DIM_PHONE_NUMBER_KEY = DPN.DIM_PHONE_NUMBER_KEY
WHERE pl.SOURCE_SYSTEM_LEAD_ID = 'CA6qOEyxOmNJUQC7'
AND PL.DIM_DATE_KEY = 2455441
AND PL.dim_site_key = 999901;
 duration_second | dim_program_key | dim_site_key | dim_date_key 
-----------------+-----------------+--------------+--------------
             207 |              79 |       999901 |      2455441
(1 row)

-- Table NON_WS_PHONE_LEADS has two distribution keys
-- Broadcast over Append
SELECT pl.duration_Second , pl.dim_program_Key, PL.DIM_SITE_KEY, PL.DIM_DATE_KEY
FROM NON_WS_PHONE_LEADS PL
JOIN DIM_PHONE_NUMBERS DPN
ON PL.DIM_PHONE_NUMBER_KEY = DPN.DIM_PHONE_NUMBER_KEY
WHERE pl.SOURCE_SYSTEM_LEAD_ID = 'CA6qOEyxOmNJUQC7'
AND PL.DIM_DATE_KEY = 2455441
AND PL.dim_site_key = 999901;
 duration_second | dim_program_key | dim_site_key | dim_date_key 
-----------------+-----------------+--------------+--------------
             207 |              79 |       999901 |      2455441
(1 row)

-- Join condition uses functions
-- Broadcast over Append
SELECT pl.duration_Second , pl.dim_program_Key, PL.DIM_SITE_KEY, PL.DIM_DATE_KEY
FROM NON_WS_PHONE_LEADS PL
JOIN DIM_PHONE_NUMBERS DPN
ON PL.DIM_PHONE_NUMBER_KEY + 1 = DPN.DIM_PHONE_NUMBER_KEY + 1
WHERE pl.SOURCE_SYSTEM_LEAD_ID = 'CA6qOEyxOmNJUQC7'
AND PL.DIM_DATE_KEY = 2455441
AND PL.dim_site_key = 999901;
 duration_second | dim_program_key | dim_site_key | dim_date_key 
-----------------+-----------------+--------------+--------------
             207 |              79 |       999901 |      2455441
(1 row)

-- Equality condition with constant on one distribution key
-- Redistribute over Append
-- Accessing a varchar in the SELECT clause should cause a SIGSEGV
SELECT pl.duration_Second , pl.dim_program_Key, PL.DIM_SITE_KEY, PL.DIM_DATE_KEY, source_system_lead_id
FROM NON_WS_PHONE_LEADS PL
LEFT outer JOIN DIM_PHONE_NUMBERS DPN
ON PL.DIM_PHONE_NUMBER_KEY = DPN.DIM_PHONE_NUMBER_KEY
WHERE pl.SOURCE_SYSTEM_LEAD_ID = 'CA6qOEyxOmNJUQC7'
AND PL.DIM_DATE_KEY = 2455441;
 duration_second | dim_program_key | dim_site_key | dim_date_key | source_system_lead_id 
-----------------+-----------------+--------------+--------------+-----------------------
             207 |              79 |       999901 |      2455441 | CA6qOEyxOmNJUQC7
(1 row)

DROP TABLE non_ws_phone_leads;
DROP TABLE dim_phone_numbers;
-- Equality condition with a constant expression on one distribution key
drop table if exists foo_p;
NOTICE:  table "foo_p" does not exist, skipping
drop table if exists bar;
NOTICE:  table "bar" does not exist, skipping
create table foo_p( a int, b int, k int, t text, p int) distributed by (a,b) partition by range(p) ( start(0) end(10) every (2), default partition other);
NOTICE:  CREATE TABLE will create partition "foo_p_1_prt_other" for table "foo_p"
NOTICE:  CREATE TABLE will create partition "foo_p_1_prt_2" for table "foo_p"
NOTICE:  CREATE TABLE will create partition "foo_p_1_prt_3" for table "foo_p"
NOTICE:  CREATE TABLE will create partition "foo_p_1_prt_4" for table "foo_p"
NOTICE:  CREATE TABLE will create partition "foo_p_1_prt_5" for table "foo_p"
NOTICE:  CREATE TABLE will create partition "foo_p_1_prt_6" for table "foo_p"
create table bar( a int, b int, k int, t text, p int) distributed by (a);
insert into foo_p select i, i % 10, i , i || 'SOME NUMBER SOME NUMBER', i % 10 from generate_series(1, 1000) i;
insert into bar select i % 7, i % 6, i % 9, i || 'SOME NUMBER', i % 4 from generate_series(1, 100) i;
insert into bar select i % 7, i % 6, i % 9, i || 'SOME NUMBER', i % 4 from generate_series(1, 10000) i;
insert into bar select i % 7, i % 6, i % 9, i || 'SOME NUMBER', i % 4 from generate_series(1, 10000) i;
analyze foo_p;
analyze bar;
set optimizer_segments = 3;
set optimizer_nestloop_factor = 1.0;
explain select foo_p.b, foo_p.t from foo_p left outer join bar on foo_p.a = bar.k  where foo_p.t is not null and foo_p.a = (array[1])[1];
                                           QUERY PLAN                                           
------------------------------------------------------------------------------------------------
 Gather Motion 3:1  (slice2; segments: 3)  (cost=28.57..566.28 rows=13400 width=31)
   ->  Hash Right Join  (cost=28.57..566.28 rows=4467 width=31)
         Hash Cond: bar.k = public.foo_p.a
         ->  Broadcast Motion 3:3  (slice1; segments: 3)  (cost=0.00..378.58 rows=2234 width=4)
               ->  Seq Scan on bar  (cost=0.00..289.25 rows=745 width=4)
                     Filter: k = ('{1}'::integer[])[1]
         ->  Hash  (cost=28.50..28.50 rows=2 width=35)
               ->  Append  (cost=0.00..28.50 rows=2 width=35)
                     ->  Seq Scan on foo_p_1_prt_other  (cost=0.00..1.00 rows=1 width=40)
                           Filter: t IS NOT NULL AND a = ('{1}'::integer[])[1]
                     ->  Seq Scan on foo_p_1_prt_2  (cost=0.00..5.50 rows=1 width=34)
                           Filter: t IS NOT NULL AND a = ('{1}'::integer[])[1]
                     ->  Seq Scan on foo_p_1_prt_3  (cost=0.00..5.50 rows=1 width=34)
                           Filter: t IS NOT NULL AND a = ('{1}'::integer[])[1]
                     ->  Seq Scan on foo_p_1_prt_4  (cost=0.00..5.50 rows=1 width=34)
                           Filter: t IS NOT NULL AND a = ('{1}'::integer[])[1]
                     ->  Seq Scan on foo_p_1_prt_5  (cost=0.00..5.50 rows=1 width=34)
                           Filter: t IS NOT NULL AND a = ('{1}'::integer[])[1]
                     ->  Seq Scan on foo_p_1_prt_6  (cost=0.00..5.50 rows=1 width=34)
                           Filter: t IS NOT NULL AND a = ('{1}'::integer[])[1]
 Optimizer: Postgres query optimizer
(21 rows)

reset optimizer_segments;
drop table if exists foo_p;
drop table if exists bar;
-- MPP-18457, MPP-18415 end
-- MPP-18359
drop view if exists redundantly_named_part cascade;
NOTICE:  view "redundantly_named_part" does not exist, skipping
create view redundantly_named_part(tableid, partid, partname) as
	with 
		dups(paroid, partname) as 
		(
			select paroid, parname
			from pg_partition_rule 
			where parname is not null 
			group by paroid, parname 
			having count(*) > 1
		),
		parts(tableid, partid, paroid, partname) as
		(
			select p.parrelid, r.parchildrelid, r.paroid, r.parname
			from pg_partition p, pg_partition_rule r
			where not p.paristemplate and
				p.oid = r.paroid
		)
	select p.tableid::regclass, p.partid::regclass, p.partname
	from parts p, dups d
	where 
		p.paroid = d.paroid and
		p.partname = d.partname;
drop table if exists pnx;
NOTICE:  table "pnx" does not exist, skipping
create table pnx 
    (x int , y text)
    distributed randomly
    partition by list (y)
        ( 
            partition a values ('x1', 'x2'),
            partition c values ('x3', 'x4')
        );
NOTICE:  CREATE TABLE will create partition "pnx_1_prt_a" for table "pnx"
NOTICE:  CREATE TABLE will create partition "pnx_1_prt_c" for table "pnx"
insert into pnx values
    (1,'x1'),
    (2,'x2'),
    (3,'x3'), 
    (4,'x4');
select tableoid::regclass, * 
from pnx;
  tableoid   | x | y  
-------------+---+----
 pnx_1_prt_a | 1 | x1
 pnx_1_prt_c | 3 | x3
 pnx_1_prt_a | 2 | x2
 pnx_1_prt_c | 4 | x4
(4 rows)

alter table pnx
    split partition a at ('x1')
    into (partition b, partition c);
ERROR:  cannot split into an existing partition
select * from redundantly_named_part where tableid::text like '%pnx%';
 tableid | partid | partname 
---------+--------+----------
(0 rows)

select tableoid::regclass, * 
from pnx;
  tableoid   | x | y  
-------------+---+----
 pnx_1_prt_a | 1 | x1
 pnx_1_prt_c | 3 | x3
 pnx_1_prt_a | 2 | x2
 pnx_1_prt_c | 4 | x4
(4 rows)

select tableoid::regclass, *
from pnx
where y = 'x1';
  tableoid   | x | y  
-------------+---+----
 pnx_1_prt_a | 1 | x1
(1 row)

select tableoid::regclass, *
from pnx
where x = 1;
  tableoid   | x | y  
-------------+---+----
 pnx_1_prt_a | 1 | x1
(1 row)

drop table if exists pxn;
NOTICE:  table "pxn" does not exist, skipping
create table pxn 
    (x int , y text)
    distributed randomly
    partition by list (y)
        ( 
            partition a values ('x1', 'x2'),
            partition c values ('x3', 'x4')
        );
NOTICE:  CREATE TABLE will create partition "pxn_1_prt_a" for table "pxn"
NOTICE:  CREATE TABLE will create partition "pxn_1_prt_c" for table "pxn"
insert into pxn values
    (1,'x1'),
    (2,'x2'),
    (3,'x3'), 
    (4,'x4');
select tableoid::regclass, * 
from pxn;
  tableoid   | x | y  
-------------+---+----
 pxn_1_prt_a | 1 | x1
 pxn_1_prt_c | 3 | x3
 pxn_1_prt_a | 2 | x2
 pxn_1_prt_c | 4 | x4
(4 rows)

alter table pxn
    split partition a at ('x1')
    into (partition c, partition b);
ERROR:  cannot split into an existing partition
select * from redundantly_named_part where tableid::text like '%pxn%';
 tableid | partid | partname 
---------+--------+----------
(0 rows)

select tableoid::regclass, * 
from pxn;
  tableoid   | x | y  
-------------+---+----
 pxn_1_prt_a | 2 | x2
 pxn_1_prt_c | 4 | x4
 pxn_1_prt_a | 1 | x1
 pxn_1_prt_c | 3 | x3
(4 rows)

select tableoid::regclass, *
from pxn
where y = 'x2';
  tableoid   | x | y  
-------------+---+----
 pxn_1_prt_a | 2 | x2
(1 row)

select tableoid::regclass, *
from pxn
where x = 2;
  tableoid   | x | y  
-------------+---+----
 pxn_1_prt_a | 2 | x2
(1 row)

drop table if exists pxn;
create table pxn 
    (x int , y int)
    distributed randomly
    partition by range (y)
        ( 
            partition a start (0) end (10),
            partition c start (11) end (20)
        );
NOTICE:  CREATE TABLE will create partition "pxn_1_prt_a" for table "pxn"
NOTICE:  CREATE TABLE will create partition "pxn_1_prt_c" for table "pxn"
insert into pxn values
    (4,4),
    (9,9),
    (14,14), 
    (19,19);
select tableoid::regclass, * 
from pxn;
  tableoid   | x  | y  
-------------+----+----
 pxn_1_prt_a |  4 |  4
 pxn_1_prt_c | 14 | 14
 pxn_1_prt_a |  9 |  9
 pxn_1_prt_c | 19 | 19
(4 rows)

alter table pxn
    split partition a at (5)
    into (partition b, partition c);
ERROR:  cannot split into an existing partition
select * from redundantly_named_part where tableid::text like '%pxn%';
 tableid | partid | partname 
---------+--------+----------
(0 rows)

select tableoid::regclass, * 
from pxn;
  tableoid   | x  | y  
-------------+----+----
 pxn_1_prt_a |  9 |  9
 pxn_1_prt_c | 19 | 19
 pxn_1_prt_a |  4 |  4
 pxn_1_prt_c | 14 | 14
(4 rows)

select tableoid::regclass, *
from pxn
where y = 4;
  tableoid   | x | y 
-------------+---+---
 pxn_1_prt_a | 4 | 4
(1 row)

select tableoid::regclass, *
from pxn
where x = 4;
  tableoid   | x | y 
-------------+---+---
 pxn_1_prt_a | 4 | 4
(1 row)

drop table if exists pxn;
create table pxn 
    (x int , y int)
    distributed randomly
    partition by range (y)
        ( 
            partition a start (0) end (10),
            partition c start (11) end (20)
        );
NOTICE:  CREATE TABLE will create partition "pxn_1_prt_a" for table "pxn"
NOTICE:  CREATE TABLE will create partition "pxn_1_prt_c" for table "pxn"
insert into pxn values
    (4,4),
    (9,9),
    (14,14), 
    (19,19);
select tableoid::regclass, * 
from pxn;
  tableoid   | x  | y  
-------------+----+----
 pxn_1_prt_a |  4 |  4
 pxn_1_prt_c | 14 | 14
 pxn_1_prt_a |  9 |  9
 pxn_1_prt_c | 19 | 19
(4 rows)

alter table pxn
    split partition a at (5)
    into (partition c, partition b);
ERROR:  cannot split into an existing partition
select * from redundantly_named_part where tableid::text like '%pxn%';
 tableid | partid | partname 
---------+--------+----------
(0 rows)

select tableoid::regclass, * 
from pxn;
  tableoid   | x  | y  
-------------+----+----
 pxn_1_prt_a |  9 |  9
 pxn_1_prt_c | 19 | 19
 pxn_1_prt_a |  4 |  4
 pxn_1_prt_c | 14 | 14
(4 rows)

select tableoid::regclass, *
from pxn
where y = 9;
  tableoid   | x | y 
-------------+---+---
 pxn_1_prt_a | 9 | 9
(1 row)

select tableoid::regclass, *
from pxn
where x = 9;
  tableoid   | x | y 
-------------+---+---
 pxn_1_prt_a | 9 | 9
(1 row)

-- MPP-18359 end
-- MPP-19105
-- Base partitions with trailing dropped columns
create table parttest_t (
	a int,
	b int,
	c char,
	d varchar(50)
) distributed by (c) 
partition by range (a) 
( 
	partition p1 start(1) end(5),
	partition p2 start(5)
);
NOTICE:  CREATE TABLE will create partition "parttest_t_1_prt_p1" for table "parttest_t"
NOTICE:  CREATE TABLE will create partition "parttest_t_1_prt_p2" for table "parttest_t"
-- Drop column
alter table parttest_t drop column d;
-- Alter table split partition
alter table parttest_t split partition for(1) at (2) into (partition p11, partition p22);
NOTICE:  exchanged partition "p1" of relation "parttest_t" with relation "pg_temp_4062621"
NOTICE:  dropped partition "p1" for relation "parttest_t"
NOTICE:  CREATE TABLE will create partition "parttest_t_1_prt_p11" for table "parttest_t"
NOTICE:  CREATE TABLE will create partition "parttest_t_1_prt_p22" for table "parttest_t"
insert into  parttest_t values(1,2,'a');
select * from parttest_t;
 a | b | c 
---+---+---
 1 | 2 | a
(1 row)

-- END MPP-19105
reset optimizer_nestloop_factor;
-- Sub-partition insertion with checking if the user provided correct leaf part
set dml_ignore_target_partition_check=false;
create table part_tab ( i int, j int) distributed by (i) partition by range(j) (start(0) end(10) every(2));
NOTICE:  CREATE TABLE will create partition "part_tab_1_prt_1" for table "part_tab"
NOTICE:  CREATE TABLE will create partition "part_tab_1_prt_2" for table "part_tab"
NOTICE:  CREATE TABLE will create partition "part_tab_1_prt_3" for table "part_tab"
NOTICE:  CREATE TABLE will create partition "part_tab_1_prt_4" for table "part_tab"
NOTICE:  CREATE TABLE will create partition "part_tab_1_prt_5" for table "part_tab"
-- Wrong part
insert into part_tab_1_prt_1 values(5,5);
ERROR:  trying to insert row into wrong partition  (seg0 slarimac:40000 pid=97899)
DETAIL:  Expected partition: part_tab_1_prt_3, provided partition: part_tab_1_prt_1.
select * from part_tab;
 i | j 
---+---
(0 rows)

select * from part_tab_1_prt_1;
 i | j 
---+---
(0 rows)

insert into part_tab_1_prt_2 values(5,5);
ERROR:  trying to insert row into wrong partition  (seg0 slarimac:40000 pid=97899)
DETAIL:  Expected partition: part_tab_1_prt_3, provided partition: part_tab_1_prt_2.
select * from part_tab;
 i | j 
---+---
(0 rows)

select * from part_tab_1_prt_2;
 i | j 
---+---
(0 rows)

-- Right part
insert into part_tab_1_prt_3 values(5,5);
select * from part_tab;
 i | j 
---+---
 5 | 5
(1 row)

select * from part_tab_1_prt_3;
 i | j 
---+---
 5 | 5
(1 row)

-- Root part
insert into part_tab values(5,5);
select * from part_tab;
 i | j 
---+---
 5 | 5
 5 | 5
(2 rows)

drop table if exists input1;
NOTICE:  table "input1" does not exist, skipping
create table input1 (x int, y int);
NOTICE:  Table doesn't have 'DISTRIBUTED BY' clause -- Using column named 'x' as the Greenplum Database data distribution key for this table.
HINT:  The 'DISTRIBUTED BY' clause determines the distribution of data. Make sure column(s) chosen are the optimal data distribution key to minimize skew.
insert into input1 select i, i from (select generate_series(1,10) as i) as t;
drop table if exists input2;
NOTICE:  table "input2" does not exist, skipping
create table input2 (x int, y int);
NOTICE:  Table doesn't have 'DISTRIBUTED BY' clause -- Using column named 'x' as the Greenplum Database data distribution key for this table.
HINT:  The 'DISTRIBUTED BY' clause determines the distribution of data. Make sure column(s) chosen are the optimal data distribution key to minimize skew.
insert into input2 select i, i from (select generate_series(1,10) as i) as t;
-- Multiple range table entries in the plan
insert into part_tab_1_prt_1 select i1.x, i2.y from input1 as i1 join input2 as i2 on i1.x = i2.x where i2.y = 5;
ERROR:  trying to insert row into wrong partition  (seg0 slarimac:40000 pid=97899)
DETAIL:  Expected partition: part_tab_1_prt_3, provided partition: part_tab_1_prt_1.
select * from part_tab;
 i | j 
---+---
 5 | 5
 5 | 5
(2 rows)

select * from part_tab_1_prt_1;
 i | j 
---+---
(0 rows)

insert into part_tab_1_prt_2 select i1.x, i2.y from input1 as i1 join input2 as i2 on i1.x = i2.x where i2.y = 5;
ERROR:  trying to insert row into wrong partition  (seg0 slarimac:40000 pid=97899)
DETAIL:  Expected partition: part_tab_1_prt_3, provided partition: part_tab_1_prt_2.
select * from part_tab;
 i | j 
---+---
 5 | 5
 5 | 5
(2 rows)

select * from part_tab_1_prt_2;
 i | j 
---+---
(0 rows)

-- Right part
insert into part_tab_1_prt_3 select i1.x, i2.y from input1 as i1 join input2 as i2 on i1.x = i2.x where i1.x between 4 and 5;
select * from part_tab;
 i | j 
---+---
 4 | 4
 5 | 5
 5 | 5
 5 | 5
(4 rows)

select * from part_tab_1_prt_3;
 i | j 
---+---
 4 | 4
 5 | 5
 5 | 5
 5 | 5
(4 rows)

-- Root part but no matching part for i2.y == 10
insert into part_tab select i1.x, i2.y from input1 as i1 join input2 as i2 on i1.x = i2.x;
ERROR:  no partition for partitioning key  (seg1 slarimac:40001 pid=97900)
select * from part_tab;
 i | j 
---+---
 5 | 5
 5 | 5
 5 | 5
 4 | 4
(4 rows)

-- Root part
insert into part_tab select i1.x, i2.y from input1 as i1 join input2 as i2 on i1.x = i2.x where i2.y < 10;
select * from part_tab;
 i | j 
---+---
 1 | 1
 2 | 2
 3 | 3
 5 | 5
 5 | 5
 4 | 4
 5 | 5
 4 | 4
 5 | 5
 6 | 6
 7 | 7
 8 | 8
 9 | 9
(13 rows)

-- Multi-level partitioning
create table deep_part ( i int, j int, k int, s char(5)) 
distributed by (i) 
partition by list(s)
subpartition by range (j) subpartition template (start(1)  end(10) every(2))
subpartition by range (k) subpartition template (start(1)  end(10) every(2))
(partition female values('F'), partition male values('M'))
;
NOTICE:  CREATE TABLE will create partition "deep_part_1_prt_female" for table "deep_part"
NOTICE:  CREATE TABLE will create partition "deep_part_1_prt_male" for table "deep_part"
NOTICE:  CREATE TABLE will create partition "deep_part_1_prt_female_2_prt_1" for table "deep_part_1_prt_female"
NOTICE:  CREATE TABLE will create partition "deep_part_1_prt_female_2_prt_2" for table "deep_part_1_prt_female"
NOTICE:  CREATE TABLE will create partition "deep_part_1_prt_female_2_prt_3" for table "deep_part_1_prt_female"
NOTICE:  CREATE TABLE will create partition "deep_part_1_prt_female_2_prt_4" for table "deep_part_1_prt_female"
NOTICE:  CREATE TABLE will create partition "deep_part_1_prt_female_2_prt_5" for table "deep_part_1_prt_female"
NOTICE:  CREATE TABLE will create partition "deep_part_1_prt_female_2_prt_1_3_prt_1" for table "deep_part_1_prt_female_2_prt_1"
NOTICE:  CREATE TABLE will create partition "deep_part_1_prt_female_2_prt_1_3_prt_2" for table "deep_part_1_prt_female_2_prt_1"
NOTICE:  CREATE TABLE will create partition "deep_part_1_prt_female_2_prt_1_3_prt_3" for table "deep_part_1_prt_female_2_prt_1"
NOTICE:  CREATE TABLE will create partition "deep_part_1_prt_female_2_prt_1_3_prt_4" for table "deep_part_1_prt_female_2_prt_1"
NOTICE:  CREATE TABLE will create partition "deep_part_1_prt_female_2_prt_1_3_prt_5" for table "deep_part_1_prt_female_2_prt_1"
NOTICE:  CREATE TABLE will create partition "deep_part_1_prt_female_2_prt_2_3_prt_1" for table "deep_part_1_prt_female_2_prt_2"
NOTICE:  CREATE TABLE will create partition "deep_part_1_prt_female_2_prt_2_3_prt_2" for table "deep_part_1_prt_female_2_prt_2"
NOTICE:  CREATE TABLE will create partition "deep_part_1_prt_female_2_prt_2_3_prt_3" for table "deep_part_1_prt_female_2_prt_2"
NOTICE:  CREATE TABLE will create partition "deep_part_1_prt_female_2_prt_2_3_prt_4" for table "deep_part_1_prt_female_2_prt_2"
NOTICE:  CREATE TABLE will create partition "deep_part_1_prt_female_2_prt_2_3_prt_5" for table "deep_part_1_prt_female_2_prt_2"
NOTICE:  CREATE TABLE will create partition "deep_part_1_prt_female_2_prt_3_3_prt_1" for table "deep_part_1_prt_female_2_prt_3"
NOTICE:  CREATE TABLE will create partition "deep_part_1_prt_female_2_prt_3_3_prt_2" for table "deep_part_1_prt_female_2_prt_3"
NOTICE:  CREATE TABLE will create partition "deep_part_1_prt_female_2_prt_3_3_prt_3" for table "deep_part_1_prt_female_2_prt_3"
NOTICE:  CREATE TABLE will create partition "deep_part_1_prt_female_2_prt_3_3_prt_4" for table "deep_part_1_prt_female_2_prt_3"
NOTICE:  CREATE TABLE will create partition "deep_part_1_prt_female_2_prt_3_3_prt_5" for table "deep_part_1_prt_female_2_prt_3"
NOTICE:  CREATE TABLE will create partition "deep_part_1_prt_female_2_prt_4_3_prt_1" for table "deep_part_1_prt_female_2_prt_4"
NOTICE:  CREATE TABLE will create partition "deep_part_1_prt_female_2_prt_4_3_prt_2" for table "deep_part_1_prt_female_2_prt_4"
NOTICE:  CREATE TABLE will create partition "deep_part_1_prt_female_2_prt_4_3_prt_3" for table "deep_part_1_prt_female_2_prt_4"
NOTICE:  CREATE TABLE will create partition "deep_part_1_prt_female_2_prt_4_3_prt_4" for table "deep_part_1_prt_female_2_prt_4"
NOTICE:  CREATE TABLE will create partition "deep_part_1_prt_female_2_prt_4_3_prt_5" for table "deep_part_1_prt_female_2_prt_4"
NOTICE:  CREATE TABLE will create partition "deep_part_1_prt_female_2_prt_5_3_prt_1" for table "deep_part_1_prt_female_2_prt_5"
NOTICE:  CREATE TABLE will create partition "deep_part_1_prt_female_2_prt_5_3_prt_2" for table "deep_part_1_prt_female_2_prt_5"
NOTICE:  CREATE TABLE will create partition "deep_part_1_prt_female_2_prt_5_3_prt_3" for table "deep_part_1_prt_female_2_prt_5"
NOTICE:  CREATE TABLE will create partition "deep_part_1_prt_female_2_prt_5_3_prt_4" for table "deep_part_1_prt_female_2_prt_5"
NOTICE:  CREATE TABLE will create partition "deep_part_1_prt_female_2_prt_5_3_prt_5" for table "deep_part_1_prt_female_2_prt_5"
NOTICE:  CREATE TABLE will create partition "deep_part_1_prt_male_2_prt_1" for table "deep_part_1_prt_male"
NOTICE:  CREATE TABLE will create partition "deep_part_1_prt_male_2_prt_2" for table "deep_part_1_prt_male"
NOTICE:  CREATE TABLE will create partition "deep_part_1_prt_male_2_prt_3" for table "deep_part_1_prt_male"
NOTICE:  CREATE TABLE will create partition "deep_part_1_prt_male_2_prt_4" for table "deep_part_1_prt_male"
NOTICE:  CREATE TABLE will create partition "deep_part_1_prt_male_2_prt_5" for table "deep_part_1_prt_male"
NOTICE:  CREATE TABLE will create partition "deep_part_1_prt_male_2_prt_1_3_prt_1" for table "deep_part_1_prt_male_2_prt_1"
NOTICE:  CREATE TABLE will create partition "deep_part_1_prt_male_2_prt_1_3_prt_2" for table "deep_part_1_prt_male_2_prt_1"
NOTICE:  CREATE TABLE will create partition "deep_part_1_prt_male_2_prt_1_3_prt_3" for table "deep_part_1_prt_male_2_prt_1"
NOTICE:  CREATE TABLE will create partition "deep_part_1_prt_male_2_prt_1_3_prt_4" for table "deep_part_1_prt_male_2_prt_1"
NOTICE:  CREATE TABLE will create partition "deep_part_1_prt_male_2_prt_1_3_prt_5" for table "deep_part_1_prt_male_2_prt_1"
NOTICE:  CREATE TABLE will create partition "deep_part_1_prt_male_2_prt_2_3_prt_1" for table "deep_part_1_prt_male_2_prt_2"
NOTICE:  CREATE TABLE will create partition "deep_part_1_prt_male_2_prt_2_3_prt_2" for table "deep_part_1_prt_male_2_prt_2"
NOTICE:  CREATE TABLE will create partition "deep_part_1_prt_male_2_prt_2_3_prt_3" for table "deep_part_1_prt_male_2_prt_2"
NOTICE:  CREATE TABLE will create partition "deep_part_1_prt_male_2_prt_2_3_prt_4" for table "deep_part_1_prt_male_2_prt_2"
NOTICE:  CREATE TABLE will create partition "deep_part_1_prt_male_2_prt_2_3_prt_5" for table "deep_part_1_prt_male_2_prt_2"
NOTICE:  CREATE TABLE will create partition "deep_part_1_prt_male_2_prt_3_3_prt_1" for table "deep_part_1_prt_male_2_prt_3"
NOTICE:  CREATE TABLE will create partition "deep_part_1_prt_male_2_prt_3_3_prt_2" for table "deep_part_1_prt_male_2_prt_3"
NOTICE:  CREATE TABLE will create partition "deep_part_1_prt_male_2_prt_3_3_prt_3" for table "deep_part_1_prt_male_2_prt_3"
NOTICE:  CREATE TABLE will create partition "deep_part_1_prt_male_2_prt_3_3_prt_4" for table "deep_part_1_prt_male_2_prt_3"
NOTICE:  CREATE TABLE will create partition "deep_part_1_prt_male_2_prt_3_3_prt_5" for table "deep_part_1_prt_male_2_prt_3"
NOTICE:  CREATE TABLE will create partition "deep_part_1_prt_male_2_prt_4_3_prt_1" for table "deep_part_1_prt_male_2_prt_4"
NOTICE:  CREATE TABLE will create partition "deep_part_1_prt_male_2_prt_4_3_prt_2" for table "deep_part_1_prt_male_2_prt_4"
NOTICE:  CREATE TABLE will create partition "deep_part_1_prt_male_2_prt_4_3_prt_3" for table "deep_part_1_prt_male_2_prt_4"
NOTICE:  CREATE TABLE will create partition "deep_part_1_prt_male_2_prt_4_3_prt_4" for table "deep_part_1_prt_male_2_prt_4"
NOTICE:  CREATE TABLE will create partition "deep_part_1_prt_male_2_prt_4_3_prt_5" for table "deep_part_1_prt_male_2_prt_4"
NOTICE:  CREATE TABLE will create partition "deep_part_1_prt_male_2_prt_5_3_prt_1" for table "deep_part_1_prt_male_2_prt_5"
NOTICE:  CREATE TABLE will create partition "deep_part_1_prt_male_2_prt_5_3_prt_2" for table "deep_part_1_prt_male_2_prt_5"
NOTICE:  CREATE TABLE will create partition "deep_part_1_prt_male_2_prt_5_3_prt_3" for table "deep_part_1_prt_male_2_prt_5"
NOTICE:  CREATE TABLE will create partition "deep_part_1_prt_male_2_prt_5_3_prt_4" for table "deep_part_1_prt_male_2_prt_5"
NOTICE:  CREATE TABLE will create partition "deep_part_1_prt_male_2_prt_5_3_prt_5" for table "deep_part_1_prt_male_2_prt_5"
-- Intermediate partition insert is not allowed
insert into deep_part_1_prt_male_2_prt_2 values(1,1,1,'M');
ERROR:  directly modifying intermediate part of a partitioned table is disallowed
HINT:  Modify either the root or a leaf partition instead.
-- Wrong sub-partition (inserting a female value in male partition)
insert into deep_part_1_prt_male_2_prt_2_3_prt_2 values (1, 1, 1, 'F');
ERROR:  trying to insert row into wrong partition  (seg0 slarimac:40000 pid=97899)
DETAIL:  Expected partition: deep_part_1_prt_female_2_prt_1_3_prt_1, provided partition: deep_part_1_prt_male_2_prt_2_3_prt_2.
select * from deep_part;
 i | j | k | s 
---+---+---+---
(0 rows)

-- Correct leaf part
insert into deep_part_1_prt_male_2_prt_1_3_prt_1 values (1, 1, 1, 'M');
select * from deep_part;
 i | j | k |   s   
---+---+---+-------
 1 | 1 | 1 | M    
(1 row)

select * from deep_part_1_prt_male_2_prt_1_3_prt_1;
 i | j | k |   s   
---+---+---+-------
 1 | 1 | 1 | M    
(1 row)

-- Root part of a multi-level partitioned table
insert into deep_part values (1, 1, 1, 'M');
select * from deep_part;
 i | j | k |   s   
---+---+---+-------
 1 | 1 | 1 | M    
 1 | 1 | 1 | M    
(2 rows)

select * from deep_part_1_prt_male_2_prt_1_3_prt_1;
 i | j | k |   s   
---+---+---+-------
 1 | 1 | 1 | M    
 1 | 1 | 1 | M    
(2 rows)

insert into deep_part values (1, 1, 1, 'F');
select * from deep_part;
 i | j | k |   s   
---+---+---+-------
 1 | 1 | 1 | F    
 1 | 1 | 1 | M    
 1 | 1 | 1 | M    
(3 rows)

select * from deep_part_1_prt_female_2_prt_1_3_prt_1;
 i | j | k |   s   
---+---+---+-------
 1 | 1 | 1 | F    
(1 row)

insert into deep_part values (5, 5, 5, 'M');
select * from deep_part;
 i | j | k |   s   
---+---+---+-------
 1 | 1 | 1 | F    
 1 | 1 | 1 | M    
 1 | 1 | 1 | M    
 5 | 5 | 5 | M    
(4 rows)

select * from deep_part_1_prt_male_2_prt_3_3_prt_3;
 i | j | k |   s   
---+---+---+-------
 5 | 5 | 5 | M    
(1 row)

insert into deep_part values (9, 9, 9, 'F');
select * from deep_part;
 i | j | k |   s   
---+---+---+-------
 1 | 1 | 1 | F    
 9 | 9 | 9 | F    
 1 | 1 | 1 | M    
 1 | 1 | 1 | M    
 5 | 5 | 5 | M    
(5 rows)

select * from deep_part_1_prt_female_2_prt_5_3_prt_5;
 i | j | k |   s   
---+---+---+-------
 9 | 9 | 9 | F    
(1 row)

-- Out of range partition
insert into deep_part values (9, 9, 10, 'F');
ERROR:  no partition for partitioning key  (seg0 slarimac:40000 pid=97899)
select * from deep_part;
 i | j | k |   s   
---+---+---+-------
 1 | 1 | 1 | F    
 9 | 9 | 9 | F    
 1 | 1 | 1 | M    
 1 | 1 | 1 | M    
 5 | 5 | 5 | M    
(5 rows)

-- Sub-partition insertion without checking for correct user provided leaf part
set dml_ignore_target_partition_check=true;
drop table if exists part_tab;
create table part_tab ( i int, j int) distributed by (i) partition by range(j) (start(0) end(10) every(2));
NOTICE:  CREATE TABLE will create partition "part_tab_1_prt_1" for table "part_tab"
NOTICE:  CREATE TABLE will create partition "part_tab_1_prt_2" for table "part_tab"
NOTICE:  CREATE TABLE will create partition "part_tab_1_prt_3" for table "part_tab"
NOTICE:  CREATE TABLE will create partition "part_tab_1_prt_4" for table "part_tab"
NOTICE:  CREATE TABLE will create partition "part_tab_1_prt_5" for table "part_tab"
-- Wrong part
insert into part_tab_1_prt_1 values(5,5);
select * from part_tab;
 i | j 
---+---
 5 | 5
(1 row)

select * from part_tab_1_prt_1;
 i | j 
---+---
(0 rows)

insert into part_tab_1_prt_2 values(5,5);
select * from part_tab;
 i | j 
---+---
 5 | 5
 5 | 5
(2 rows)

select * from part_tab_1_prt_2;
 i | j 
---+---
(0 rows)

-- Right part
insert into part_tab_1_prt_3 values(5,5);
select * from part_tab;
 i | j 
---+---
 5 | 5
 5 | 5
 5 | 5
(3 rows)

select * from part_tab_1_prt_3;
 i | j 
---+---
 5 | 5
 5 | 5
 5 | 5
(3 rows)

-- Root part
insert into part_tab values(5,5);
select * from part_tab;
 i | j 
---+---
 5 | 5
 5 | 5
 5 | 5
 5 | 5
(4 rows)

drop table if exists input1;
create table input1 (x int, y int);
NOTICE:  Table doesn't have 'DISTRIBUTED BY' clause -- Using column named 'x' as the Greenplum Database data distribution key for this table.
HINT:  The 'DISTRIBUTED BY' clause determines the distribution of data. Make sure column(s) chosen are the optimal data distribution key to minimize skew.
insert into input1 select i, i from (select generate_series(1,10) as i) as t;
drop table if exists input2;
create table input2 (x int, y int);
NOTICE:  Table doesn't have 'DISTRIBUTED BY' clause -- Using column named 'x' as the Greenplum Database data distribution key for this table.
HINT:  The 'DISTRIBUTED BY' clause determines the distribution of data. Make sure column(s) chosen are the optimal data distribution key to minimize skew.
insert into input2 select i, i from (select generate_series(1,10) as i) as t;
-- Multiple range table entries in the plan
insert into part_tab_1_prt_1 select i1.x, i2.y from input1 as i1 join input2 as i2 on i1.x = i2.x where i2.y = 5;
select * from part_tab;
 i | j 
---+---
 5 | 5
 5 | 5
 5 | 5
 5 | 5
 5 | 5
(5 rows)

select * from part_tab_1_prt_1;
 i | j 
---+---
(0 rows)

insert into part_tab_1_prt_2 select i1.x, i2.y from input1 as i1 join input2 as i2 on i1.x = i2.x where i2.y = 5;
select * from part_tab;
 i | j 
---+---
 5 | 5
 5 | 5
 5 | 5
 5 | 5
 5 | 5
 5 | 5
(6 rows)

select * from part_tab_1_prt_2;
 i | j 
---+---
(0 rows)

-- Right part
insert into part_tab_1_prt_3 select i1.x, i2.y from input1 as i1 join input2 as i2 on i1.x = i2.x where i1.x between 4 and 5;
select * from part_tab;
 i | j 
---+---
 4 | 4
 5 | 5
 5 | 5
 5 | 5
 5 | 5
 5 | 5
 5 | 5
 5 | 5
(8 rows)

select * from part_tab_1_prt_3;
 i | j 
---+---
 4 | 4
 5 | 5
 5 | 5
 5 | 5
 5 | 5
 5 | 5
 5 | 5
 5 | 5
(8 rows)

-- Root part but no matching part for i2.y == 10
insert into part_tab select i1.x, i2.y from input1 as i1 join input2 as i2 on i1.x = i2.x;
ERROR:  no partition for partitioning key  (seg1 slarimac:40001 pid=97900)
select * from part_tab;
 i | j 
---+---
 4 | 4
 5 | 5
 5 | 5
 5 | 5
 5 | 5
 5 | 5
 5 | 5
 5 | 5
(8 rows)

-- Root part
insert into part_tab select i1.x, i2.y from input1 as i1 join input2 as i2 on i1.x = i2.x where i2.y < 10;
select * from part_tab;
 i | j 
---+---
 2 | 2
 4 | 4
 4 | 4
 6 | 6
 8 | 8
 1 | 1
 3 | 3
 5 | 5
 5 | 5
 5 | 5
 5 | 5
 5 | 5
 5 | 5
 5 | 5
 5 | 5
 7 | 7
 9 | 9
(17 rows)

-- Multi-level partitioning
drop table if exists deep_part;
create table deep_part ( i int, j int, k int, s char(5)) 
distributed by (i) 
partition by list(s)
subpartition by range (j) subpartition template (start(1)  end(10) every(2))
subpartition by range (k) subpartition template (start(1)  end(10) every(2))
(partition female values('F'), partition male values('M'))
;
NOTICE:  CREATE TABLE will create partition "deep_part_1_prt_female" for table "deep_part"
NOTICE:  CREATE TABLE will create partition "deep_part_1_prt_male" for table "deep_part"
NOTICE:  CREATE TABLE will create partition "deep_part_1_prt_female_2_prt_1" for table "deep_part_1_prt_female"
NOTICE:  CREATE TABLE will create partition "deep_part_1_prt_female_2_prt_1_3_prt_1" for table "deep_part_1_prt_female_2_prt_1"
NOTICE:  CREATE TABLE will create partition "deep_part_1_prt_female_2_prt_1_3_prt_2" for table "deep_part_1_prt_female_2_prt_1"
NOTICE:  CREATE TABLE will create partition "deep_part_1_prt_female_2_prt_1_3_prt_3" for table "deep_part_1_prt_female_2_prt_1"
NOTICE:  CREATE TABLE will create partition "deep_part_1_prt_female_2_prt_1_3_prt_4" for table "deep_part_1_prt_female_2_prt_1"
NOTICE:  CREATE TABLE will create partition "deep_part_1_prt_female_2_prt_1_3_prt_5" for table "deep_part_1_prt_female_2_prt_1"
NOTICE:  CREATE TABLE will create partition "deep_part_1_prt_female_2_prt_2" for table "deep_part_1_prt_female"
NOTICE:  CREATE TABLE will create partition "deep_part_1_prt_female_2_prt_2_3_prt_1" for table "deep_part_1_prt_female_2_prt_2"
NOTICE:  CREATE TABLE will create partition "deep_part_1_prt_female_2_prt_2_3_prt_2" for table "deep_part_1_prt_female_2_prt_2"
NOTICE:  CREATE TABLE will create partition "deep_part_1_prt_female_2_prt_2_3_prt_3" for table "deep_part_1_prt_female_2_prt_2"
NOTICE:  CREATE TABLE will create partition "deep_part_1_prt_female_2_prt_2_3_prt_4" for table "deep_part_1_prt_female_2_prt_2"
NOTICE:  CREATE TABLE will create partition "deep_part_1_prt_female_2_prt_2_3_prt_5" for table "deep_part_1_prt_female_2_prt_2"
NOTICE:  CREATE TABLE will create partition "deep_part_1_prt_female_2_prt_3" for table "deep_part_1_prt_female"
NOTICE:  CREATE TABLE will create partition "deep_part_1_prt_female_2_prt_3_3_prt_1" for table "deep_part_1_prt_female_2_prt_3"
NOTICE:  CREATE TABLE will create partition "deep_part_1_prt_female_2_prt_3_3_prt_2" for table "deep_part_1_prt_female_2_prt_3"
NOTICE:  CREATE TABLE will create partition "deep_part_1_prt_female_2_prt_3_3_prt_3" for table "deep_part_1_prt_female_2_prt_3"
NOTICE:  CREATE TABLE will create partition "deep_part_1_prt_female_2_prt_3_3_prt_4" for table "deep_part_1_prt_female_2_prt_3"
NOTICE:  CREATE TABLE will create partition "deep_part_1_prt_female_2_prt_3_3_prt_5" for table "deep_part_1_prt_female_2_prt_3"
NOTICE:  CREATE TABLE will create partition "deep_part_1_prt_female_2_prt_4" for table "deep_part_1_prt_female"
NOTICE:  CREATE TABLE will create partition "deep_part_1_prt_female_2_prt_4_3_prt_1" for table "deep_part_1_prt_female_2_prt_4"
NOTICE:  CREATE TABLE will create partition "deep_part_1_prt_female_2_prt_4_3_prt_2" for table "deep_part_1_prt_female_2_prt_4"
NOTICE:  CREATE TABLE will create partition "deep_part_1_prt_female_2_prt_4_3_prt_3" for table "deep_part_1_prt_female_2_prt_4"
NOTICE:  CREATE TABLE will create partition "deep_part_1_prt_female_2_prt_4_3_prt_4" for table "deep_part_1_prt_female_2_prt_4"
NOTICE:  CREATE TABLE will create partition "deep_part_1_prt_female_2_prt_4_3_prt_5" for table "deep_part_1_prt_female_2_prt_4"
NOTICE:  CREATE TABLE will create partition "deep_part_1_prt_female_2_prt_5" for table "deep_part_1_prt_female"
NOTICE:  CREATE TABLE will create partition "deep_part_1_prt_female_2_prt_5_3_prt_1" for table "deep_part_1_prt_female_2_prt_5"
NOTICE:  CREATE TABLE will create partition "deep_part_1_prt_female_2_prt_5_3_prt_2" for table "deep_part_1_prt_female_2_prt_5"
NOTICE:  CREATE TABLE will create partition "deep_part_1_prt_female_2_prt_5_3_prt_3" for table "deep_part_1_prt_female_2_prt_5"
NOTICE:  CREATE TABLE will create partition "deep_part_1_prt_female_2_prt_5_3_prt_4" for table "deep_part_1_prt_female_2_prt_5"
NOTICE:  CREATE TABLE will create partition "deep_part_1_prt_female_2_prt_5_3_prt_5" for table "deep_part_1_prt_female_2_prt_5"
NOTICE:  CREATE TABLE will create partition "deep_part_1_prt_male_2_prt_1" for table "deep_part_1_prt_male"
NOTICE:  CREATE TABLE will create partition "deep_part_1_prt_male_2_prt_1_3_prt_1" for table "deep_part_1_prt_male_2_prt_1"
NOTICE:  CREATE TABLE will create partition "deep_part_1_prt_male_2_prt_1_3_prt_2" for table "deep_part_1_prt_male_2_prt_1"
NOTICE:  CREATE TABLE will create partition "deep_part_1_prt_male_2_prt_1_3_prt_3" for table "deep_part_1_prt_male_2_prt_1"
NOTICE:  CREATE TABLE will create partition "deep_part_1_prt_male_2_prt_1_3_prt_4" for table "deep_part_1_prt_male_2_prt_1"
NOTICE:  CREATE TABLE will create partition "deep_part_1_prt_male_2_prt_1_3_prt_5" for table "deep_part_1_prt_male_2_prt_1"
NOTICE:  CREATE TABLE will create partition "deep_part_1_prt_male_2_prt_2" for table "deep_part_1_prt_male"
NOTICE:  CREATE TABLE will create partition "deep_part_1_prt_male_2_prt_2_3_prt_1" for table "deep_part_1_prt_male_2_prt_2"
NOTICE:  CREATE TABLE will create partition "deep_part_1_prt_male_2_prt_2_3_prt_2" for table "deep_part_1_prt_male_2_prt_2"
NOTICE:  CREATE TABLE will create partition "deep_part_1_prt_male_2_prt_2_3_prt_3" for table "deep_part_1_prt_male_2_prt_2"
NOTICE:  CREATE TABLE will create partition "deep_part_1_prt_male_2_prt_2_3_prt_4" for table "deep_part_1_prt_male_2_prt_2"
NOTICE:  CREATE TABLE will create partition "deep_part_1_prt_male_2_prt_2_3_prt_5" for table "deep_part_1_prt_male_2_prt_2"
NOTICE:  CREATE TABLE will create partition "deep_part_1_prt_male_2_prt_3" for table "deep_part_1_prt_male"
NOTICE:  CREATE TABLE will create partition "deep_part_1_prt_male_2_prt_3_3_prt_1" for table "deep_part_1_prt_male_2_prt_3"
NOTICE:  CREATE TABLE will create partition "deep_part_1_prt_male_2_prt_3_3_prt_2" for table "deep_part_1_prt_male_2_prt_3"
NOTICE:  CREATE TABLE will create partition "deep_part_1_prt_male_2_prt_3_3_prt_3" for table "deep_part_1_prt_male_2_prt_3"
NOTICE:  CREATE TABLE will create partition "deep_part_1_prt_male_2_prt_3_3_prt_4" for table "deep_part_1_prt_male_2_prt_3"
NOTICE:  CREATE TABLE will create partition "deep_part_1_prt_male_2_prt_3_3_prt_5" for table "deep_part_1_prt_male_2_prt_3"
NOTICE:  CREATE TABLE will create partition "deep_part_1_prt_male_2_prt_4" for table "deep_part_1_prt_male"
NOTICE:  CREATE TABLE will create partition "deep_part_1_prt_male_2_prt_4_3_prt_1" for table "deep_part_1_prt_male_2_prt_4"
NOTICE:  CREATE TABLE will create partition "deep_part_1_prt_male_2_prt_4_3_prt_2" for table "deep_part_1_prt_male_2_prt_4"
NOTICE:  CREATE TABLE will create partition "deep_part_1_prt_male_2_prt_4_3_prt_3" for table "deep_part_1_prt_male_2_prt_4"
NOTICE:  CREATE TABLE will create partition "deep_part_1_prt_male_2_prt_4_3_prt_4" for table "deep_part_1_prt_male_2_prt_4"
NOTICE:  CREATE TABLE will create partition "deep_part_1_prt_male_2_prt_4_3_prt_5" for table "deep_part_1_prt_male_2_prt_4"
NOTICE:  CREATE TABLE will create partition "deep_part_1_prt_male_2_prt_5" for table "deep_part_1_prt_male"
NOTICE:  CREATE TABLE will create partition "deep_part_1_prt_male_2_prt_5_3_prt_1" for table "deep_part_1_prt_male_2_prt_5"
NOTICE:  CREATE TABLE will create partition "deep_part_1_prt_male_2_prt_5_3_prt_2" for table "deep_part_1_prt_male_2_prt_5"
NOTICE:  CREATE TABLE will create partition "deep_part_1_prt_male_2_prt_5_3_prt_3" for table "deep_part_1_prt_male_2_prt_5"
NOTICE:  CREATE TABLE will create partition "deep_part_1_prt_male_2_prt_5_3_prt_4" for table "deep_part_1_prt_male_2_prt_5"
NOTICE:  CREATE TABLE will create partition "deep_part_1_prt_male_2_prt_5_3_prt_5" for table "deep_part_1_prt_male_2_prt_5"
-- Intermediate partition insert is not allowed
insert into deep_part_1_prt_male_2_prt_2 values(1,1,1,'M');
ERROR:  directly modifying intermediate part of a partitioned table is disallowed
HINT:  Modify either the root or a leaf partition instead.
-- Wrong sub-partition (inserting a female value in male partition)
insert into deep_part_1_prt_male_2_prt_2_3_prt_2 values (1, 1, 1, 'F');
select * from deep_part;
 i | j | k |   s   
---+---+---+-------
 1 | 1 | 1 | F    
(1 row)

-- Correct leaf part
insert into deep_part_1_prt_male_2_prt_1_3_prt_1 values (1, 1, 1, 'M');
select * from deep_part;
 i | j | k |   s   
---+---+---+-------
 1 | 1 | 1 | F    
 1 | 1 | 1 | M    
(2 rows)

select * from deep_part_1_prt_male_2_prt_1_3_prt_1;
 i | j | k |   s   
---+---+---+-------
 1 | 1 | 1 | M    
(1 row)

-- Root part of a multi-level partitioned table
insert into deep_part values (1, 1, 1, 'M');
select * from deep_part;
 i | j | k |   s   
---+---+---+-------
 1 | 1 | 1 | F    
 1 | 1 | 1 | M    
 1 | 1 | 1 | M    
(3 rows)

select * from deep_part_1_prt_male_2_prt_1_3_prt_1;
 i | j | k |   s   
---+---+---+-------
 1 | 1 | 1 | M    
 1 | 1 | 1 | M    
(2 rows)

insert into deep_part values (1, 1, 1, 'F');
select * from deep_part;
 i | j | k |   s   
---+---+---+-------
 1 | 1 | 1 | F    
 1 | 1 | 1 | F    
 1 | 1 | 1 | M    
 1 | 1 | 1 | M    
(4 rows)

select * from deep_part_1_prt_female_2_prt_1_3_prt_1;
 i | j | k |   s   
---+---+---+-------
 1 | 1 | 1 | F    
 1 | 1 | 1 | F    
(2 rows)

insert into deep_part values (5, 5, 5, 'M');
select * from deep_part;
 i | j | k |   s   
---+---+---+-------
 1 | 1 | 1 | F    
 1 | 1 | 1 | F    
 1 | 1 | 1 | M    
 1 | 1 | 1 | M    
 5 | 5 | 5 | M    
(5 rows)

select * from deep_part_1_prt_male_2_prt_3_3_prt_3;
 i | j | k |   s   
---+---+---+-------
 5 | 5 | 5 | M    
(1 row)

insert into deep_part values (9, 9, 9, 'F');
select * from deep_part;
 i | j | k |   s   
---+---+---+-------
 1 | 1 | 1 | F    
 1 | 1 | 1 | F    
 9 | 9 | 9 | F    
 1 | 1 | 1 | M    
 1 | 1 | 1 | M    
 5 | 5 | 5 | M    
(6 rows)

select * from deep_part_1_prt_female_2_prt_5_3_prt_5;
 i | j | k |   s   
---+---+---+-------
 9 | 9 | 9 | F    
(1 row)

-- Out of range partition
insert into deep_part values (9, 9, 10, 'F');
ERROR:  no partition for partitioning key  (seg2 127.0.1.1:25434 pid=22690)
select * from deep_part;
 i | j | k |   s   
---+---+---+-------
 1 | 1 | 1 | F    
 1 | 1 | 1 | F    
 1 | 1 | 1 | M    
 1 | 1 | 1 | M    
 5 | 5 | 5 | M    
 9 | 9 | 9 | F    
(6 rows)

drop table input2;
drop table input1;
-- Avoid TupleDesc leak when COPY partition table from files
-- This also covers the bug reported in MPP-9548 where insertion
-- into a dropped/added column yielded incorrect results
drop table if exists pt_td_leak;
NOTICE:  table "pt_td_leak" does not exist, skipping
CREATE TABLE pt_td_leak
(
col1 int,
col2 int,
col3 int
)
distributed by (col1)
partition by range(col2)
(
    partition part1 start(1) end(5),
    partition part2 start(5) end(10)
);
NOTICE:  CREATE TABLE will create partition "pt_td_leak_1_prt_part1" for table "pt_td_leak"
NOTICE:  CREATE TABLE will create partition "pt_td_leak_1_prt_part2" for table "pt_td_leak"
insert into pt_td_leak select i,i,i from generate_series(1,9) i;
copy pt_td_leak to '/tmp/pt_td_leak.out' csv;
alter table pt_td_leak drop column col3;
alter table pt_td_leak add column col3 int default 7;
drop table if exists pt_td_leak_exchange;
NOTICE:  table "pt_td_leak_exchange" does not exist, skipping
CREATE TABLE pt_td_leak_exchange ( col1 int, col2 int, col3 int) distributed by (col1);
alter table pt_td_leak exchange partition part2 with table pt_td_leak_exchange;
insert into pt_td_leak values(1,8,1);
copy pt_td_leak from '/tmp/pt_td_leak.out' with delimiter ',';
select * from pt_td_leak where col1 = 5;
 col1 | col2 | col3 
------+------+------
    5 |    5 |    5
(1 row)

-- Check that data inserted into dropped/added column is correct
select * from pt_td_leak where col3 = 1;
 col1 | col2 | col3 
------+------+------
    1 |    1 |    1
    1 |    8 |    1
(2 rows)

drop table pt_td_leak;
drop table pt_td_leak_exchange;
--
-- Test COPY, when distribution keys have different attribute numbers,
-- because of dropped columns
--
CREATE TABLE pt_dropped_col_distkey (i int, to_be_dropped text, t text)
DISTRIBUTED BY (t) PARTITION BY RANGE (i) (START (1) END(10) EVERY (5));
INSERT INTO pt_dropped_col_distkey SELECT g, 'dropped' || g, 'before drop ' || g FROM generate_series(1, 7) g;
ALTER TABLE pt_dropped_col_distkey DROP COLUMN to_be_dropped;
-- This new partition won't have the dropped column. Because the distribution
-- key was after the dropped column, the attribute number of the distribution
-- key column will be different in this partition and the parent.
ALTER TABLE pt_dropped_col_distkey ADD PARTITION pt_dropped_col_distkey_new_part START (10) END (100);
INSERT INTO pt_dropped_col_distkey SELECT g, 'after drop ' || g FROM generate_series(8, 15) g;
SELECT * FROM pt_dropped_col_distkey ORDER BY i;
 i  |       t       
----+---------------
  1 | before drop 1
  2 | before drop 2
  3 | before drop 3
  4 | before drop 4
  5 | before drop 5
  6 | before drop 6
  7 | before drop 7
  8 | after drop 8
  9 | after drop 9
 10 | after drop 10
 11 | after drop 11
 12 | after drop 12
 13 | after drop 13
 14 | after drop 14
 15 | after drop 15
(15 rows)

COPY pt_dropped_col_distkey TO '/tmp/pt_dropped_col_distkey.out';
DELETE FROM pt_dropped_col_distkey;
COPY pt_dropped_col_distkey FROM '/tmp/pt_dropped_col_distkey.out';
SELECT * FROM pt_dropped_col_distkey ORDER BY i;
 i  |       t       
----+---------------
  1 | before drop 1
  2 | before drop 2
  3 | before drop 3
  4 | before drop 4
  5 | before drop 5
  6 | before drop 6
  7 | before drop 7
  8 | after drop 8
  9 | after drop 9
 10 | after drop 10
 11 | after drop 11
 12 | after drop 12
 13 | after drop 13
 14 | after drop 14
 15 | after drop 15
(15 rows)

-- don't drop the table, so that we have a partitioned table like this still
-- in the database, when we test pg_upgrade later.
--
-- Test split default partition while per tuple memory context is reset
--
drop table if exists test_split_part cascade;
NOTICE:  table "test_split_part" does not exist, skipping
CREATE TABLE test_split_part ( log_id int NOT NULL, f_array int[] NOT NULL)
DISTRIBUTED BY (log_id)
PARTITION BY RANGE(log_id)
(
    START (1::int) END (100::int) EVERY (5) WITH (appendonly=false),
    PARTITION "Old" START (101::int) END (201::int) WITH (appendonly=false),
    DEFAULT PARTITION other_log_ids  WITH (appendonly=false)
);
NOTICE:  CREATE TABLE will create partition "test_split_part_1_prt_other_log_ids" for table "test_split_part"
NOTICE:  CREATE TABLE will create partition "test_split_part_1_prt_2" for table "test_split_part"
NOTICE:  CREATE TABLE will create partition "test_split_part_1_prt_3" for table "test_split_part"
NOTICE:  CREATE TABLE will create partition "test_split_part_1_prt_4" for table "test_split_part"
NOTICE:  CREATE TABLE will create partition "test_split_part_1_prt_5" for table "test_split_part"
NOTICE:  CREATE TABLE will create partition "test_split_part_1_prt_6" for table "test_split_part"
NOTICE:  CREATE TABLE will create partition "test_split_part_1_prt_7" for table "test_split_part"
NOTICE:  CREATE TABLE will create partition "test_split_part_1_prt_8" for table "test_split_part"
NOTICE:  CREATE TABLE will create partition "test_split_part_1_prt_9" for table "test_split_part"
NOTICE:  CREATE TABLE will create partition "test_split_part_1_prt_10" for table "test_split_part"
NOTICE:  CREATE TABLE will create partition "test_split_part_1_prt_11" for table "test_split_part"
NOTICE:  CREATE TABLE will create partition "test_split_part_1_prt_12" for table "test_split_part"
NOTICE:  CREATE TABLE will create partition "test_split_part_1_prt_13" for table "test_split_part"
NOTICE:  CREATE TABLE will create partition "test_split_part_1_prt_14" for table "test_split_part"
NOTICE:  CREATE TABLE will create partition "test_split_part_1_prt_15" for table "test_split_part"
NOTICE:  CREATE TABLE will create partition "test_split_part_1_prt_16" for table "test_split_part"
NOTICE:  CREATE TABLE will create partition "test_split_part_1_prt_17" for table "test_split_part"
NOTICE:  CREATE TABLE will create partition "test_split_part_1_prt_18" for table "test_split_part"
NOTICE:  CREATE TABLE will create partition "test_split_part_1_prt_19" for table "test_split_part"
NOTICE:  CREATE TABLE will create partition "test_split_part_1_prt_20" for table "test_split_part"
NOTICE:  CREATE TABLE will create partition "test_split_part_1_prt_21" for table "test_split_part"
NOTICE:  CREATE TABLE will create partition "test_split_part_1_prt_Old" for table "test_split_part"
insert into test_split_part (log_id , f_array) select id, '{10}' from generate_series(1,1000) id;
ALTER TABLE test_split_part SPLIT DEFAULT PARTITION START (201) INCLUSIVE END (301) EXCLUSIVE INTO (PARTITION "New", DEFAULT PARTITION);
NOTICE:  exchanged partition "other_log_ids" of relation "test_split_part" with relation "pg_temp_325194"
NOTICE:  dropped partition "other_log_ids" for relation "test_split_part"
NOTICE:  CREATE TABLE will create partition "test_split_part_1_prt_New" for table "test_split_part"
NOTICE:  CREATE TABLE will create partition "test_split_part_1_prt_other_log_ids" for table "test_split_part"
-- Only the root partition should have automatically created an array type
select typname, typtype, typcategory from pg_type where typname like '%test_split_part%' and typcategory = 'A';
     typname      | typtype | typcategory 
------------------+---------+-------------
 _test_split_part | b       | A
(1 row)

select array_agg(test_split_part) from test_split_part where log_id = 500;
   array_agg    
----------------
 {"(500,{10})"}
(1 row)

select array_agg(test_split_part_1_prt_other_log_ids) from test_split_part_1_prt_other_log_ids where log_id = 500;
ERROR:  could not find array type for data type test_split_part_1_prt_other_log_ids
-- Test that pg_get_partition_def() correctly dumps the renamed names for
-- partitions. Originally reported in MPP-7232
create table mpp7232a (a int, b int) distributed by (a) partition by range (b) (start (1) end (3) every (1));
select pg_get_partition_def('mpp7232a'::regclass, true);
         pg_get_partition_def          
---------------------------------------
 PARTITION BY RANGE(b)                +
           (                          +
           START (1) END (3) EVERY (1)+
           )
(1 row)

alter table mpp7232a rename partition for (rank(1)) to alpha;
alter table mpp7232a rename partition for (rank(2)) to bravo;
select partitionname, partitionrank from pg_partitions where tablename like 'mpp7232a' order by 2;
 partitionname | partitionrank 
---------------+---------------
 alpha         |             1
 bravo         |             2
(2 rows)

select pg_get_partition_def('mpp7232a'::regclass, true);
                  pg_get_partition_def                   
---------------------------------------------------------
 PARTITION BY RANGE(b)                                  +
           (                                            +
           PARTITION alpha START (1) END (2) EVERY (1), +
           PARTITION bravo START (2) END (3) EVERY (1)  +
           )
(1 row)

create table mpp7232b (a int, b int) distributed by (a) partition by range (b) (partition alpha start (1) end (3) every (1));
select partitionname, partitionrank from pg_partitions where tablename like 'mpp7232b' order by 2;
 partitionname | partitionrank 
---------------+---------------
 alpha_1       |             1
 alpha_2       |             2
(2 rows)

alter table mpp7232b rename partition for (rank(1)) to foo;
NOTICE:  renamed partition "alpha_1" to "foo" for relation "mpp7232b"
select pg_get_partition_def('mpp7232b'::regclass, true);
                  pg_get_partition_def                   
---------------------------------------------------------
 PARTITION BY RANGE(b)                                  +
           (                                            +
           PARTITION alpha_2 START (2) END (3) EVERY (1)+
           PARTITION foo START (1) END (2) EVERY (1),   +
           )
(1 row)

-- Test .. WITH (tablename = <foo> ..) syntax.
create table mpp17740 (a integer, b integer, e date) with (appendonly = true, orientation = column)
distributed by (a)
partition by range(e)
(
    partition mpp17740_20120523 start ('2012-05-23'::date) inclusive end ('2012-05-24'::date) exclusive with (tablename = 'mpp17740_20120523', appendonly = true),
    partition mpp17740_20120524 start ('2012-05-24'::date) inclusive end ('2012-05-25'::date) exclusive with (tablename = 'mpp17740_20120524', appendonly = true)
);
select partitiontablename, partitionrangestart, partitionrangeend from pg_partitions where tablename = 'mpp17740' order by partitiontablename;
 partitiontablename | partitionrangestart | partitionrangeend  
--------------------+---------------------+--------------------
 mpp17740_20120523  | '05-23-2012'::date  | '05-24-2012'::date
 mpp17740_20120524  | '05-24-2012'::date  | '05-25-2012'::date
(2 rows)

alter table mpp17740 add partition mpp17740_20120520 start ('2012-05-20'::date) inclusive end ('2012-05-21'::date) exclusive with (tablename = 'mpp17740_20120520', appendonly=true);
select partitiontablename, partitionrangestart, partitionrangeend from pg_partitions where tablename = 'mpp17740' order by partitiontablename;
 partitiontablename | partitionrangestart | partitionrangeend  
--------------------+---------------------+--------------------
 mpp17740_20120520  | '05-20-2012'::date  | '05-21-2012'::date
 mpp17740_20120523  | '05-23-2012'::date  | '05-24-2012'::date
 mpp17740_20120524  | '05-24-2012'::date  | '05-25-2012'::date
(3 rows)

-- Test mix of add and drop various column before split, and exchange partition at the end
create table sales (pkid serial, option1 int, option2 int, option3 int, constraint partable_pkey primary key(pkid, option3))
distributed by (pkid) partition by range (option3)
(
	partition aa start(1) end(100),
	partition bb start(101) end(200),
	partition cc start(201) end (300)
);
-- root partition (and only root) should have relfrozenxid as 0
select relname from pg_class where relkind = 'r' and relname like 'sales%' and relfrozenxid=0;
 relname 
---------
 sales
(1 row)

select gp_segment_id, relname from gp_dist_random('pg_class') where relkind = 'r' and relname like 'sales%' and relfrozenxid=0;
 gp_segment_id | relname 
---------------+---------
             1 | sales
             2 | sales
             0 | sales
(3 rows)

alter table sales add column tax float;
-- root partition (and only root) continues to have relfrozenxid as 0
select relname from pg_class where relkind = 'r' and relname like 'sales%' and relfrozenxid=0;
 relname 
---------
 sales
(1 row)

select gp_segment_id, relname from gp_dist_random('pg_class') where relkind = 'r' and relname like 'sales%' and relfrozenxid=0;
 gp_segment_id | relname 
---------------+---------
             2 | sales
             0 | sales
             1 | sales
(3 rows)

alter table sales drop column tax;
create table newpart(like sales);
NOTICE:  table doesn't have 'DISTRIBUTED BY' clause, defaulting to distribution columns from LIKE table
alter table newpart add constraint newpart_pkey primary key(pkid, option3);
alter table sales split partition for(1) at (50) into (partition aa1, partition aa2);
NOTICE:  dropped partition "aa" for relation "sales"
select table_schema, table_name, constraint_name, constraint_type
	from information_schema.table_constraints
	where table_name in ('sales', 'newpart')
	and constraint_name in ('partable_pkey', 'newpart_pkey')
	order by table_name desc;
 table_schema | table_name | constraint_name | constraint_type 
--------------+------------+-----------------+-----------------
 public       | sales      | partable_pkey   | PRIMARY KEY
 public       | newpart    | newpart_pkey    | PRIMARY KEY
(2 rows)

alter table sales exchange partition for (101) with table newpart;
select * from sales order by pkid;
 pkid | option1 | option2 | option3 
------+---------+---------+---------
(0 rows)

-- Create exchange table before drop column, make sure the consistency check still exist
create table newpart2(like sales);
alter table sales drop column option2;
alter table sales exchange partition for (101) with table newpart2;
ERROR:  relation "newpart2" must have the same column names and column order as "sales"
select * from sales order by pkid;
 pkid | option1 | option3 
------+---------+---------
(0 rows)

drop table sales cascade;
NOTICE:  drop cascades to default for table newpart column pkid
-- Exchage partiton table with a table having dropped column
create table exchange_part(a int, b int) partition by range(b) (start (0) end (10) every (5));
NOTICE:  CREATE TABLE will create partition "exchange_part_1_prt_1" for table "exchange_part"
NOTICE:  CREATE TABLE will create partition "exchange_part_1_prt_2" for table "exchange_part"
NOTICE:  CREATE TABLE will create partition "exchange_part_1_prt_3" for table "exchange_part"
NOTICE:  CREATE TABLE will create partition "exchange_part_1_prt_4" for table "exchange_part"
NOTICE:  CREATE TABLE will create partition "exchange_part_1_prt_5" for table "exchange_part"
NOTICE:  CREATE TABLE will create partition "exchange_part_1_prt_6" for table "exchange_part"
NOTICE:  CREATE TABLE will create partition "exchange_part_1_prt_7" for table "exchange_part"
NOTICE:  CREATE TABLE will create partition "exchange_part_1_prt_8" for table "exchange_part"
NOTICE:  CREATE TABLE will create partition "exchange_part_1_prt_9" for table "exchange_part"
NOTICE:  CREATE TABLE will create partition "exchange_part_1_prt_10" for table "exchange_part"
create table exchange1(a int, c int, b int);
alter table exchange1 drop column c;
alter table exchange_part exchange partition for (1) with table exchange1;
copy exchange_part from STDIN DELIMITER as '|';
select * from exchange_part;
  a   | b 
------+---
 9797 | 3
 9799 | 4
 9801 | 5
 9836 | 5
 9802 | 6
 9840 | 6
 9803 | 7
 9822 | 7
 9806 | 8
 9824 | 8
 9807 | 9
 9794 | 1
 9808 | 1
 9810 | 2
 9828 | 2
 9831 | 3
 9817 | 5
 9818 | 6
 9843 | 7
 9844 | 8
 9825 | 9
 9827 | 1
 9795 | 2
 9814 | 3
 9815 | 4
 9832 | 4
(26 rows)

drop table exchange_part;
drop table exchange1;
-- Ensure that new partitions get the correct attributes (MPP17110)
CREATE TABLE pt_tab_encode (a int, b text)
with (appendonly=true, orientation=column, compresstype=zlib, compresslevel=1)
distributed by (a)
partition by list(b) (partition s_abc values ('abc') with (appendonly=true, orientation=column, compresstype=zlib, compresslevel=1));
NOTICE:  CREATE TABLE will create partition "pt_tab_encode_1_prt_s_abc" for table "pt_tab_encode"
alter table pt_tab_encode add partition "s_xyz" values ('xyz') WITH (appendonly=true, orientation=column, compresstype=zlib, compresslevel=1);
NOTICE:  CREATE TABLE will create partition "pt_tab_encode_1_prt_s_xyz" for table "pt_tab_encode"
select tablename, partitiontablename from pg_partitions where tablename = 'pt_tab_encode';
   tablename   |    partitiontablename     
---------------+---------------------------
 pt_tab_encode | pt_tab_encode_1_prt_s_abc
 pt_tab_encode | pt_tab_encode_1_prt_s_xyz
(2 rows)

select gp_segment_id, attrelid::regclass, attnum, attoptions from pg_attribute_encoding where attrelid = 'pt_tab_encode_1_prt_s_abc'::regclass;
 gp_segment_id |         attrelid          | attnum |                     attoptions                      
---------------+---------------------------+--------+-----------------------------------------------------
            -1 | pt_tab_encode_1_prt_s_abc |      1 | {compresstype=zlib,compresslevel=1,blocksize=32768}
            -1 | pt_tab_encode_1_prt_s_abc |      2 | {compresstype=zlib,compresslevel=1,blocksize=32768}
(2 rows)

select gp_segment_id, attrelid::regclass, attnum, attoptions from gp_dist_random('pg_attribute_encoding') where attrelid = 'pt_tab_encode_1_prt_s_abc'::regclass order by 1,3 limit 5;
 gp_segment_id |         attrelid          | attnum |                     attoptions                      
---------------+---------------------------+--------+-----------------------------------------------------
             0 | pt_tab_encode_1_prt_s_abc |      1 | {compresstype=zlib,compresslevel=1,blocksize=32768}
             0 | pt_tab_encode_1_prt_s_abc |      2 | {compresstype=zlib,compresslevel=1,blocksize=32768}
             1 | pt_tab_encode_1_prt_s_abc |      1 | {compresstype=zlib,compresslevel=1,blocksize=32768}
             1 | pt_tab_encode_1_prt_s_abc |      2 | {compresstype=zlib,compresslevel=1,blocksize=32768}
             2 | pt_tab_encode_1_prt_s_abc |      1 | {compresstype=zlib,compresslevel=1,blocksize=32768}
(5 rows)

select gp_segment_id, attrelid::regclass, attnum, attoptions from pg_attribute_encoding where attrelid = 'pt_tab_encode_1_prt_s_xyz'::regclass;
 gp_segment_id |         attrelid          | attnum |                     attoptions                      
---------------+---------------------------+--------+-----------------------------------------------------
            -1 | pt_tab_encode_1_prt_s_xyz |      1 | {compresstype=zlib,compresslevel=1,blocksize=32768}
            -1 | pt_tab_encode_1_prt_s_xyz |      2 | {compresstype=zlib,compresslevel=1,blocksize=32768}
(2 rows)

select gp_segment_id, attrelid::regclass, attnum, attoptions from gp_dist_random('pg_attribute_encoding') where attrelid = 'pt_tab_encode_1_prt_s_xyz'::regclass order by 1,3 limit 5;
 gp_segment_id |         attrelid          | attnum |                     attoptions                      
---------------+---------------------------+--------+-----------------------------------------------------
             0 | pt_tab_encode_1_prt_s_xyz |      1 | {compresstype=zlib,compresslevel=1,blocksize=32768}
             0 | pt_tab_encode_1_prt_s_xyz |      2 | {compresstype=zlib,compresslevel=1,blocksize=32768}
             1 | pt_tab_encode_1_prt_s_xyz |      1 | {compresstype=zlib,compresslevel=1,blocksize=32768}
             1 | pt_tab_encode_1_prt_s_xyz |      2 | {compresstype=zlib,compresslevel=1,blocksize=32768}
             2 | pt_tab_encode_1_prt_s_xyz |      1 | {compresstype=zlib,compresslevel=1,blocksize=32768}
(5 rows)

select oid::regclass, relkind, relstorage, reloptions from pg_class where oid = 'pt_tab_encode_1_prt_s_abc'::regclass;
            oid            | relkind | relstorage |                               reloptions                               
---------------------------+---------+------------+------------------------------------------------------------------------
 pt_tab_encode_1_prt_s_abc | r       | c          | {appendonly=true,orientation=column,compresstype=zlib,compresslevel=1}
(1 row)

select oid::regclass, relkind, relstorage, reloptions from pg_class where oid = 'pt_tab_encode_1_prt_s_xyz'::regclass;
            oid            | relkind | relstorage |                               reloptions                               
---------------------------+---------+------------+------------------------------------------------------------------------
 pt_tab_encode_1_prt_s_xyz | r       | c          | {appendonly=true,orientation=column,compresstype=zlib,compresslevel=1}
(1 row)

-- Ensure that only the correct type of partitions can be added
create table at_range (a int) partition by range (a) (start(1) end(5));
NOTICE:  CREATE TABLE will create partition "at_range_1_prt_1" for table "at_range"
create table at_list (i int) partition by list(i) (partition p1 values(1));
NOTICE:  CREATE TABLE will create partition "at_list_1_prt_p1" for table "at_list"
alter table at_list add partition foo2 start(6) end (10);
ERROR:  cannot add range partition to list partitioned table
alter table at_range add partition test values(5);
ERROR:  cannot add list partition to range partitioned table
-- Ensure array type for the non-partition table is there after partition exchange.
CREATE TABLE pt_xchg(a int) PARTITION BY RANGE(a) (START(1) END(4) EVERY (2));
NOTICE:  Table doesn't have 'DISTRIBUTED BY' clause -- Using column named 'a' as the Greenplum Database data distribution key for this table.
HINT:  The 'DISTRIBUTED BY' clause determines the distribution of data. Make sure column(s) chosen are the optimal data distribution key to minimize skew.
NOTICE:  CREATE TABLE will create partition "pt_xchg_1_prt_1" for table "pt_xchg"
NOTICE:  CREATE TABLE will create partition "pt_xchg_1_prt_2" for table "pt_xchg"
create table xchg_tab1(a int);
NOTICE:  Table doesn't have 'DISTRIBUTED BY' clause -- Using column named 'a' as the Greenplum Database data distribution key for this table.
HINT:  The 'DISTRIBUTED BY' clause determines the distribution of data. Make sure column(s) chosen are the optimal data distribution key to minimize skew.
CREATE SCHEMA xchg_schema;
create table xchg_schema.xchg_tab2(a int);
NOTICE:  Table doesn't have 'DISTRIBUTED BY' clause -- Using column named 'a' as the Greenplum Database data distribution key for this table.
HINT:  The 'DISTRIBUTED BY' clause determines the distribution of data. Make sure column(s) chosen are the optimal data distribution key to minimize skew.
alter table pt_xchg exchange partition for (1) with table xchg_tab1;
alter table pt_xchg exchange partition for (3) with table xchg_schema.xchg_tab2;
select a.typowner=b.typowner from pg_type a join pg_type b on true where a.typname = 'xchg_tab1' and b.typname = '_xchg_tab1';
 ?column? 
----------
 t
(1 row)

select nspname from pg_namespace join pg_type on pg_namespace.oid = pg_type.typnamespace where pg_type.typname = 'xchg_tab1' or pg_type.typname = '_xchg_tab1';
 nspname 
---------
 public
 public
(2 rows)

select nspname from pg_namespace join pg_type on pg_namespace.oid = pg_type.typnamespace where pg_type.typname = 'xchg_tab2' or pg_type.typname = '_xchg_tab2';
   nspname   
-------------
 xchg_schema
 xchg_schema
(2 rows)

select typname from pg_type where typelem = 'xchg_tab1'::regtype;
  typname   
------------
 _xchg_tab1
(1 row)

select typname from pg_type where typelem = 'xchg_schema.xchg_tab2'::regtype;
  typname   
------------
 _xchg_tab2
(1 row)

select typname from pg_type where typarray = '_xchg_tab1'::regtype;
  typname  
-----------
 xchg_tab1
(1 row)

select typname from pg_type where typarray = 'xchg_schema._xchg_tab2'::regtype;
  typname  
-----------
 xchg_tab2
(1 row)

alter table pt_xchg exchange partition for (1) with table xchg_tab1;
select a.typowner=b.typowner from pg_type a join pg_type b on true where a.typname = 'xchg_tab1' and b.typname = '_xchg_tab1';
 ?column? 
----------
 t
(1 row)

select nspname from pg_namespace join pg_type on pg_namespace.oid = pg_type.typnamespace where pg_type.typname = 'xchg_tab1' or pg_type.typname = '_xchg_tab1';
 nspname 
---------
 public
 public
(2 rows)

select typname from pg_type where typelem = 'xchg_tab1'::regtype;
  typname   
------------
 _xchg_tab1
(1 row)

select typname from pg_type where typarray = '_xchg_tab1'::regtype;
  typname  
-----------
 xchg_tab1
(1 row)

