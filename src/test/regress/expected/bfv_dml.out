--  MPP-21536: Duplicated rows inserted when ORCA is turned on
-- create test table
create table m();
NOTICE:  Table doesn't have 'DISTRIBUTED BY' clause, and no column type is suitable for a distribution key. Creating a NULL policy entry.
alter table m add column a int;
alter table m add column b int;
-- generate data for m
insert into m select i, i%5 from generate_series(1,10)i;
-- INSERT and UPDATE
create table yyy(a int, b int) distributed randomly;
insert into yyy select a,b from m;
select * from yyy order by 1, 2;
 a  | b 
----+---
  1 | 1
  2 | 2
  3 | 3
  4 | 4
  5 | 0
  6 | 1
  7 | 2
  8 | 3
  9 | 4
 10 | 0
(10 rows)

update yyy set a=m.b from m where m.a=yyy.b;
select * from yyy order by 1, 2;
 a  | b 
----+---
  1 | 1
  1 | 1
  2 | 2
  2 | 2
  3 | 3
  3 | 3
  4 | 4
  4 | 4
  5 | 0
 10 | 0
(10 rows)

drop table yyy;
-- UPDATE with different values
create table yyy(a int, b int) distributed randomly;
insert into yyy select a,b from m;
update yyy set b=m.b from m where m.a=yyy.a;
select * from yyy order by 1, 2;
 a  | b 
----+---
  1 | 1
  2 | 2
  3 | 3
  4 | 4
  5 | 0
  6 | 1
  7 | 2
  8 | 3
  9 | 4
 10 | 0
(10 rows)

drop table yyy;
-- DELETE
create table yyy(a int, b int) distributed randomly;
insert into yyy select a,b from m;
delete from yyy where a in (select a from m);
select * from yyy order by 1, 2;
 a | b 
---+---
(0 rows)

drop table yyy;
create table yyy(a int, b int) distributed randomly;
insert into yyy select a,b from m;
delete from yyy where b in (select a from m);
select * from yyy order by 1, 2;
 a  | b 
----+---
  5 | 0
 10 | 0
(2 rows)

drop table yyy;
-- Now repeat all the above tests, but using a hacked master-only 'm' table
drop table m;
set optimizer_enable_master_only_queries=on;
-- create master-only table
create table m();
NOTICE:  Table doesn't have 'DISTRIBUTED BY' clause, and no column type is suitable for a distribution key. Creating a NULL policy entry.
set allow_system_table_mods=true;
delete from gp_distribution_policy where localoid='m'::regclass;
reset allow_system_table_mods;
alter table m add column a int;
alter table m add column b int;
-- generate data for m
insert into m select i, i%5 from generate_series(1,10)i;
create table zzz(a int primary key, b int) distributed by (a);
insert into zzz select a,b from m;
select * from zzz order by 1, 2;
 a  | b 
----+---
  1 | 1
  2 | 2
  3 | 3
  4 | 4
  5 | 0
  6 | 1
  7 | 2
  8 | 3
  9 | 4
 10 | 0
(10 rows)

delete from zzz where a in (select a from m);
select * from zzz order by 1, 2;
 a | b 
---+---
(0 rows)

drop table zzz;
create table zzz(a int primary key, b int) distributed by (a);
insert into zzz select a,b from m;
delete from zzz where b in (select a from m);
select * from zzz order by 1, 2;
 a  | b 
----+---
  5 | 0
 10 | 0
(2 rows)

drop table zzz;
create table zzz(a int primary key, b int) distributed by (a);
insert into zzz select a,b from m;
-- This update fails with duplicate key error, but it varies which segment
-- reports it first, i.e. it varies which row it complaints first. Silence
-- that difference in the error DETAIL line
\set VERBOSITY terse
update zzz set a=m.b from m where m.a=zzz.b;
ERROR:  duplicate key value violates unique constraint "zzz_pkey"  (seg1 10.152.10.32:25433 pid=2877)
select * from zzz order by 1, 2;
 a  | b 
----+---
  1 | 1
  2 | 2
  3 | 3
  4 | 4
  5 | 0
  6 | 1
  7 | 2
  8 | 3
  9 | 4
 10 | 0
(10 rows)

drop table zzz;
create table zzz(a int primary key, b int) distributed by (a);
insert into zzz select a,b from m;
update zzz set b=m.b from m where m.a=zzz.a;
select * from zzz order by 1, 2;
 a  | b 
----+---
  1 | 1
  2 | 2
  3 | 3
  4 | 4
  5 | 0
  6 | 1
  7 | 2
  8 | 3
  9 | 4
 10 | 0
(10 rows)

drop table zzz;
drop table m;
-- MPP-21622 Update with primary key: only sort if the primary key is updated
--
-- Aside from testing that bug, this also tests EXPLAIN of an DMLActionExpr
-- that ORCA generates for plans that update the primary key.
create table update_pk_test (a int primary key, b int) distributed by (a);
insert into update_pk_test values(1,1);
explain update update_pk_test set b = 5;
                             QUERY PLAN                              
---------------------------------------------------------------------
 Update on update_pk_test  (cost=0.00..1.01 rows=1 width=14)
   ->  Seq Scan on update_pk_test  (cost=0.00..1.01 rows=1 width=14)
 Settings:  optimizer=off
 Optimizer status: Postgres query optimizer
(4 rows)

update update_pk_test set b = 5;
select * from update_pk_test order by 1,2;
 a | b 
---+---
 1 | 5
(1 row)

explain update update_pk_test set a = 5;
                                       QUERY PLAN                                        
-----------------------------------------------------------------------------------------
 Update on update_pk_test  (cost=0.00..1.01 rows=1 width=14)
   ->  Redistribute Motion 3:3  (slice1; segments: 3)  (cost=0.00..1.01 rows=1 width=14)
         Hash Key: a
         ->  Split  (cost=0.00..1.01 rows=1 width=14)
               ->  Seq Scan on update_pk_test  (cost=0.00..1.01 rows=1 width=14)
 Optimizer: Postgres query optimizer
(6 rows)

update update_pk_test set a = 5;
select * from update_pk_test order by 1,2;
 a | b 
---+---
 5 | 5
(1 row)

-- MPP-22599 DML queries that fallback to planner don't check for updates on
-- the distribution key.
--
-- So the bug was that if ORCA fell back to the planner, then the usual
-- check that prohibits updating the distribution key columns was not
-- performed like it should. So the idea of this test is to have an UPDATE
-- on distribution key column, with some features in the table or the query,
-- such that ORCA cannot produce a plan and it falls back to the Postgres
-- planner.
set optimizer_trace_fallback = on;
-- Subquery that returns a row rather than a single scalar isn't supported
-- in ORCA currently, so we can use that to trigger fallback.
update update_pk_test set a=1 where row(1,2) = (SELECT 1, 2);
select * from update_pk_test order by 1,2;
 a | b 
---+---
 1 | 5
(1 row)

reset optimizer_trace_fallback;
--
-- Check that INSERT and DELETE triggers don't fire on UPDATE.
--
-- It may seem weird how that could happen, but with ORCA, UPDATEs are
-- implemented as a "split update", which is really a DELETE and an INSERT.
--
CREATE TABLE bfv_dml_trigger_test (id int4, t text);
INSERT INTO bfv_dml_trigger_test VALUES (1, 'foo');
CREATE OR REPLACE FUNCTION bfv_dml_error_func() RETURNS trigger AS
$$
BEGIN
   RAISE EXCEPTION 'trigger was called!';
   RETURN NEW;
END
$$ LANGUAGE 'plpgsql';
CREATE TRIGGER before_trigger BEFORE INSERT or DELETE ON bfv_dml_trigger_test
FOR EACH ROW
EXECUTE PROCEDURE bfv_dml_error_func();
CREATE TRIGGER after_trigger AFTER INSERT or DELETE ON bfv_dml_trigger_test
FOR EACH ROW
EXECUTE PROCEDURE bfv_dml_error_func();
UPDATE bfv_dml_trigger_test SET t = 'bar';
UPDATE bfv_dml_trigger_test SET id = id + 1;
--
-- Verify that ExecInsert doesn't scribble on the old tuple, when the new
-- tuple comes directly from the old table.
--
CREATE TABLE execinsert_test (id int4, t text) DISTRIBUTED BY (id);
INSERT INTO execinsert_test values (1, 'foo');
-- Insert another identical tuple, but roll it back. If the insertion
-- incorrectly modified the xmin on the old tuple, then it will become
-- invisible when we roll back.
begin;
INSERT INTO execinsert_test select * FROM execinsert_test;
rollback;
select * from execinsert_test;
 id |  t  
----+-----
  1 | foo
(1 row)

drop table execinsert_test;
-- Repeat with a hacked master-only table, just in case the planner decides
-- to add a Motion node or something that hides the problem otherwise.
CREATE TABLE execinsert_test (id int4, t text) DISTRIBUTED BY (id);
set allow_system_table_mods=true;
delete from gp_distribution_policy where localoid='execinsert_test'::regclass;
reset allow_system_table_mods;
INSERT INTO execinsert_test values (1, 'foo');
begin;
INSERT INTO execinsert_test select * FROM execinsert_test;
rollback;
select * from execinsert_test;
 id |  t  
----+-----
  1 | foo
(1 row)

drop table execinsert_test;
