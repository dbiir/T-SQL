--
-- AGGREGATES
--
-- start_ignore
SET optimizer_trace_fallback to on;
-- end_ignore
SELECT avg(four) AS avg_1 FROM onek;
       avg_1        
--------------------
 1.5000000000000000
(1 row)

SELECT avg(a) AS avg_32 FROM aggtest WHERE a < 100;
       avg_32        
---------------------
 32.6666666666666667
(1 row)

-- In 7.1, avg(float4) is computed using float8 arithmetic.
-- Round the result to 3 digits to avoid platform-specific results.
SELECT avg(b)::numeric(10,3) AS avg_107_943 FROM aggtest;
 avg_107_943 
-------------
     107.943
(1 row)

SELECT avg(gpa) AS avg_3_4 FROM ONLY student;
INFO:  GPORCA failed to produce a plan, falling back to planner
DETAIL:  Feature not supported: ONLY in the FROM clause
 avg_3_4 
---------
     3.4
(1 row)

SELECT sum(four) AS sum_1500 FROM onek;
 sum_1500 
----------
     1500
(1 row)

SELECT sum(a) AS sum_198 FROM aggtest;
 sum_198 
---------
     198
(1 row)

SELECT sum(b) AS avg_431_773 FROM aggtest;
 avg_431_773 
-------------
     431.773
(1 row)

SELECT sum(gpa) AS avg_6_8 FROM ONLY student;
INFO:  GPORCA failed to produce a plan, falling back to planner
DETAIL:  Feature not supported: ONLY in the FROM clause
 avg_6_8 
---------
     6.8
(1 row)

SELECT max(four) AS max_3 FROM onek;
 max_3 
-------
     3
(1 row)

SELECT max(a) AS max_100 FROM aggtest;
 max_100 
---------
     100
(1 row)

SELECT max(aggtest.b) AS max_324_78 FROM aggtest;
 max_324_78 
------------
     324.78
(1 row)

SELECT max(student.gpa) AS max_3_7 FROM student;
INFO:  GPORCA failed to produce a plan, falling back to planner
DETAIL:  Feature not supported: Inherited tables
 max_3_7 
---------
     3.7
(1 row)

SELECT stddev_pop(b) FROM aggtest;
   stddev_pop    
-----------------
 131.10703231895
(1 row)

SELECT stddev_samp(b) FROM aggtest;
   stddev_samp    
------------------
 151.389360803998
(1 row)

SELECT var_pop(b) FROM aggtest;
     var_pop      
------------------
 17189.0539234823
(1 row)

SELECT var_samp(b) FROM aggtest;
     var_samp     
------------------
 22918.7385646431
(1 row)

SELECT stddev_pop(b::numeric) FROM aggtest;
    stddev_pop    
------------------
 131.107032862199
(1 row)

SELECT stddev_samp(b::numeric) FROM aggtest;
   stddev_samp    
------------------
 151.389361431288
(1 row)

SELECT var_pop(b::numeric) FROM aggtest;
      var_pop       
--------------------
 17189.054065929769
(1 row)

SELECT var_samp(b::numeric) FROM aggtest;
      var_samp      
--------------------
 22918.738754573025
(1 row)

-- population variance is defined for a single tuple, sample variance
-- is not
SELECT var_pop(1.0), var_samp(2.0);
 var_pop | var_samp 
---------+----------
       0 |         
(1 row)

SELECT stddev_pop(3.0::numeric), stddev_samp(4.0::numeric);
 stddev_pop | stddev_samp 
------------+-------------
          0 |            
(1 row)

-- verify correct results for null and NaN inputs
select sum(null::int4) from generate_series(1,3);
 sum 
-----
    
(1 row)

select sum(null::int8) from generate_series(1,3);
 sum 
-----
    
(1 row)

select sum(null::numeric) from generate_series(1,3);
 sum 
-----
    
(1 row)

select sum(null::float8) from generate_series(1,3);
 sum 
-----
    
(1 row)

select avg(null::int4) from generate_series(1,3);
 avg 
-----
    
(1 row)

select avg(null::int8) from generate_series(1,3);
 avg 
-----
    
(1 row)

select avg(null::numeric) from generate_series(1,3);
 avg 
-----
    
(1 row)

select avg(null::float8) from generate_series(1,3);
 avg 
-----
    
(1 row)

select sum('NaN'::numeric) from generate_series(1,3);
 sum 
-----
 NaN
(1 row)

select avg('NaN'::numeric) from generate_series(1,3);
 avg 
-----
 NaN
(1 row)

-- SQL2003 binary aggregates
SELECT regr_count(b, a) FROM aggtest;
 regr_count 
------------
          4
(1 row)

SELECT regr_sxx(b, a) FROM aggtest;
 regr_sxx 
----------
     5099
(1 row)

SELECT regr_syy(b, a) FROM aggtest;
     regr_syy     
------------------
 68756.2156939293
(1 row)

SELECT regr_sxy(b, a) FROM aggtest;
     regr_sxy     
------------------
 2614.51582155004
(1 row)

SELECT regr_avgx(b, a), regr_avgy(b, a) FROM aggtest;
 regr_avgx |    regr_avgy     
-----------+------------------
      49.5 | 107.943152273074
(1 row)

SELECT regr_r2(b, a) FROM aggtest;
      regr_r2       
--------------------
 0.0194977982031803
(1 row)

SELECT regr_slope(b, a), regr_intercept(b, a) FROM aggtest;
    regr_slope     |  regr_intercept  
-------------------+------------------
 0.512750700441271 | 82.5619926012309
(1 row)

SELECT covar_pop(b, a), covar_samp(b, a) FROM aggtest;
    covar_pop    |    covar_samp    
-----------------+------------------
 653.62895538751 | 871.505273850014
(1 row)

SELECT corr(b, a) FROM aggtest;
       corr        
-------------------
 0.139634516517873
(1 row)

SELECT count(four) AS cnt_1000 FROM onek;
 cnt_1000 
----------
     1000
(1 row)

SELECT count(DISTINCT four) AS cnt_4 FROM onek;
 cnt_4 
-------
     4
(1 row)

select ten, count(*), sum(four) from onek
group by ten order by ten;
 ten | count | sum 
-----+-------+-----
   0 |   100 | 100
   1 |   100 | 200
   2 |   100 | 100
   3 |   100 | 200
   4 |   100 | 100
   5 |   100 | 200
   6 |   100 | 100
   7 |   100 | 200
   8 |   100 | 100
   9 |   100 | 200
(10 rows)

select ten, count(four), sum(DISTINCT four) from onek
group by ten order by ten;
 ten | count | sum 
-----+-------+-----
   0 |   100 |   2
   1 |   100 |   4
   2 |   100 |   2
   3 |   100 |   4
   4 |   100 |   2
   5 |   100 |   4
   6 |   100 |   2
   7 |   100 |   4
   8 |   100 |   2
   9 |   100 |   4
(10 rows)

-- user-defined aggregates
SELECT newavg(four) AS avg_1 FROM onek;
       avg_1        
--------------------
 1.5000000000000000
(1 row)

SELECT newsum(four) AS sum_1500 FROM onek;
 sum_1500 
----------
     1500
(1 row)

SELECT newcnt(four) AS cnt_1000 FROM onek;
 cnt_1000 
----------
     1000
(1 row)

SELECT newcnt(*) AS cnt_1000 FROM onek;
 cnt_1000 
----------
     1000
(1 row)

SELECT oldcnt(*) AS cnt_1000 FROM onek;
 cnt_1000 
----------
     1000
(1 row)

SELECT sum2(q1,q2) FROM int8_tbl;
INFO:  GPORCA failed to produce a plan, falling back to planner
DETAIL:  GPDB Expression type: Query Parameter not supported in DXL
CONTEXT:  SQL function "sum3" during startup
       sum2        
-------------------
 18271560493827981
(1 row)

-- test for outer-level aggregates
-- this should work
select ten, sum(distinct four) from onek a
group by ten
having exists (select 1 from onek b where sum(distinct a.four) = b.four);
 ten | sum 
-----+-----
   2 |   2
   6 |   2
   0 |   2
   8 |   2
   4 |   2
(5 rows)

-- this should fail because subquery has an agg of its own in WHERE
select ten, sum(distinct four) from onek a
group by ten
having exists (select 1 from onek b
               where sum(distinct a.four + b.four) = b.four);
ERROR:  aggregate functions are not allowed in WHERE
LINE 4:                where sum(distinct a.four + b.four) = b.four)...
                             ^
-- Test handling of sublinks within outer-level aggregates.
-- Per bug report from Daniel Grace.
select
  (select max((select i.unique2 from tenk1 i where i.unique1 = o.unique1)))
from tenk1 o;
INFO:  GPORCA failed to produce a plan, falling back to planner
DETAIL:  Query-to-DXL Translation: No variable entry found due to incorrect normalization of query
 max  
------
 9999
(1 row)

-- Test handling of Params within aggregate arguments in hashed aggregation.
-- Per bug report from Jeevan Chalke.
explain (verbose, costs off)
select s1, s2, sm
from generate_series(1, 3) s1,
     lateral (select s2, sum(s1 + s2) sm
              from generate_series(1, 3) s2 group by s2) ss
order by 1, 2;
INFO:  GPORCA failed to produce a plan, falling back to planner
DETAIL:  Feature not supported: LATERAL
                               QUERY PLAN                               
------------------------------------------------------------------------
 Sort
   Output: s1.s1, s2.s2, (sum((s1.s1 + s2.s2)))
   Sort Key: s1.s1, s2.s2
   ->  Nested Loop
         Output: s1.s1, s2.s2, (sum((s1.s1 + s2.s2)))
         ->  Function Scan on pg_catalog.generate_series s1
               Output: s1.s1
               Function Call: generate_series(1, 3)
         ->  Materialize
               Output: s2.s2, (sum((s1.s1 + s2.s2)))
               ->  HashAggregate
                     Output: s2.s2, sum((s1.s1 + s2.s2))
                     Group Key: s2.s2
                     ->  Function Scan on pg_catalog.generate_series s2
                           Output: s2.s2
                           Function Call: generate_series(1, 3)
 Optimizer: Postgres query optimizer
(17 rows)

select s1, s2, sm
from generate_series(1, 3) s1,
     lateral (select s2, sum(s1 + s2) sm
              from generate_series(1, 3) s2 group by s2) ss
order by 1, 2;
INFO:  GPORCA failed to produce a plan, falling back to planner
DETAIL:  Feature not supported: LATERAL
 s1 | s2 | sm 
----+----+----
  1 |  1 |  2
  1 |  2 |  3
  1 |  3 |  4
  2 |  1 |  3
  2 |  2 |  4
  2 |  3 |  5
  3 |  1 |  4
  3 |  2 |  5
  3 |  3 |  6
(9 rows)

explain (verbose, costs off)
select array(select sum(x+y) s
            from generate_series(1,3) y group by y order by s)
  from generate_series(1,3) x;
INFO:  GPORCA failed to produce a plan, falling back to planner
DETAIL:  Feature not supported: Non-Scalar Subquery
                            QUERY PLAN                             
-------------------------------------------------------------------
 Function Scan on pg_catalog.generate_series x
   Output: (SubPlan 1)
   Function Call: generate_series(1, 3)
   SubPlan 1
     ->  Sort
           Output: (sum((x.x + y.y))), y.y
           Sort Key: (sum((x.x + y.y)))
           ->  HashAggregate
                 Output: sum((x.x + y.y)), y.y
                 Group Key: y.y
                 ->  Function Scan on pg_catalog.generate_series y
                       Output: y.y
                       Function Call: generate_series(1, 3)
 Optimizer: Postgres query optimizer
(14 rows)

select array(select sum(x+y) s
            from generate_series(1,3) y group by y order by s)
  from generate_series(1,3) x;
INFO:  GPORCA failed to produce a plan, falling back to planner
DETAIL:  Feature not supported: Non-Scalar Subquery
  array  
---------
 {2,3,4}
 {3,4,5}
 {4,5,6}
(3 rows)

--
-- test for bitwise integer aggregates
--
CREATE TEMPORARY TABLE bitwise_test(
  i2 INT2,
  i4 INT4,
  i8 INT8,
  i INTEGER,
  x INT2,
  y BIT(4)
);
NOTICE:  Table doesn't have 'DISTRIBUTED BY' clause -- Using column named 'i2' as the Greenplum Database data distribution key for this table.
HINT:  The 'DISTRIBUTED BY' clause determines the distribution of data. Make sure column(s) chosen are the optimal data distribution key to minimize skew.
-- empty case
SELECT
  BIT_AND(i2) AS "?",
  BIT_OR(i4)  AS "?"
FROM bitwise_test;
 ? | ? 
---+---
   |  
(1 row)

COPY bitwise_test FROM STDIN NULL 'null';
SELECT
  BIT_AND(i2) AS "1",
  BIT_AND(i4) AS "1",
  BIT_AND(i8) AS "1",
  BIT_AND(i)  AS "?",
  BIT_AND(x)  AS "0",
  BIT_AND(y)  AS "0100",
  BIT_OR(i2)  AS "7",
  BIT_OR(i4)  AS "7",
  BIT_OR(i8)  AS "7",
  BIT_OR(i)   AS "?",
  BIT_OR(x)   AS "7",
  BIT_OR(y)   AS "1101"
FROM bitwise_test;
 1 | 1 | 1 | ? | 0 | 0100 | 7 | 7 | 7 | ? | 7 | 1101 
---+---+---+---+---+------+---+---+---+---+---+------
 1 | 1 | 1 | 1 | 0 | 0100 | 7 | 7 | 7 | 3 | 7 | 1101
(1 row)

--
-- test boolean aggregates
--
-- first test all possible transition and final states
SELECT
  -- boolean and transitions
  -- null because strict
  booland_statefunc(NULL, NULL)  IS NULL AS "t",
  booland_statefunc(TRUE, NULL)  IS NULL AS "t",
  booland_statefunc(FALSE, NULL) IS NULL AS "t",
  booland_statefunc(NULL, TRUE)  IS NULL AS "t",
  booland_statefunc(NULL, FALSE) IS NULL AS "t",
  -- and actual computations
  booland_statefunc(TRUE, TRUE) AS "t",
  NOT booland_statefunc(TRUE, FALSE) AS "t",
  NOT booland_statefunc(FALSE, TRUE) AS "t",
  NOT booland_statefunc(FALSE, FALSE) AS "t";
 t | t | t | t | t | t | t | t | t 
---+---+---+---+---+---+---+---+---
 t | t | t | t | t | t | t | t | t
(1 row)

SELECT
  -- boolean or transitions
  -- null because strict
  boolor_statefunc(NULL, NULL)  IS NULL AS "t",
  boolor_statefunc(TRUE, NULL)  IS NULL AS "t",
  boolor_statefunc(FALSE, NULL) IS NULL AS "t",
  boolor_statefunc(NULL, TRUE)  IS NULL AS "t",
  boolor_statefunc(NULL, FALSE) IS NULL AS "t",
  -- actual computations
  boolor_statefunc(TRUE, TRUE) AS "t",
  boolor_statefunc(TRUE, FALSE) AS "t",
  boolor_statefunc(FALSE, TRUE) AS "t",
  NOT boolor_statefunc(FALSE, FALSE) AS "t";
 t | t | t | t | t | t | t | t | t 
---+---+---+---+---+---+---+---+---
 t | t | t | t | t | t | t | t | t
(1 row)

CREATE TEMPORARY TABLE bool_test(
  b1 BOOL,
  b2 BOOL,
  b3 BOOL,
  b4 BOOL);
NOTICE:  Table doesn't have 'DISTRIBUTED BY' clause -- Using column named 'b1' as the Greenplum Database data distribution key for this table.
HINT:  The 'DISTRIBUTED BY' clause determines the distribution of data. Make sure column(s) chosen are the optimal data distribution key to minimize skew.
-- empty case
SELECT
  BOOL_AND(b1)   AS "n",
  BOOL_OR(b3)    AS "n"
FROM bool_test;
 n | n 
---+---
   | 
(1 row)

COPY bool_test FROM STDIN NULL 'null';
SELECT
  BOOL_AND(b1)     AS "f",
  BOOL_AND(b2)     AS "t",
  BOOL_AND(b3)     AS "f",
  BOOL_AND(b4)     AS "n",
  BOOL_AND(NOT b2) AS "f",
  BOOL_AND(NOT b3) AS "t"
FROM bool_test;
 f | t | f | n | f | t 
---+---+---+---+---+---
 f | t | f |   | f | t
(1 row)

SELECT
  EVERY(b1)     AS "f",
  EVERY(b2)     AS "t",
  EVERY(b3)     AS "f",
  EVERY(b4)     AS "n",
  EVERY(NOT b2) AS "f",
  EVERY(NOT b3) AS "t"
FROM bool_test;
 f | t | f | n | f | t 
---+---+---+---+---+---
 f | t | f |   | f | t
(1 row)

SELECT
  BOOL_OR(b1)      AS "t",
  BOOL_OR(b2)      AS "t",
  BOOL_OR(b3)      AS "f",
  BOOL_OR(b4)      AS "n",
  BOOL_OR(NOT b2)  AS "f",
  BOOL_OR(NOT b3)  AS "t"
FROM bool_test;
 t | t | f | n | f | t 
---+---+---+---+---+---
 t | t | f |   | f | t
(1 row)

--
-- Test cases that should be optimized into indexscans instead of
-- the generic aggregate implementation.
--
-- Basic cases
explain (costs off)
  select min(unique1) from tenk1;
                   QUERY PLAN                   
------------------------------------------------
 Aggregate
   ->  Gather Motion 3:1  (slice1; segments: 3)
         ->  Aggregate
               ->  Seq Scan on tenk1
 Optimizer: Pivotal Optimizer (GPORCA) version 2.55.21
(5 rows)

select min(unique1) from tenk1;
 min 
-----
   0
(1 row)

explain (costs off)
  select max(unique1) from tenk1;
                   QUERY PLAN                   
------------------------------------------------
 Aggregate
   ->  Gather Motion 3:1  (slice1; segments: 3)
         ->  Aggregate
               ->  Seq Scan on tenk1
 Optimizer: Pivotal Optimizer (GPORCA) version 2.55.21
(5 rows)

select max(unique1) from tenk1;
 max  
------
 9999
(1 row)

explain (costs off)
  select max(unique1) from tenk1 where unique1 < 42;
                        QUERY PLAN                         
-----------------------------------------------------------
 Aggregate
   ->  Gather Motion 3:1  (slice1; segments: 3)
         ->  Aggregate
               ->  Index Scan using tenk1_unique1 on tenk1
                     Index Cond: (unique1 < 42)
 Optimizer: Pivotal Optimizer (GPORCA) version 2.55.21
(6 rows)

select max(unique1) from tenk1 where unique1 < 42;
 max 
-----
  41
(1 row)

explain (costs off)
  select max(unique1) from tenk1 where unique1 > 42;
                   QUERY PLAN                   
------------------------------------------------
 Aggregate
   ->  Gather Motion 3:1  (slice1; segments: 3)
         ->  Aggregate
               ->  Index Scan using tenk1_unique1 on tenk1
                     Index Cond: (unique1 > 42)
 Optimizer: Pivotal Optimizer (GPORCA) version 2.55.21
(6 rows)

select max(unique1) from tenk1 where unique1 > 42;
 max  
------
 9999
(1 row)

set enable_seqscan=off;
set enable_bitmapscan=off;
explain (costs off)
  select max(unique1) from tenk1 where unique1 > 42000;
                        QUERY PLAN                         
-----------------------------------------------------------
 Aggregate
   ->  Gather Motion 3:1  (slice1; segments: 3)
         ->  Aggregate
               ->  Index Scan using tenk1_unique1 on tenk1
                     Index Cond: (unique1 > 42000)
 Optimizer: Pivotal Optimizer (GPORCA) version 2.55.21
(6 rows)

select max(unique1) from tenk1 where unique1 > 42000;
 max 
-----
    
(1 row)

reset enable_seqscan;
-- multi-column index (uses tenk1_thous_tenthous)
explain (costs off)
  select max(tenthous) from tenk1 where thousand = 33;
                            QUERY PLAN                            
------------------------------------------------------------------
 Aggregate
   ->  Gather Motion 3:1  (slice1; segments: 3)
         ->  Aggregate
               ->  Index Scan using tenk1_thous_tenthous on tenk1
                     Index Cond: (thousand = 33)
 Optimizer: Pivotal Optimizer (GPORCA) version 2.55.21
(6 rows)

select max(tenthous) from tenk1 where thousand = 33;
 max  
------
 9033
(1 row)

explain (costs off)
  select min(tenthous) from tenk1 where thousand = 33;
                            QUERY PLAN                            
------------------------------------------------------------------
 Aggregate
   ->  Gather Motion 3:1  (slice1; segments: 3)
         ->  Aggregate
               ->  Index Scan using tenk1_thous_tenthous on tenk1
                     Index Cond: (thousand = 33)
 Optimizer: Pivotal Optimizer (GPORCA) version 2.55.21
(6 rows)

select min(tenthous) from tenk1 where thousand = 33;
 min 
-----
  33
(1 row)

-- check parameter propagation into an indexscan subquery
-- In GPDB, this cannot use the MIN/MAX optimization, because the subplan
-- parameter cannot be pushed through a Motion node.
explain (costs off)
  select f1, (select min(unique1) from tenk1 where unique1 > f1) AS gt
    from int4_tbl;
                             QUERY PLAN                             
--------------------------------------------------------------------
 Result
   ->  Gather Motion 3:1  (slice1; segments: 3)
         ->  Seq Scan on int4_tbl
   SubPlan 1  (slice0)
     ->  Aggregate
           ->  Result
                 Filter: (tenk1.unique1 > int4_tbl.f1)
                 ->  Materialize
                       ->  Gather Motion 3:1  (slice2; segments: 3)
                             ->  Seq Scan on tenk1
 Optimizer: Pivotal Optimizer (GPORCA) version 2.55.21
(11 rows)

select f1, (select min(unique1) from tenk1 where unique1 > f1) AS gt
  from int4_tbl;
     f1      | gt 
-------------+----
      123456 |   
 -2147483647 |  0
           0 |  1
     -123456 |  0
  2147483647 |   
(5 rows)

-- check some cases that were handled incorrectly in 8.3.0
explain (costs off)
  select distinct max(unique2) from tenk1;
                   QUERY PLAN                   
------------------------------------------------
 Aggregate
   ->  Gather Motion 3:1  (slice1; segments: 3)
         ->  Aggregate
               ->  Seq Scan on tenk1
 Optimizer: Pivotal Optimizer (GPORCA) version 2.55.21
(5 rows)

select distinct max(unique2) from tenk1;
 max  
------
 9999
(1 row)

explain (costs off)
  select max(unique2) from tenk1 order by 1;
                      QUERY PLAN                      
------------------------------------------------------
 Sort
   Sort Key: (max((max(unique2))))
   ->  Aggregate
         ->  Gather Motion 3:1  (slice1; segments: 3)
               ->  Aggregate
                     ->  Seq Scan on tenk1
 Optimizer: Pivotal Optimizer (GPORCA) version 2.55.21
(7 rows)

select max(unique2) from tenk1 order by 1;
 max  
------
 9999
(1 row)

explain (costs off)
  select max(unique2) from tenk1 order by max(unique2);
                      QUERY PLAN                      
------------------------------------------------------
 Sort
   Sort Key: (max((max(unique2))))
   ->  Aggregate
         ->  Gather Motion 3:1  (slice1; segments: 3)
               ->  Aggregate
                     ->  Seq Scan on tenk1
 Optimizer: Pivotal Optimizer (GPORCA) version 2.55.21
(7 rows)

select max(unique2) from tenk1 order by max(unique2);
 max  
------
 9999
(1 row)

explain (costs off)
  select max(unique2) from tenk1 order by max(unique2)+1;
                            QUERY PLAN                            
------------------------------------------------------------------
 Result
   ->  Sort
         Sort Key: (((max((max(unique2)))) + 1))
         ->  Result
               ->  Aggregate
                     ->  Gather Motion 3:1  (slice1; segments: 3)
                           ->  Aggregate
                                 ->  Seq Scan on tenk1
 Optimizer: Pivotal Optimizer (GPORCA) version 2.55.21
(9 rows)

select max(unique2) from tenk1 order by max(unique2)+1;
 max  
------
 9999
(1 row)

explain (costs off)
  select max(unique2), generate_series(1,3) as g from tenk1 order by g desc;
                         QUERY PLAN                         
------------------------------------------------------------
 Sort
   Sort Key: (generate_series(1, 3))
   ->  Result
         ->  Aggregate
               ->  Gather Motion 3:1  (slice1; segments: 3)
                     ->  Aggregate
                           ->  Seq Scan on tenk1
 Optimizer: Pivotal Optimizer (GPORCA) version 2.55.21
(8 rows)

select max(unique2), generate_series(1,3) as g from tenk1 order by g desc;
 max  | g 
------+---
 9999 | 3
 9999 | 2
 9999 | 1
(3 rows)

-- try it on an inheritance tree
create table minmaxtest(f1 int);
NOTICE:  Table doesn't have 'DISTRIBUTED BY' clause -- Using column named 'f1' as the Greenplum Database data distribution key for this table.
HINT:  The 'DISTRIBUTED BY' clause determines the distribution of data. Make sure column(s) chosen are the optimal data distribution key to minimize skew.
create table minmaxtest1() inherits (minmaxtest);
NOTICE:  table has parent, setting distribution columns to match parent table
create table minmaxtest2() inherits (minmaxtest);
NOTICE:  table has parent, setting distribution columns to match parent table
create table minmaxtest3() inherits (minmaxtest);
NOTICE:  table has parent, setting distribution columns to match parent table
create index minmaxtesti on minmaxtest(f1);
create index minmaxtest1i on minmaxtest1(f1);
create index minmaxtest2i on minmaxtest2(f1 desc);
create index minmaxtest3i on minmaxtest3(f1) where f1 is not null;
insert into minmaxtest values(11), (12);
INFO:  GPORCA failed to produce a plan, falling back to planner
DETAIL:  Feature not supported: Inherited tables
insert into minmaxtest1 values(13), (14);
insert into minmaxtest2 values(15), (16);
insert into minmaxtest3 values(17), (18);
set enable_seqscan=off;
explain (costs off)
  select min(f1), max(f1) from minmaxtest;
INFO:  GPORCA failed to produce a plan, falling back to planner
DETAIL:  Feature not supported: Inherited tables
                                             QUERY PLAN                                             
----------------------------------------------------------------------------------------------------
 Result
   InitPlan 1 (returns $0)  (slice3)
     ->  Limit
           ->  Gather Motion 3:1  (slice1; segments: 3)
                 Merge Key: minmaxtest.f1
                 ->  Merge Append
                       Sort Key: minmaxtest.f1
                       ->  Index Only Scan using minmaxtesti on minmaxtest
                             Index Cond: (f1 IS NOT NULL)
                       ->  Index Only Scan using minmaxtest1i on minmaxtest1
                             Index Cond: (f1 IS NOT NULL)
                       ->  Index Only Scan Backward using minmaxtest2i on minmaxtest2
                             Index Cond: (f1 IS NOT NULL)
                       ->  Index Only Scan using minmaxtest3i on minmaxtest3
                             Index Cond: (f1 IS NOT NULL)
   InitPlan 2 (returns $1)  (slice4)
     ->  Limit
           ->  Gather Motion 3:1  (slice2; segments: 3)
                 Merge Key: minmaxtest_1.f1
                 ->  Merge Append
                       Sort Key: minmaxtest_1.f1
                       ->  Index Only Scan Backward using minmaxtesti on minmaxtest minmaxtest_1
                             Index Cond: (f1 IS NOT NULL)
                       ->  Index Only Scan Backward using minmaxtest1i on minmaxtest1 minmaxtest1_1
                             Index Cond: (f1 IS NOT NULL)
                       ->  Index Only Scan using minmaxtest2i on minmaxtest2 minmaxtest2_1
                             Index Cond: (f1 IS NOT NULL)
                       ->  Index Only Scan Backward using minmaxtest3i on minmaxtest3 minmaxtest3_1
                             Index Cond: (f1 IS NOT NULL)
 Optimizer: Postgres query optimizer
(30 rows)

select min(f1), max(f1) from minmaxtest;
INFO:  GPORCA failed to produce a plan, falling back to planner
DETAIL:  Feature not supported: Inherited tables
 min | max 
-----+-----
  11 |  18
(1 row)

reset enable_seqscan;
-- DISTINCT doesn't do anything useful here, but it shouldn't fail
explain (costs off)
  select distinct min(f1), max(f1) from minmaxtest;
INFO:  GPORCA failed to produce a plan, falling back to planner
DETAIL:  Feature not supported: Inherited tables
                            QUERY PLAN                             
-------------------------------------------------------------------
 HashAggregate
   Group Key: min((min(minmaxtest.f1))), max((max(minmaxtest.f1)))
   ->  Aggregate
         ->  Gather Motion 3:1  (slice1; segments: 3)
               ->  Aggregate
                     ->  Append
                           ->  Seq Scan on minmaxtest
                           ->  Seq Scan on minmaxtest1
                           ->  Seq Scan on minmaxtest2
                           ->  Seq Scan on minmaxtest3
 Optimizer: Postgres query optimizer
(11 rows)

select distinct min(f1), max(f1) from minmaxtest;
INFO:  GPORCA failed to produce a plan, falling back to planner
DETAIL:  Feature not supported: Inherited tables
 min | max 
-----+-----
  11 |  18
(1 row)

drop table minmaxtest cascade;
NOTICE:  drop cascades to 3 other objects
DETAIL:  drop cascades to table minmaxtest1
drop cascades to table minmaxtest2
drop cascades to table minmaxtest3
-- check for correct detection of nested-aggregate errors
select max(min(unique1)) from tenk1;
ERROR:  aggregate function calls cannot be nested
LINE 1: select max(min(unique1)) from tenk1;
                   ^
select (select max(min(unique1)) from int8_tbl) from tenk1;
ERROR:  aggregate function calls cannot be nested
LINE 1: select (select max(min(unique1)) from int8_tbl) from tenk1;
                           ^
--
-- Test combinations of DISTINCT and/or ORDER BY
--
select array_agg(a order by b)
  from (values (1,4),(2,3),(3,1),(4,2)) v(a,b);
INFO:  GPORCA failed to produce a plan, falling back to planner
DETAIL:  GPDB Expression type: Ordered aggregates not supported in DXL
 array_agg 
-----------
 {3,4,2,1}
(1 row)

select array_agg(a order by a)
  from (values (1,4),(2,3),(3,1),(4,2)) v(a,b);
INFO:  GPORCA failed to produce a plan, falling back to planner
DETAIL:  GPDB Expression type: Ordered aggregates not supported in DXL
 array_agg 
-----------
 {1,2,3,4}
(1 row)

select array_agg(a order by a desc)
  from (values (1,4),(2,3),(3,1),(4,2)) v(a,b);
INFO:  GPORCA failed to produce a plan, falling back to planner
DETAIL:  GPDB Expression type: Ordered aggregates not supported in DXL
 array_agg 
-----------
 {4,3,2,1}
(1 row)

select array_agg(b order by a desc)
  from (values (1,4),(2,3),(3,1),(4,2)) v(a,b);
INFO:  GPORCA failed to produce a plan, falling back to planner
DETAIL:  GPDB Expression type: Ordered aggregates not supported in DXL
 array_agg 
-----------
 {2,1,3,4}
(1 row)

select array_agg(distinct a)
  from (values (1),(2),(1),(3),(null),(2)) v(a);
  array_agg   
--------------
 {1,2,3,NULL}
(1 row)

select array_agg(distinct a order by a)
  from (values (1),(2),(1),(3),(null),(2)) v(a);
INFO:  GPORCA failed to produce a plan, falling back to planner
DETAIL:  GPDB Expression type: Ordered aggregates not supported in DXL
  array_agg   
--------------
 {1,2,3,NULL}
(1 row)

select array_agg(distinct a order by a desc)
  from (values (1),(2),(1),(3),(null),(2)) v(a);
INFO:  GPORCA failed to produce a plan, falling back to planner
DETAIL:  GPDB Expression type: Ordered aggregates not supported in DXL
  array_agg   
--------------
 {NULL,3,2,1}
(1 row)

select array_agg(distinct a order by a desc nulls last)
  from (values (1),(2),(1),(3),(null),(2)) v(a);
INFO:  GPORCA failed to produce a plan, falling back to planner
DETAIL:  GPDB Expression type: Ordered aggregates not supported in DXL
  array_agg   
--------------
 {3,2,1,NULL}
(1 row)

-- multi-arg aggs, strict/nonstrict, distinct/order by
select aggfstr(a,b,c)
  from (values (1,3,'foo'),(0,null,null),(2,2,'bar'),(3,1,'baz')) v(a,b,c);
INFO:  GPORCA failed to produce a plan, falling back to planner
DETAIL:  Feature not supported: ROW EXPRESSION
CONTEXT:  SQL function "aggf_trans" during startup
                aggfstr                
---------------------------------------
 {"(1,3,foo)","(2,2,bar)","(3,1,baz)"}
(1 row)

select aggfns(a,b,c)
  from (values (1,3,'foo'),(0,null,null),(2,2,'bar'),(3,1,'baz')) v(a,b,c);
INFO:  GPORCA failed to produce a plan, falling back to planner
DETAIL:  Feature not supported: ROW EXPRESSION
CONTEXT:  SQL function "aggfns_trans" during startup
                    aggfns                     
-----------------------------------------------
 {"(1,3,foo)","(0,,)","(2,2,bar)","(3,1,baz)"}
(1 row)

select aggfstr(distinct a,b,c)
  from (values (1,3,'foo'),(0,null,null),(2,2,'bar'),(3,1,'baz')) v(a,b,c),
       generate_series(1,3) i;
INFO:  GPORCA failed to produce a plan, falling back to planner
DETAIL:  Feature not supported: ROW EXPRESSION
CONTEXT:  SQL function "aggf_trans" during startup
                aggfstr                
---------------------------------------
 {"(1,3,foo)","(2,2,bar)","(3,1,baz)"}
(1 row)

select aggfns(distinct a,b,c)
  from (values (1,3,'foo'),(0,null,null),(2,2,'bar'),(3,1,'baz')) v(a,b,c),
       generate_series(1,3) i;
INFO:  GPORCA failed to produce a plan, falling back to planner
DETAIL:  Feature not supported: ROW EXPRESSION
CONTEXT:  SQL function "aggfns_trans" during startup
                    aggfns                     
-----------------------------------------------
 {"(0,,)","(1,3,foo)","(2,2,bar)","(3,1,baz)"}
(1 row)

select aggfstr(distinct a,b,c order by b)
  from (values (1,3,'foo'),(0,null,null),(2,2,'bar'),(3,1,'baz')) v(a,b,c),
       generate_series(1,3) i;
INFO:  GPORCA failed to produce a plan, falling back to planner
DETAIL:  GPDB Expression type: Ordered aggregates not supported in DXL
INFO:  GPORCA failed to produce a plan, falling back to planner
DETAIL:  Feature not supported: ROW EXPRESSION
CONTEXT:  SQL function "aggf_trans" during startup
                aggfstr                
---------------------------------------
 {"(3,1,baz)","(2,2,bar)","(1,3,foo)"}
(1 row)

select aggfns(distinct a,b,c order by b)
  from (values (1,3,'foo'),(0,null,null),(2,2,'bar'),(3,1,'baz')) v(a,b,c),
       generate_series(1,3) i;
INFO:  GPORCA failed to produce a plan, falling back to planner
DETAIL:  GPDB Expression type: Ordered aggregates not supported in DXL
INFO:  GPORCA failed to produce a plan, falling back to planner
DETAIL:  Feature not supported: ROW EXPRESSION
CONTEXT:  SQL function "aggfns_trans" during startup
                    aggfns                     
-----------------------------------------------
 {"(3,1,baz)","(2,2,bar)","(1,3,foo)","(0,,)"}
(1 row)

-- test specific code paths
select aggfns(distinct a,a,c order by c using ~<~,a)
  from (values (1,3,'foo'),(0,null,null),(2,2,'bar'),(3,1,'baz')) v(a,b,c),
       generate_series(1,2) i;
INFO:  GPORCA failed to produce a plan, falling back to planner
DETAIL:  GPDB Expression type: Ordered aggregates not supported in DXL
INFO:  GPORCA failed to produce a plan, falling back to planner
DETAIL:  Feature not supported: ROW EXPRESSION
CONTEXT:  SQL function "aggfns_trans" during startup
                     aggfns                     
------------------------------------------------
 {"(2,2,bar)","(3,3,baz)","(1,1,foo)","(0,0,)"}
(1 row)

select aggfns(distinct a,a,c order by c using ~<~)
  from (values (1,3,'foo'),(0,null,null),(2,2,'bar'),(3,1,'baz')) v(a,b,c),
       generate_series(1,2) i;
INFO:  GPORCA failed to produce a plan, falling back to planner
DETAIL:  GPDB Expression type: Ordered aggregates not supported in DXL
INFO:  GPORCA failed to produce a plan, falling back to planner
DETAIL:  Feature not supported: ROW EXPRESSION
CONTEXT:  SQL function "aggfns_trans" during startup
                     aggfns                     
------------------------------------------------
 {"(2,2,bar)","(3,3,baz)","(1,1,foo)","(0,0,)"}
(1 row)

select aggfns(distinct a,a,c order by a)
  from (values (1,3,'foo'),(0,null,null),(2,2,'bar'),(3,1,'baz')) v(a,b,c),
       generate_series(1,2) i;
INFO:  GPORCA failed to produce a plan, falling back to planner
DETAIL:  GPDB Expression type: Ordered aggregates not supported in DXL
INFO:  GPORCA failed to produce a plan, falling back to planner
DETAIL:  Feature not supported: ROW EXPRESSION
CONTEXT:  SQL function "aggfns_trans" during startup
                     aggfns                     
------------------------------------------------
 {"(0,0,)","(1,1,foo)","(2,2,bar)","(3,3,baz)"}
(1 row)

select aggfns(distinct a,b,c order by a,c using ~<~,b)
  from (values (1,3,'foo'),(0,null,null),(2,2,'bar'),(3,1,'baz')) v(a,b,c),
       generate_series(1,2) i;
INFO:  GPORCA failed to produce a plan, falling back to planner
DETAIL:  GPDB Expression type: Ordered aggregates not supported in DXL
INFO:  GPORCA failed to produce a plan, falling back to planner
DETAIL:  Feature not supported: ROW EXPRESSION
CONTEXT:  SQL function "aggfns_trans" during startup
                    aggfns                     
-----------------------------------------------
 {"(0,,)","(1,3,foo)","(2,2,bar)","(3,1,baz)"}
(1 row)

-- check node I/O via view creation and usage, also deparsing logic
create view agg_view1 as
  select aggfns(a,b,c)
    from (values (1,3,'foo'),(0,null,null),(2,2,'bar'),(3,1,'baz')) v(a,b,c);
select * from agg_view1;
                    aggfns                     
-----------------------------------------------
 {"(1,3,foo)","(0,,)","(2,2,bar)","(3,1,baz)"}
(1 row)

select pg_get_viewdef('agg_view1'::regclass);
                                                   pg_get_viewdef                                                    
---------------------------------------------------------------------------------------------------------------------
  SELECT aggfns(v.a, v.b, v.c) AS aggfns                                                                            +
    FROM ( VALUES (1,3,'foo'::text), (0,NULL::integer,NULL::text), (2,2,'bar'::text), (3,1,'baz'::text)) v(a, b, c);
(1 row)

create or replace view agg_view1 as
  select aggfns(distinct a,b,c)
    from (values (1,3,'foo'),(0,null,null),(2,2,'bar'),(3,1,'baz')) v(a,b,c),
         generate_series(1,3) i;
select * from agg_view1;
                    aggfns                     
-----------------------------------------------
 {"(0,,)","(1,3,foo)","(2,2,bar)","(3,1,baz)"}
(1 row)

select pg_get_viewdef('agg_view1'::regclass);
                                                   pg_get_viewdef                                                    
---------------------------------------------------------------------------------------------------------------------
  SELECT aggfns(DISTINCT v.a, v.b, v.c) AS aggfns                                                                   +
    FROM ( VALUES (1,3,'foo'::text), (0,NULL::integer,NULL::text), (2,2,'bar'::text), (3,1,'baz'::text)) v(a, b, c),+
     generate_series(1, 3) i(i);
(1 row)

create or replace view agg_view1 as
  select aggfns(distinct a,b,c order by b)
    from (values (1,3,'foo'),(0,null,null),(2,2,'bar'),(3,1,'baz')) v(a,b,c),
         generate_series(1,3) i;
select * from agg_view1;
                    aggfns                     
-----------------------------------------------
 {"(3,1,baz)","(2,2,bar)","(1,3,foo)","(0,,)"}
(1 row)

select pg_get_viewdef('agg_view1'::regclass);
                                                   pg_get_viewdef                                                    
---------------------------------------------------------------------------------------------------------------------
  SELECT aggfns(DISTINCT v.a, v.b, v.c ORDER BY v.b) AS aggfns                                                      +
    FROM ( VALUES (1,3,'foo'::text), (0,NULL::integer,NULL::text), (2,2,'bar'::text), (3,1,'baz'::text)) v(a, b, c),+
     generate_series(1, 3) i(i);
(1 row)

create or replace view agg_view1 as
  select aggfns(a,b,c order by b+1)
    from (values (1,3,'foo'),(0,null,null),(2,2,'bar'),(3,1,'baz')) v(a,b,c);
select * from agg_view1;
                    aggfns                     
-----------------------------------------------
 {"(3,1,baz)","(2,2,bar)","(1,3,foo)","(0,,)"}
(1 row)

select pg_get_viewdef('agg_view1'::regclass);
                                                   pg_get_viewdef                                                    
---------------------------------------------------------------------------------------------------------------------
  SELECT aggfns(v.a, v.b, v.c ORDER BY (v.b + 1)) AS aggfns                                                         +
    FROM ( VALUES (1,3,'foo'::text), (0,NULL::integer,NULL::text), (2,2,'bar'::text), (3,1,'baz'::text)) v(a, b, c);
(1 row)

create or replace view agg_view1 as
  select aggfns(a,a,c order by b)
    from (values (1,3,'foo'),(0,null,null),(2,2,'bar'),(3,1,'baz')) v(a,b,c);
select * from agg_view1;
                     aggfns                     
------------------------------------------------
 {"(3,3,baz)","(2,2,bar)","(1,1,foo)","(0,0,)"}
(1 row)

select pg_get_viewdef('agg_view1'::regclass);
                                                   pg_get_viewdef                                                    
---------------------------------------------------------------------------------------------------------------------
  SELECT aggfns(v.a, v.a, v.c ORDER BY v.b) AS aggfns                                                               +
    FROM ( VALUES (1,3,'foo'::text), (0,NULL::integer,NULL::text), (2,2,'bar'::text), (3,1,'baz'::text)) v(a, b, c);
(1 row)

create or replace view agg_view1 as
  select aggfns(a,b,c order by c using ~<~)
    from (values (1,3,'foo'),(0,null,null),(2,2,'bar'),(3,1,'baz')) v(a,b,c);
select * from agg_view1;
                    aggfns                     
-----------------------------------------------
 {"(2,2,bar)","(3,1,baz)","(1,3,foo)","(0,,)"}
(1 row)

select pg_get_viewdef('agg_view1'::regclass);
                                                   pg_get_viewdef                                                    
---------------------------------------------------------------------------------------------------------------------
  SELECT aggfns(v.a, v.b, v.c ORDER BY v.c USING ~<~ NULLS LAST) AS aggfns                                          +
    FROM ( VALUES (1,3,'foo'::text), (0,NULL::integer,NULL::text), (2,2,'bar'::text), (3,1,'baz'::text)) v(a, b, c);
(1 row)

create or replace view agg_view1 as
  select aggfns(distinct a,b,c order by a,c using ~<~,b)
    from (values (1,3,'foo'),(0,null,null),(2,2,'bar'),(3,1,'baz')) v(a,b,c),
         generate_series(1,2) i;
select * from agg_view1;
                    aggfns                     
-----------------------------------------------
 {"(0,,)","(1,3,foo)","(2,2,bar)","(3,1,baz)"}
(1 row)

select pg_get_viewdef('agg_view1'::regclass);
                                                   pg_get_viewdef                                                    
---------------------------------------------------------------------------------------------------------------------
  SELECT aggfns(DISTINCT v.a, v.b, v.c ORDER BY v.a, v.c USING ~<~ NULLS LAST, v.b) AS aggfns                       +
    FROM ( VALUES (1,3,'foo'::text), (0,NULL::integer,NULL::text), (2,2,'bar'::text), (3,1,'baz'::text)) v(a, b, c),+
     generate_series(1, 2) i(i);
(1 row)

drop view agg_view1;
-- incorrect DISTINCT usage errors
select aggfns(distinct a,b,c order by i)
  from (values (1,1,'foo')) v(a,b,c), generate_series(1,2) i;
ERROR:  in an aggregate with DISTINCT, ORDER BY expressions must appear in argument list
LINE 1: select aggfns(distinct a,b,c order by i)
                                              ^
select aggfns(distinct a,b,c order by a,b+1)
  from (values (1,1,'foo')) v(a,b,c), generate_series(1,2) i;
ERROR:  in an aggregate with DISTINCT, ORDER BY expressions must appear in argument list
LINE 1: select aggfns(distinct a,b,c order by a,b+1)
                                                ^
select aggfns(distinct a,b,c order by a,b,i,c)
  from (values (1,1,'foo')) v(a,b,c), generate_series(1,2) i;
ERROR:  in an aggregate with DISTINCT, ORDER BY expressions must appear in argument list
LINE 1: select aggfns(distinct a,b,c order by a,b,i,c)
                                                  ^
select aggfns(distinct a,a,c order by a,b)
  from (values (1,1,'foo')) v(a,b,c), generate_series(1,2) i;
ERROR:  in an aggregate with DISTINCT, ORDER BY expressions must appear in argument list
LINE 1: select aggfns(distinct a,a,c order by a,b)
                                                ^
-- string_agg tests
select string_agg(a,',') from (values('aaaa'),('bbbb'),('cccc')) g(a);
   string_agg   
----------------
 aaaa,bbbb,cccc
(1 row)

select string_agg(a,',') from (values('aaaa'),(null),('bbbb'),('cccc')) g(a);
   string_agg   
----------------
 aaaa,bbbb,cccc
(1 row)

select string_agg(a,'AB') from (values(null),(null),('bbbb'),('cccc')) g(a);
 string_agg 
------------
 bbbbABcccc
(1 row)

select string_agg(a,',') from (values(null),(null)) g(a);
 string_agg 
------------
 
(1 row)

-- check some implicit casting cases, as per bug #5564
select string_agg(distinct f1, ',' order by f1) from varchar_tbl;  -- ok
INFO:  GPORCA failed to produce a plan, falling back to planner
DETAIL:  GPDB Expression type: Ordered aggregates not supported in DXL
 string_agg 
------------
 a,ab,abcd
(1 row)

select string_agg(distinct f1::text, ',' order by f1) from varchar_tbl;  -- not ok
ERROR:  in an aggregate with DISTINCT, ORDER BY expressions must appear in argument list
LINE 1: select string_agg(distinct f1::text, ',' order by f1) from v...
                                                          ^
select string_agg(distinct f1, ',' order by f1::text) from varchar_tbl;  -- not ok
ERROR:  in an aggregate with DISTINCT, ORDER BY expressions must appear in argument list
LINE 1: select string_agg(distinct f1, ',' order by f1::text) from v...
                                                    ^
select string_agg(distinct f1::text, ',' order by f1::text) from varchar_tbl;  -- ok
INFO:  GPORCA failed to produce a plan, falling back to planner
DETAIL:  GPDB Expression type: Ordered aggregates not supported in DXL
 string_agg 
------------
 a,ab,abcd
(1 row)

-- FILTER tests
select min(unique1) filter (where unique1 > 100) from tenk1;
INFO:  GPORCA failed to produce a plan, falling back to planner
DETAIL:  Feature not supported: Aggregate functions with FILTER
 min 
-----
 101
(1 row)

select ten, sum(distinct four) filter (where four::text ~ '123') from onek a
group by ten;
INFO:  GPORCA failed to produce a plan, falling back to planner
DETAIL:  Feature not supported: Aggregate functions with FILTER
 ten | sum 
-----+-----
   0 |    
   1 |    
   2 |    
   3 |    
   4 |    
   5 |    
   6 |    
   7 |    
   8 |    
   9 |    
(10 rows)

select ten, sum(distinct four) filter (where four > 10) from onek a
group by ten
having exists (select 1 from onek b where sum(distinct a.four) = b.four);
INFO:  GPORCA failed to produce a plan, falling back to planner
DETAIL:  Feature not supported: Aggregate functions with FILTER
 ten | sum 
-----+-----
   0 |    
   2 |    
   4 |    
   6 |    
   8 |    
(5 rows)

select max(foo COLLATE "C") filter (where (bar collate "POSIX") > '0')
from (values ('a', 'b')) AS v(foo,bar);
INFO:  GPORCA failed to produce a plan, falling back to planner
DETAIL:  Feature not supported: Non-default collation
 max 
-----
 a
(1 row)

-- outer reference in FILTER (PostgreSQL extension)
select (select count(*)
        from (values (1)) t0(inner_c))
from (values (2),(3)) t1(outer_c); -- inner query is aggregation query
 count 
-------
     1
     1
(2 rows)

select (select count(*) filter (where outer_c <> 0)
        from (values (1)) t0(inner_c))
from (values (2),(3)) t1(outer_c); -- outer query is aggregation query
INFO:  GPORCA failed to produce a plan, falling back to planner
DETAIL:  Feature not supported: Aggregate functions with FILTER
 count 
-------
     2
(1 row)

select (select count(inner_c) filter (where outer_c <> 0)
        from (values (1)) t0(inner_c))
from (values (2),(3)) t1(outer_c); -- inner query is aggregation query
INFO:  GPORCA failed to produce a plan, falling back to planner
DETAIL:  Feature not supported: Aggregate functions with FILTER
 count 
-------
     1
     1
(2 rows)

select
  (select max((select i.unique2 from tenk1 i where i.unique1 = o.unique1))
     filter (where o.unique1 < 10))
from tenk1 o;					-- outer query is aggregation query
INFO:  GPORCA failed to produce a plan, falling back to planner
DETAIL:  Feature not supported: Aggregate functions with FILTER
 max  
------
 9998
(1 row)

-- subquery in FILTER clause (PostgreSQL extension)
select sum(unique1) FILTER (WHERE
  unique1 IN (SELECT unique1 FROM onek where unique1 < 100)) FROM tenk1;
INFO:  GPORCA failed to produce a plan, falling back to planner
DETAIL:  Feature not supported: Aggregate functions with FILTER
 sum  
------
 4950
(1 row)

-- exercise lots of aggregate parts with FILTER
select aggfns(distinct a,b,c order by a,c using ~<~,b) filter (where a > 1)
    from (values (1,3,'foo'),(0,null,null),(2,2,'bar'),(3,1,'baz')) v(a,b,c),
    generate_series(1,2) i;
INFO:  GPORCA failed to produce a plan, falling back to planner
DETAIL:  GPDB Expression type: Ordered aggregates not supported in DXL
INFO:  GPORCA failed to produce a plan, falling back to planner
DETAIL:  Feature not supported: ROW EXPRESSION
CONTEXT:  SQL function "aggfns_trans" during startup
          aggfns           
---------------------------
 {"(2,2,bar)","(3,1,baz)"}
(1 row)

-- ordered-set aggregates
select p, percentile_cont(p) within group (order by x::float8)
from generate_series(1,5) x,
     (values (0::float8),(0.1),(0.25),(0.4),(0.5),(0.6),(0.75),(0.9),(1)) v(p)
group by p order by p;
INFO:  GPORCA failed to produce a plan, falling back to planner
DETAIL:  GPDB Expression type: Ordered aggregates not supported in DXL
  p   | percentile_cont 
------+-----------------
    0 |               1
  0.1 |             1.4
 0.25 |               2
  0.4 |             2.6
  0.5 |               3
  0.6 |             3.4
 0.75 |               4
  0.9 |             4.6
    1 |               5
(9 rows)

select p, percentile_cont(p order by p) within group (order by x)  -- error
from generate_series(1,5) x,
     (values (0::float8),(0.1),(0.25),(0.4),(0.5),(0.6),(0.75),(0.9),(1)) v(p)
group by p order by p;
ERROR:  cannot use multiple ORDER BY clauses with WITHIN GROUP
LINE 1: select p, percentile_cont(p order by p) within group (order ...
                                                ^
select p, sum() within group (order by x::float8)  -- error
from generate_series(1,5) x,
     (values (0::float8),(0.1),(0.25),(0.4),(0.5),(0.6),(0.75),(0.9),(1)) v(p)
group by p order by p;
ERROR:  sum is not an ordered-set aggregate, so it cannot have WITHIN GROUP
LINE 1: select p, sum() within group (order by x::float8)  
                  ^
select p, percentile_cont(p,p)  -- error
from generate_series(1,5) x,
     (values (0::float8),(0.1),(0.25),(0.4),(0.5),(0.6),(0.75),(0.9),(1)) v(p)
group by p order by p;
ERROR:  WITHIN GROUP is required for ordered-set aggregate percentile_cont
LINE 1: select p, percentile_cont(p,p)  
                  ^
select percentile_cont(0.5) within group (order by b) from aggtest;
INFO:  GPORCA failed to produce a plan, falling back to planner
DETAIL:  GPDB Expression type: Ordered aggregates not supported in DXL
 percentile_cont  
------------------
 53.4485001564026
(1 row)

select percentile_cont(0.5) within group (order by b), sum(b) from aggtest;
INFO:  GPORCA failed to produce a plan, falling back to planner
DETAIL:  GPDB Expression type: Ordered aggregates not supported in DXL
 percentile_cont  |   sum   
------------------+---------
 53.4485001564026 | 431.773
(1 row)

select percentile_cont(0.5) within group (order by thousand) from tenk1;
INFO:  GPORCA failed to produce a plan, falling back to planner
DETAIL:  GPDB Expression type: Ordered aggregates not supported in DXL
 percentile_cont 
-----------------
           499.5
(1 row)

select percentile_disc(0.5) within group (order by thousand) from tenk1;
INFO:  GPORCA failed to produce a plan, falling back to planner
DETAIL:  GPDB Expression type: Ordered aggregates not supported in DXL
 percentile_disc 
-----------------
             499
(1 row)

select rank(3) within group (order by x)
from (values (1),(1),(2),(2),(3),(3),(4)) v(x);
INFO:  GPORCA failed to produce a plan, falling back to planner
DETAIL:  GPDB Expression type: Ordered aggregates not supported in DXL
 rank 
------
    5
(1 row)

select cume_dist(3) within group (order by x)
from (values (1),(1),(2),(2),(3),(3),(4)) v(x);
INFO:  GPORCA failed to produce a plan, falling back to planner
DETAIL:  GPDB Expression type: Ordered aggregates not supported in DXL
 cume_dist 
-----------
     0.875
(1 row)

select percent_rank(3) within group (order by x)
from (values (1),(1),(2),(2),(3),(3),(4),(5)) v(x);
INFO:  GPORCA failed to produce a plan, falling back to planner
DETAIL:  GPDB Expression type: Ordered aggregates not supported in DXL
 percent_rank 
--------------
          0.5
(1 row)

select dense_rank(3) within group (order by x)
from (values (1),(1),(2),(2),(3),(3),(4)) v(x);
INFO:  GPORCA failed to produce a plan, falling back to planner
DETAIL:  GPDB Expression type: Ordered aggregates not supported in DXL
 dense_rank 
------------
          3
(1 row)

select percentile_disc(array[0,0.1,0.25,0.5,0.75,0.9,1]) within group (order by thousand)
from tenk1;
INFO:  GPORCA failed to produce a plan, falling back to planner
DETAIL:  GPDB Expression type: Ordered aggregates not supported in DXL
      percentile_disc       
----------------------------
 {0,99,249,499,749,899,999}
(1 row)

select percentile_cont(array[0,0.25,0.5,0.75,1]) within group (order by thousand)
from tenk1;
INFO:  GPORCA failed to produce a plan, falling back to planner
DETAIL:  GPDB Expression type: Ordered aggregates not supported in DXL
       percentile_cont       
-----------------------------
 {0,249.75,499.5,749.25,999}
(1 row)

select percentile_disc(array[[null,1,0.5],[0.75,0.25,null]]) within group (order by thousand)
from tenk1;
INFO:  GPORCA failed to produce a plan, falling back to planner
DETAIL:  GPDB Expression type: Ordered aggregates not supported in DXL
         percentile_disc         
---------------------------------
 {{NULL,999,499},{749,249,NULL}}
(1 row)

select percentile_cont(array[0,1,0.25,0.75,0.5,1]) within group (order by x)
from generate_series(1,6) x;
INFO:  GPORCA failed to produce a plan, falling back to planner
DETAIL:  GPDB Expression type: Ordered aggregates not supported in DXL
    percentile_cont    
-----------------------
 {1,6,2.25,4.75,3.5,6}
(1 row)

select ten, mode() within group (order by string4) from tenk1 group by ten order by ten;
INFO:  GPORCA failed to produce a plan, falling back to planner
DETAIL:  GPDB Expression type: Ordered aggregates not supported in DXL
 ten |  mode  
-----+--------
   0 | HHHHxx
   1 | OOOOxx
   2 | VVVVxx
   3 | OOOOxx
   4 | HHHHxx
   5 | HHHHxx
   6 | OOOOxx
   7 | AAAAxx
   8 | VVVVxx
   9 | VVVVxx
(10 rows)

select percentile_disc(array[0.25,0.5,0.75]) within group (order by x)
from unnest('{fred,jim,fred,jack,jill,fred,jill,jim,jim,sheila,jim,sheila}'::text[]) u(x);
INFO:  GPORCA failed to produce a plan, falling back to planner
DETAIL:  GPDB Expression type: Ordered aggregates not supported in DXL
 percentile_disc 
-----------------
 {fred,jill,jim}
(1 row)

-- check collation propagates up in suitable cases:
select pg_collation_for(percentile_disc(1) within group (order by x collate "POSIX"))
  from (values ('fred'),('jim')) v(x);
INFO:  GPORCA failed to produce a plan, falling back to planner
DETAIL:  Feature not supported: Non-default collation
 pg_collation_for 
------------------
 "POSIX"
(1 row)

-- ordered-set aggs created with CREATE AGGREGATE
select test_rank(3) within group (order by x)
from (values (1),(1),(2),(2),(3),(3),(4)) v(x);
INFO:  GPORCA failed to produce a plan, falling back to planner
DETAIL:  GPDB Expression type: Ordered aggregates not supported in DXL
 test_rank 
-----------
         5
(1 row)

select test_percentile_disc(0.5) within group (order by thousand) from tenk1;
INFO:  GPORCA failed to produce a plan, falling back to planner
DETAIL:  GPDB Expression type: Ordered aggregates not supported in DXL
 test_percentile_disc 
----------------------
                  499
(1 row)

-- ordered-set aggs can't use ungrouped vars in direct args:
select rank(x) within group (order by x) from generate_series(1,5) x;
ERROR:  column "x.x" must appear in the GROUP BY clause or be used in an aggregate function
LINE 1: select rank(x) within group (order by x) from generate_serie...
                    ^
DETAIL:  Direct arguments of an ordered-set aggregate must use only grouped columns.
-- outer-level agg can't use a grouped arg of a lower level, either:
select array(select percentile_disc(a) within group (order by x)
               from (values (0.3),(0.7)) v(a) group by a)
  from generate_series(1,5) g(x);
ERROR:  outer-level aggregate cannot contain a lower-level variable in its direct arguments
LINE 1: select array(select percentile_disc(a) within group (order b...
                                            ^
-- agg in the direct args is a grouping violation, too:
select rank(sum(x)) within group (order by x) from generate_series(1,5) x;
ERROR:  aggregate function calls cannot be nested
LINE 1: select rank(sum(x)) within group (order by x) from generate_...
                    ^
-- hypothetical-set type unification and argument-count failures:
select rank(3) within group (order by x) from (values ('fred'),('jim')) v(x);
ERROR:  WITHIN GROUP types text and integer cannot be matched
LINE 1: select rank(3) within group (order by x) from (values ('fred...
                    ^
select rank(3) within group (order by stringu1,stringu2) from tenk1;
ERROR:  function rank(integer, name, name) does not exist
LINE 1: select rank(3) within group (order by stringu1,stringu2) fro...
               ^
HINT:  To use the hypothetical-set aggregate rank, the number of hypothetical direct arguments (here 1) must match the number of ordering columns (here 2).
select rank('fred') within group (order by x) from generate_series(1,5) x;
ERROR:  invalid input syntax for integer: "fred"
LINE 1: select rank('fred') within group (order by x) from generate_...
                    ^
select rank('adam'::text collate "C") within group (order by x collate "POSIX")
  from (values ('fred'),('jim')) v(x);
ERROR:  collation mismatch between explicit collations "C" and "POSIX"
LINE 1: ...adam'::text collate "C") within group (order by x collate "P...
                                                             ^
-- hypothetical-set type unification successes:
select rank('adam'::varchar) within group (order by x) from (values ('fred'),('jim')) v(x);
INFO:  GPORCA failed to produce a plan, falling back to planner
DETAIL:  GPDB Expression type: Ordered aggregates not supported in DXL
 rank 
------
    1
(1 row)

select rank('3') within group (order by x) from generate_series(1,5) x;
INFO:  GPORCA failed to produce a plan, falling back to planner
DETAIL:  GPDB Expression type: Ordered aggregates not supported in DXL
 rank 
------
    3
(1 row)

-- divide by zero check
select percent_rank(0) within group (order by x) from generate_series(1,0) x;
INFO:  GPORCA failed to produce a plan, falling back to planner
DETAIL:  GPDB Expression type: Ordered aggregates not supported in DXL
 percent_rank 
--------------
            0
(1 row)

-- deparse and multiple features:
create view aggordview1 as
select ten,
       percentile_disc(0.5) within group (order by thousand) as p50,
       percentile_disc(0.5) within group (order by thousand) filter (where hundred=1) as px,
       rank(5,'AZZZZ',50) within group (order by hundred, string4 desc, hundred)
  from tenk1
 group by ten order by ten;
select pg_get_viewdef('aggordview1');
                                                        pg_get_viewdef                                                         
-------------------------------------------------------------------------------------------------------------------------------
  SELECT tenk1.ten,                                                                                                           +
     percentile_disc((0.5)::double precision) WITHIN GROUP (ORDER BY tenk1.thousand) AS p50,                                  +
     percentile_disc((0.5)::double precision) WITHIN GROUP (ORDER BY tenk1.thousand) FILTER (WHERE (tenk1.hundred = 1)) AS px,+
     rank(5, 'AZZZZ'::name, 50) WITHIN GROUP (ORDER BY tenk1.hundred, tenk1.string4 DESC, tenk1.hundred) AS rank              +
    FROM tenk1                                                                                                                +
   GROUP BY tenk1.ten                                                                                                         +
   ORDER BY tenk1.ten;
(1 row)

select * from aggordview1 order by ten;
INFO:  GPORCA failed to produce a plan, falling back to planner
DETAIL:  GPDB Expression type: Ordered aggregates not supported in DXL
 ten | p50 | px  | rank 
-----+-----+-----+------
   0 | 490 |     |  101
   1 | 491 | 401 |  101
   2 | 492 |     |  101
   3 | 493 |     |  101
   4 | 494 |     |  101
   5 | 495 |     |   67
   6 | 496 |     |    1
   7 | 497 |     |    1
   8 | 498 |     |    1
   9 | 499 |     |    1
(10 rows)

drop view aggordview1;
-- variadic aggregates
select least_agg(q1,q2) from int8_tbl;
INFO:  GPORCA failed to produce a plan, falling back to planner
DETAIL:  GPDB Expression type: Query Parameter not supported in DXL
CONTEXT:  SQL function "least_accum" during startup
     least_agg     
-------------------
 -4567890123456789
(1 row)

select least_agg(variadic array[q1,q2]) from int8_tbl;
INFO:  GPORCA failed to produce a plan, falling back to planner
DETAIL:  GPDB Expression type: Query Parameter not supported in DXL
CONTEXT:  SQL function "least_accum" during startup
     least_agg     
-------------------
 -4567890123456789
(1 row)

-- string_agg bytea tests
create table bytea_test_table(gpDistKey int, v bytea);
NOTICE:  Table doesn't have 'DISTRIBUTED BY' clause -- Using column named 'gpdistkey' as the Greenplum Database data distribution key for this table.
HINT:  The 'DISTRIBUTED BY' clause determines the distribution of data. Make sure column(s) chosen are the optimal data distribution key to minimize skew.
select string_agg(v, '') from bytea_test_table;
 string_agg 
------------
 
(1 row)

insert into bytea_test_table(v) values(decode('ff','hex'));
select string_agg(v, '') from bytea_test_table;
 string_agg 
------------
 \xff
(1 row)

insert into bytea_test_table(v) values(decode('aa','hex'));
select string_agg(v, '') from bytea_test_table;
 string_agg 
------------
 \xffaa
(1 row)

select string_agg(v, NULL) from bytea_test_table;
 string_agg 
------------
 \xffaa
(1 row)

select string_agg(v, decode('ee', 'hex')) from bytea_test_table;
 string_agg 
------------
 \xffeeaa
(1 row)

drop table bytea_test_table;
-- FILTER tests
select min(unique1) filter (where unique1 > 100) from tenk1;
INFO:  GPORCA failed to produce a plan, falling back to planner
DETAIL:  Feature not supported: Aggregate functions with FILTER
 min 
-----
 101
(1 row)

select ten, sum(distinct four) filter (where four::text ~ '123') from onek a
group by ten;
INFO:  GPORCA failed to produce a plan, falling back to planner
DETAIL:  Feature not supported: Aggregate functions with FILTER
 ten | sum 
-----+-----
   0 |    
   1 |    
   2 |    
   3 |    
   4 |    
   5 |    
   6 |    
   7 |    
   8 |    
   9 |    
(10 rows)

select ten, sum(distinct four) filter (where four > 10) from onek a
group by ten
having exists (select 1 from onek b where sum(distinct a.four) = b.four);
INFO:  GPORCA failed to produce a plan, falling back to planner
DETAIL:  Feature not supported: Aggregate functions with FILTER
 ten | sum 
-----+-----
   0 |    
   2 |    
   4 |    
   6 |    
   8 |    
(5 rows)

select max(foo COLLATE "C") filter (where (bar collate "POSIX") > '0')
from (values ('a', 'b')) AS v(foo,bar);
INFO:  GPORCA failed to produce a plan, falling back to planner
DETAIL:  Feature not supported: Non-default collation
 max 
-----
 a
(1 row)

-- outer reference in FILTER (PostgreSQL extension)
select (select count(*)
        from (values (1)) t0(inner_c))
from (values (2),(3)) t1(outer_c); -- inner query is aggregation query
 count 
-------
     1
     1
(2 rows)

select (select count(*) filter (where outer_c <> 0)
        from (values (1)) t0(inner_c))
from (values (2),(3)) t1(outer_c); -- outer query is aggregation query
INFO:  GPORCA failed to produce a plan, falling back to planner
DETAIL:  Feature not supported: Aggregate functions with FILTER
 count 
-------
     2
(1 row)

select (select count(inner_c) filter (where outer_c <> 0)
        from (values (1)) t0(inner_c))
from (values (2),(3)) t1(outer_c); -- inner query is aggregation query
INFO:  GPORCA failed to produce a plan, falling back to planner
DETAIL:  Feature not supported: Aggregate functions with FILTER
 count 
-------
     1
     1
(2 rows)

select
  (select max((select i.unique2 from tenk1 i where i.unique1 = o.unique1))
     filter (where o.unique1 < 10))
from tenk1 o;					-- outer query is aggregation query
INFO:  GPORCA failed to produce a plan, falling back to planner
DETAIL:  Feature not supported: Aggregate functions with FILTER
 max  
------
 9998
(1 row)

-- subquery in FILTER clause (PostgreSQL extension)
select sum(unique1) FILTER (WHERE
  unique1 IN (SELECT unique1 FROM onek where unique1 < 100)) FROM tenk1;
INFO:  GPORCA failed to produce a plan, falling back to planner
DETAIL:  Feature not supported: Aggregate functions with FILTER
 sum  
------
 4950
(1 row)

-- exercise lots of aggregate parts with FILTER
select aggfns(distinct a,b,c order by a,c using ~<~,b) filter (where a > 1)
    from (values (1,3,'foo'),(0,null,null),(2,2,'bar'),(3,1,'baz')) v(a,b,c),
    generate_series(1,2) i;
INFO:  GPORCA failed to produce a plan, falling back to planner
DETAIL:  GPDB Expression type: Ordered aggregates not supported in DXL
INFO:  GPORCA failed to produce a plan, falling back to planner
DETAIL:  Feature not supported: ROW EXPRESSION
CONTEXT:  SQL function "aggfns_trans" during startup
          aggfns           
---------------------------
 {"(2,2,bar)","(3,1,baz)"}
(1 row)

-- ordered-set aggregates
select p, percentile_cont(p) within group (order by x::float8)
from generate_series(1,5) x,
     (values (0::float8),(0.1),(0.25),(0.4),(0.5),(0.6),(0.75),(0.9),(1)) v(p)
group by p order by p;
INFO:  GPORCA failed to produce a plan, falling back to planner
DETAIL:  GPDB Expression type: Ordered aggregates not supported in DXL
  p   | percentile_cont 
------+-----------------
    0 |               1
  0.1 |             1.4
 0.25 |               2
  0.4 |             2.6
  0.5 |               3
  0.6 |             3.4
 0.75 |               4
  0.9 |             4.6
    1 |               5
(9 rows)

select p, percentile_cont(p order by p) within group (order by x)  -- error
from generate_series(1,5) x,
     (values (0::float8),(0.1),(0.25),(0.4),(0.5),(0.6),(0.75),(0.9),(1)) v(p)
group by p order by p;
ERROR:  cannot use multiple ORDER BY clauses with WITHIN GROUP
LINE 1: select p, percentile_cont(p order by p) within group (order ...
                                                ^
select p, sum() within group (order by x::float8)  -- error
from generate_series(1,5) x,
     (values (0::float8),(0.1),(0.25),(0.4),(0.5),(0.6),(0.75),(0.9),(1)) v(p)
group by p order by p;
ERROR:  sum is not an ordered-set aggregate, so it cannot have WITHIN GROUP
LINE 1: select p, sum() within group (order by x::float8)  
                  ^
select p, percentile_cont(p,p)  -- error
from generate_series(1,5) x,
     (values (0::float8),(0.1),(0.25),(0.4),(0.5),(0.6),(0.75),(0.9),(1)) v(p)
group by p order by p;
ERROR:  WITHIN GROUP is required for ordered-set aggregate percentile_cont
LINE 1: select p, percentile_cont(p,p)  
                  ^
select percentile_cont(0.5) within group (order by b) from aggtest;
INFO:  GPORCA failed to produce a plan, falling back to planner
DETAIL:  GPDB Expression type: Ordered aggregates not supported in DXL
 percentile_cont  
------------------
 53.4485001564026
(1 row)

select percentile_cont(0.5) within group (order by b), sum(b) from aggtest;
INFO:  GPORCA failed to produce a plan, falling back to planner
DETAIL:  GPDB Expression type: Ordered aggregates not supported in DXL
 percentile_cont  |   sum   
------------------+---------
 53.4485001564026 | 431.773
(1 row)

select percentile_cont(0.5) within group (order by thousand) from tenk1;
INFO:  GPORCA failed to produce a plan, falling back to planner
DETAIL:  GPDB Expression type: Ordered aggregates not supported in DXL
 percentile_cont 
-----------------
           499.5
(1 row)

select percentile_disc(0.5) within group (order by thousand) from tenk1;
INFO:  GPORCA failed to produce a plan, falling back to planner
DETAIL:  GPDB Expression type: Ordered aggregates not supported in DXL
 percentile_disc 
-----------------
             499
(1 row)

select rank(3) within group (order by x)
from (values (1),(1),(2),(2),(3),(3),(4)) v(x);
INFO:  GPORCA failed to produce a plan, falling back to planner
DETAIL:  GPDB Expression type: Ordered aggregates not supported in DXL
 rank 
------
    5
(1 row)

select cume_dist(3) within group (order by x)
from (values (1),(1),(2),(2),(3),(3),(4)) v(x);
INFO:  GPORCA failed to produce a plan, falling back to planner
DETAIL:  GPDB Expression type: Ordered aggregates not supported in DXL
 cume_dist 
-----------
     0.875
(1 row)

select percent_rank(3) within group (order by x)
from (values (1),(1),(2),(2),(3),(3),(4),(5)) v(x);
INFO:  GPORCA failed to produce a plan, falling back to planner
DETAIL:  GPDB Expression type: Ordered aggregates not supported in DXL
 percent_rank 
--------------
          0.5
(1 row)

select dense_rank(3) within group (order by x)
from (values (1),(1),(2),(2),(3),(3),(4)) v(x);
INFO:  GPORCA failed to produce a plan, falling back to planner
DETAIL:  GPDB Expression type: Ordered aggregates not supported in DXL
 dense_rank 
------------
          3
(1 row)

select percentile_disc(array[0,0.1,0.25,0.5,0.75,0.9,1]) within group (order by thousand)
from tenk1;
INFO:  GPORCA failed to produce a plan, falling back to planner
DETAIL:  GPDB Expression type: Ordered aggregates not supported in DXL
      percentile_disc       
----------------------------
 {0,99,249,499,749,899,999}
(1 row)

select percentile_cont(array[0,0.25,0.5,0.75,1]) within group (order by thousand)
from tenk1;
INFO:  GPORCA failed to produce a plan, falling back to planner
DETAIL:  GPDB Expression type: Ordered aggregates not supported in DXL
       percentile_cont       
-----------------------------
 {0,249.75,499.5,749.25,999}
(1 row)

select percentile_disc(array[[null,1,0.5],[0.75,0.25,null]]) within group (order by thousand)
from tenk1;
INFO:  GPORCA failed to produce a plan, falling back to planner
DETAIL:  GPDB Expression type: Ordered aggregates not supported in DXL
         percentile_disc         
---------------------------------
 {{NULL,999,499},{749,249,NULL}}
(1 row)

select percentile_cont(array[0,1,0.25,0.75,0.5,1,0.3,0.32,0.35,0.38,0.4]) within group (order by x)
from generate_series(1,6) x;
INFO:  GPORCA failed to produce a plan, falling back to planner
DETAIL:  GPDB Expression type: Ordered aggregates not supported in DXL
             percentile_cont              
------------------------------------------
 {1,6,2.25,4.75,3.5,6,2.5,2.6,2.75,2.9,3}
(1 row)

select ten, mode() within group (order by string4) from tenk1 group by ten;
INFO:  GPORCA failed to produce a plan, falling back to planner
DETAIL:  GPDB Expression type: Ordered aggregates not supported in DXL
 ten |  mode  
-----+--------
   0 | HHHHxx
   1 | OOOOxx
   2 | VVVVxx
   3 | OOOOxx
   4 | HHHHxx
   5 | HHHHxx
   6 | OOOOxx
   7 | AAAAxx
   8 | VVVVxx
   9 | VVVVxx
(10 rows)

select percentile_disc(array[0.25,0.5,0.75]) within group (order by x)
from unnest('{fred,jim,fred,jack,jill,fred,jill,jim,jim,sheila,jim,sheila}'::text[]) u(x);
INFO:  GPORCA failed to produce a plan, falling back to planner
DETAIL:  GPDB Expression type: Ordered aggregates not supported in DXL
 percentile_disc 
-----------------
 {fred,jill,jim}
(1 row)

-- check collation propagates up in suitable cases:
select pg_collation_for(percentile_disc(1) within group (order by x collate "POSIX"))
  from (values ('fred'),('jim')) v(x);
INFO:  GPORCA failed to produce a plan, falling back to planner
DETAIL:  Feature not supported: Non-default collation
 pg_collation_for 
------------------
 "POSIX"
(1 row)

-- ordered-set aggs created with CREATE AGGREGATE
select test_rank(3) within group (order by x)
from (values (1),(1),(2),(2),(3),(3),(4)) v(x);
INFO:  GPORCA failed to produce a plan, falling back to planner
DETAIL:  GPDB Expression type: Ordered aggregates not supported in DXL
 test_rank 
-----------
         5
(1 row)

select test_percentile_disc(0.5) within group (order by thousand) from tenk1;
INFO:  GPORCA failed to produce a plan, falling back to planner
DETAIL:  GPDB Expression type: Ordered aggregates not supported in DXL
 test_percentile_disc 
----------------------
                  499
(1 row)

-- ordered-set aggs can't use ungrouped vars in direct args:
select rank(x) within group (order by x) from generate_series(1,5) x;
ERROR:  column "x.x" must appear in the GROUP BY clause or be used in an aggregate function
LINE 1: select rank(x) within group (order by x) from generate_serie...
                    ^
DETAIL:  Direct arguments of an ordered-set aggregate must use only grouped columns.
-- outer-level agg can't use a grouped arg of a lower level, either:
select array(select percentile_disc(a) within group (order by x)
               from (values (0.3),(0.7)) v(a) group by a)
  from generate_series(1,5) g(x);
ERROR:  outer-level aggregate cannot contain a lower-level variable in its direct arguments
LINE 1: select array(select percentile_disc(a) within group (order b...
                                            ^
-- agg in the direct args is a grouping violation, too:
select rank(sum(x)) within group (order by x) from generate_series(1,5) x;
ERROR:  aggregate function calls cannot be nested
LINE 1: select rank(sum(x)) within group (order by x) from generate_...
                    ^
-- hypothetical-set type unification and argument-count failures:
select rank(3) within group (order by x) from (values ('fred'),('jim')) v(x);
ERROR:  WITHIN GROUP types text and integer cannot be matched
LINE 1: select rank(3) within group (order by x) from (values ('fred...
                    ^
select rank(3) within group (order by stringu1,stringu2) from tenk1;
ERROR:  function rank(integer, name, name) does not exist
LINE 1: select rank(3) within group (order by stringu1,stringu2) fro...
               ^
HINT:  To use the hypothetical-set aggregate rank, the number of hypothetical direct arguments (here 1) must match the number of ordering columns (here 2).
select rank('fred') within group (order by x) from generate_series(1,5) x;
ERROR:  invalid input syntax for integer: "fred"
LINE 1: select rank('fred') within group (order by x) from generate_...
                    ^
select rank('adam'::text collate "C") within group (order by x collate "POSIX")
  from (values ('fred'),('jim')) v(x);
ERROR:  collation mismatch between explicit collations "C" and "POSIX"
LINE 1: ...adam'::text collate "C") within group (order by x collate "P...
                                                             ^
-- hypothetical-set type unification successes:
select rank('adam'::varchar) within group (order by x) from (values ('fred'),('jim')) v(x);
INFO:  GPORCA failed to produce a plan, falling back to planner
DETAIL:  GPDB Expression type: Ordered aggregates not supported in DXL
 rank 
------
    1
(1 row)

select rank('3') within group (order by x) from generate_series(1,5) x;
INFO:  GPORCA failed to produce a plan, falling back to planner
DETAIL:  GPDB Expression type: Ordered aggregates not supported in DXL
 rank 
------
    3
(1 row)

-- divide by zero check
select percent_rank(0) within group (order by x) from generate_series(1,0) x;
INFO:  GPORCA failed to produce a plan, falling back to planner
DETAIL:  GPDB Expression type: Ordered aggregates not supported in DXL
 percent_rank 
--------------
            0
(1 row)

-- deparse and multiple features:
create view aggordview1 as
select ten,
       percentile_disc(0.5) within group (order by thousand) as p50,
       percentile_disc(0.5) within group (order by thousand) filter (where hundred=1) as px,
       rank(5,'AZZZZ',50) within group (order by hundred, string4 desc, hundred)
  from tenk1
 group by ten order by ten;
select pg_get_viewdef('aggordview1');
                                                        pg_get_viewdef                                                         
-------------------------------------------------------------------------------------------------------------------------------
  SELECT tenk1.ten,                                                                                                           +
     percentile_disc((0.5)::double precision) WITHIN GROUP (ORDER BY tenk1.thousand) AS p50,                                  +
     percentile_disc((0.5)::double precision) WITHIN GROUP (ORDER BY tenk1.thousand) FILTER (WHERE (tenk1.hundred = 1)) AS px,+
     rank(5, 'AZZZZ'::name, 50) WITHIN GROUP (ORDER BY tenk1.hundred, tenk1.string4 DESC, tenk1.hundred) AS rank              +
    FROM tenk1                                                                                                                +
   GROUP BY tenk1.ten                                                                                                         +
   ORDER BY tenk1.ten;
(1 row)

select * from aggordview1 order by ten;
INFO:  GPORCA failed to produce a plan, falling back to planner
DETAIL:  GPDB Expression type: Ordered aggregates not supported in DXL
 ten | p50 | px  | rank 
-----+-----+-----+------
   0 | 490 |     |  101
   1 | 491 | 401 |  101
   2 | 492 |     |  101
   3 | 493 |     |  101
   4 | 494 |     |  101
   5 | 495 |     |   67
   6 | 496 |     |    1
   7 | 497 |     |    1
   8 | 498 |     |    1
   9 | 499 |     |    1
(10 rows)

drop view aggordview1;
-- variadic aggregates
select least_agg(q1,q2) from int8_tbl;
INFO:  GPORCA failed to produce a plan, falling back to planner
DETAIL:  GPDB Expression type: Query Parameter not supported in DXL
CONTEXT:  SQL function "least_accum" during startup
     least_agg     
-------------------
 -4567890123456789
(1 row)

select least_agg(variadic array[q1,q2]) from int8_tbl;
INFO:  GPORCA failed to produce a plan, falling back to planner
DETAIL:  GPDB Expression type: Query Parameter not supported in DXL
CONTEXT:  SQL function "least_accum" during startup
     least_agg     
-------------------
 -4567890123456789
(1 row)

-- check collation-sensitive matching between grouping expressions
select v||'a', case v||'a' when 'aa' then 1 else 0 end, count(*)
  from unnest(array['a','b']) u(v)
 group by v||'a' order by 1;
 ?column? | case | count 
----------+------+-------
 aa       |    1 |     1
 ba       |    0 |     1
(2 rows)

select v||'a', case when v||'a' = 'aa' then 1 else 0 end, count(*)
  from unnest(array['a','b']) u(v)
 group by v||'a' order by 1;
 ?column? | case | count 
----------+------+-------
 aa       |    1 |     1
 ba       |    0 |     1
(2 rows)

