-- TODO: inherit tables
-- TODO: partition tables
-- TODO: ao tables
-- TODO: tables and temp tables
\set explain 'explain analyze'
create extension if not exists gp_debug_numsegments;
drop schema if exists test_partial_table;
NOTICE:  schema "test_partial_table" does not exist, skipping
create schema test_partial_table;
set search_path=test_partial_table,public;
set allow_system_table_mods=true;
--
-- prepare kinds of tables
--
select gp_debug_set_create_table_default_numsegments(1);
 gp_debug_set_create_table_default_numsegments 
-----------------------------------------------
 1
(1 row)

create table t1 (c1 int, c2 int, c3 int, c4 int) distributed by (c1, c2);
create table d1 (c1 int, c2 int, c3 int, c4 int) distributed replicated;
create table r1 (c1 int, c2 int, c3 int, c4 int) distributed randomly;
select gp_debug_set_create_table_default_numsegments(2);
 gp_debug_set_create_table_default_numsegments 
-----------------------------------------------
 2
(1 row)

create table t2 (c1 int, c2 int, c3 int, c4 int) distributed by (c1, c2);
create table d2 (c1 int, c2 int, c3 int, c4 int) distributed replicated;
create table r2 (c1 int, c2 int, c3 int, c4 int) distributed randomly;
select gp_debug_reset_create_table_default_numsegments();
 gp_debug_reset_create_table_default_numsegments 
-------------------------------------------------
 
(1 row)

select localoid::regclass, distkey, policytype, numsegments
	from gp_distribution_policy where localoid in (
		't1'::regclass, 'd1'::regclass, 'r1'::regclass,
		't2'::regclass, 'd2'::regclass, 'r2'::regclass);
 localoid | distkey | policytype | numsegments 
----------+---------+------------+-------------
 t1       | 1 2     | p          |           1
 d1       |         | r          |           1
 r1       |         | p          |           1
 t2       | 1 2     | p          |           2
 d2       |         | r          |           2
 r2       |         | p          |           2
(6 rows)

analyze t1;
analyze d1;
analyze r1;
analyze t2;
analyze d2;
analyze r2;
--
-- regression tests
--
-- Test numsegments properity cannot be larger than the size of cluster
create table size_sanity_check(c1 int, c2 int);
NOTICE:  Table doesn't have 'DISTRIBUTED BY' clause -- Using column named 'c1' as the Greenplum Database data distribution key for this table.
HINT:  The 'DISTRIBUTED BY' clause determines the distribution of data. Make sure column(s) chosen are the optimal data distribution key to minimize skew.
update gp_distribution_policy set numsegments = 10 where localoid = 'size_sanity_check'::regclass;
select * from size_sanity_check;
ERROR:  cannot access table "size_sanity_check" in current transaction
LINE 1: select * from size_sanity_check;
                      ^
DETAIL:  New segments are concurrently added to the cluster during the execution of current transaction, the table has data on some of the new segments, but these new segments are invisible and inaccessible to current transaction.
HINT:  Re-run the query in a new transaction.
update gp_distribution_policy set numsegments = 3 where localoid = 'size_sanity_check'::regclass;
-- a temp table is created during reorganization, its numsegments should be
-- the same with original table, otherwise some data will be lost after the
-- reorganization.
--
-- in most cases the temp table is created with CTAS.
begin;
	insert into t1 select i, i from generate_series(1,10) i;
	select gp_segment_id, * from t1;
 gp_segment_id | c1 | c2 | c3 | c4 
---------------+----+----+----+----
             0 |  1 |  1 |    |   
             0 |  2 |  2 |    |   
             0 |  3 |  3 |    |   
             0 |  4 |  4 |    |   
             0 |  5 |  5 |    |   
             0 |  6 |  6 |    |   
             0 |  7 |  7 |    |   
             0 |  8 |  8 |    |   
             0 |  9 |  9 |    |   
             0 | 10 | 10 |    |   
(10 rows)

	select gp_debug_set_create_table_default_numsegments('full');
 gp_debug_set_create_table_default_numsegments 
-----------------------------------------------
 FULL
(1 row)

	alter table t1 set with (reorganize=true) distributed by (c1);
	select gp_segment_id, * from t1;
 gp_segment_id | c1 | c2 | c3 | c4 
---------------+----+----+----+----
             0 |  1 |  1 |    |   
             0 |  2 |  2 |    |   
             0 |  3 |  3 |    |   
             0 |  4 |  4 |    |   
             0 |  5 |  5 |    |   
             0 |  6 |  6 |    |   
             0 |  7 |  7 |    |   
             0 |  8 |  8 |    |   
             0 |  9 |  9 |    |   
             0 | 10 | 10 |    |   
(10 rows)

abort;
-- but there are also cases the temp table is created with CREATE + INSERT.
-- case 1: with dropped columns
begin;
	insert into t1 select i, i from generate_series(1,10) i;
	select gp_segment_id, * from t1;
 gp_segment_id | c1 | c2 | c3 | c4 
---------------+----+----+----+----
             0 |  1 |  1 |    |   
             0 |  2 |  2 |    |   
             0 |  3 |  3 |    |   
             0 |  4 |  4 |    |   
             0 |  5 |  5 |    |   
             0 |  6 |  6 |    |   
             0 |  7 |  7 |    |   
             0 |  8 |  8 |    |   
             0 |  9 |  9 |    |   
             0 | 10 | 10 |    |   
(10 rows)

	alter table t1 drop column c4;
	select gp_debug_set_create_table_default_numsegments('full');
 gp_debug_set_create_table_default_numsegments 
-----------------------------------------------
 FULL
(1 row)

	alter table t1 set with (reorganize=true) distributed by (c1);
	select gp_segment_id, * from t1;
 gp_segment_id | c1 | c2 | c3 
---------------+----+----+----
             0 |  1 |  1 |   
             0 |  2 |  2 |   
             0 |  3 |  3 |   
             0 |  4 |  4 |   
             0 |  5 |  5 |   
             0 |  6 |  6 |   
             0 |  7 |  7 |   
             0 |  8 |  8 |   
             0 |  9 |  9 |   
             0 | 10 | 10 |   
(10 rows)

abort;
-- case 2: AOCO
begin;
	select gp_debug_set_create_table_default_numsegments('minimal');
 gp_debug_set_create_table_default_numsegments 
-----------------------------------------------
 MINIMAL
(1 row)

	create table t (c1 int, c2 int)
	  with (appendonly=true, orientation=column)
	  distributed by (c1, c2);
	insert into t select i, i from generate_series(1,10) i;
	select gp_segment_id, * from t;
 gp_segment_id | c1 | c2 
---------------+----+----
             0 |  1 |  1
             0 |  2 |  2
             0 |  3 |  3
             0 |  4 |  4
             0 |  5 |  5
             0 |  6 |  6
             0 |  7 |  7
             0 |  8 |  8
             0 |  9 |  9
             0 | 10 | 10
(10 rows)

	select gp_debug_set_create_table_default_numsegments('full');
 gp_debug_set_create_table_default_numsegments 
-----------------------------------------------
 FULL
(1 row)

	alter table t set with (reorganize=true) distributed by (c1);
	select gp_segment_id, * from t;
 gp_segment_id | c1 | c2 
---------------+----+----
             0 |  1 |  1
             0 |  2 |  2
             0 |  3 |  3
             0 |  4 |  4
             0 |  5 |  5
             0 |  6 |  6
             0 |  7 |  7
             0 |  8 |  8
             0 |  9 |  9
             0 | 10 | 10
(10 rows)

abort;
-- case 3: AO + index
begin;
	select gp_debug_set_create_table_default_numsegments('minimal');
 gp_debug_set_create_table_default_numsegments 
-----------------------------------------------
 MINIMAL
(1 row)

	create table t (c1 int, c2 int)
	  with (appendonly=true, orientation=row)
	  distributed by (c1, c2);
	create index ti on t (c2);
	insert into t select i, i from generate_series(1,10) i;
	select gp_segment_id, * from t;
 gp_segment_id | c1 | c2 
---------------+----+----
             0 |  1 |  1
             0 |  2 |  2
             0 |  3 |  3
             0 |  4 |  4
             0 |  5 |  5
             0 |  6 |  6
             0 |  7 |  7
             0 |  8 |  8
             0 |  9 |  9
             0 | 10 | 10
(10 rows)

	select gp_debug_set_create_table_default_numsegments('full');
 gp_debug_set_create_table_default_numsegments 
-----------------------------------------------
 FULL
(1 row)

	alter table t set with (reorganize=true) distributed by (c1);
	select gp_segment_id, * from t;
 gp_segment_id | c1 | c2 
---------------+----+----
             0 |  1 |  1
             0 |  2 |  2
             0 |  3 |  3
             0 |  4 |  4
             0 |  5 |  5
             0 |  6 |  6
             0 |  7 |  7
             0 |  8 |  8
             0 |  9 |  9
             0 | 10 | 10
(10 rows)

abort;
-- restore the analyze information
analyze t1;
select gp_debug_reset_create_table_default_numsegments();
 gp_debug_reset_create_table_default_numsegments 
-------------------------------------------------
 
(1 row)

-- append SingleQE of different sizes
select max(c1) as v, 1 as r from t2 union all select 1 as v, 2 as r;
 v | r 
---+---
   | 1
 1 | 2
(2 rows)

-- append node should use the max numsegments of all the subpaths
begin;
	-- insert enough data to ensure executors got reached on segments
	insert into t1 select i from generate_series(1,100) i;
	insert into t2 select i from generate_series(1,100) i;
	:explain  select * from t2 a join t2 b using(c2)
	union all select * from t1 c join t1 d using(c2) ;
                                                                      QUERY PLAN                                                                       
-------------------------------------------------------------------------------------------------------------------------------------------------------
 Gather Motion 2:1  (slice3; segments: 2)  (cost=6.25..17.52 rows=14 width=28) (actual time=2.573..2.573 rows=0 loops=2)
   ->  Append  (cost=6.25..17.52 rows=5 width=28) (actual time=0.000..4.405 rows=0 loops=1)
         ->  Hash Join  (cost=6.25..11.69 rows=3 width=28) (actual time=0.000..3.522 rows=0 loops=1)
               Hash Cond: (a.c2 = b.c2)
               Extra Text: (seg0)   Hash chain length 0.0 avg, 0 max, using 0 of 262144 buckets.
               ->  Redistribute Motion 2:2  (slice1; segments: 2)  (cost=0.00..5.00 rows=50 width=16) (never executed)
                     Hash Key: a.c2
                     ->  Seq Scan on t2 a  (cost=0.00..3.00 rows=34 width=16) (actual time=0.010..0.019 rows=28 loops=2)
               ->  Hash  (cost=5.00..5.00 rows=34 width=16) (actual time=0.000..1.184 rows=0 loops=1)
                     ->  Redistribute Motion 2:2  (slice2; segments: 2)  (cost=0.00..5.00 rows=50 width=16) (actual time=0.018..0.585 rows=50 loops=2)
                           Hash Key: b.c2
                           ->  Seq Scan on t2 b  (cost=0.00..3.00 rows=34 width=16) (actual time=0.007..0.015 rows=28 loops=2)
         ->  Hash Join  (cost=3.25..5.69 rows=3 width=28) (actual time=0.000..1.404 rows=0 loops=1)
               Hash Cond: (c.c2 = d.c2)
               Extra Text: (seg0)   Hash chain length 0.0 avg, 0 max, using 0 of 262144 buckets.
               ->  Seq Scan on t1 c  (cost=0.00..2.00 rows=34 width=16) (actual time=0.012..0.012 rows=0 loops=2)
               ->  Hash  (cost=2.00..2.00 rows=34 width=16) (actual time=0.000..0.056 rows=0 loops=1)
                     ->  Seq Scan on t1 d  (cost=0.00..2.00 rows=34 width=16) (actual time=0.009..0.022 rows=50 loops=2)
 Planning time: 1.964 ms
   (slice0)    Executor memory: 518K bytes.
   (slice1)    Executor memory: 66K bytes avg x 2 workers, 66K bytes max (seg0).
   (slice2)    Executor memory: 66K bytes avg x 2 workers, 66K bytes max (seg0).
   (slice3)    Executor memory: 3244K bytes avg x 2 workers, 4270K bytes max (seg0).
 Memory used:  128000kB
 Optimizer: Postgres query optimizer
 Execution time: 9.956 ms
(26 rows)

	:explain  select * from t1 a join t1 b using(c2)
	union all select * from t2 c join t2 d using(c2) ;
                                                                      QUERY PLAN                                                                       
-------------------------------------------------------------------------------------------------------------------------------------------------------
 Gather Motion 2:1  (slice3; segments: 2)  (cost=3.25..17.52 rows=14 width=28) (actual time=1.483..1.483 rows=0 loops=2)
   ->  Append  (cost=3.25..17.52 rows=5 width=28) (actual time=0.000..2.279 rows=0 loops=1)
         ->  Hash Join  (cost=3.25..5.69 rows=3 width=28) (actual time=0.000..0.827 rows=0 loops=1)
               Hash Cond: (a.c2 = b.c2)
               Extra Text: (seg0)   Hash chain length 0.0 avg, 0 max, using 0 of 262144 buckets.
               ->  Seq Scan on t1 a  (cost=0.00..2.00 rows=34 width=16) (actual time=0.006..0.006 rows=0 loops=2)
               ->  Hash  (cost=2.00..2.00 rows=34 width=16) (actual time=0.000..0.043 rows=0 loops=1)
                     ->  Seq Scan on t1 b  (cost=0.00..2.00 rows=34 width=16) (actual time=0.004..0.015 rows=50 loops=2)
         ->  Hash Join  (cost=6.25..11.69 rows=3 width=28) (actual time=0.000..2.221 rows=0 loops=1)
               Hash Cond: (c.c2 = d.c2)
               Extra Text: (seg0)   Hash chain length 0.0 avg, 0 max, using 0 of 262144 buckets.
               ->  Redistribute Motion 2:2  (slice1; segments: 2)  (cost=0.00..5.00 rows=50 width=16) (never executed)
                     Hash Key: c.c2
                     ->  Seq Scan on t2 c  (cost=0.00..3.00 rows=34 width=16) (actual time=0.010..0.018 rows=28 loops=2)
               ->  Hash  (cost=5.00..5.00 rows=34 width=16) (actual time=0.000..0.915 rows=0 loops=1)
                     ->  Redistribute Motion 2:2  (slice2; segments: 2)  (cost=0.00..5.00 rows=50 width=16) (actual time=0.266..0.449 rows=50 loops=2)
                           Hash Key: d.c2
                           ->  Seq Scan on t2 d  (cost=0.00..3.00 rows=34 width=16) (actual time=0.006..0.013 rows=28 loops=2)
 Planning time: 1.493 ms
   (slice0)    Executor memory: 518K bytes.
   (slice1)    Executor memory: 66K bytes avg x 2 workers, 66K bytes max (seg0).
   (slice2)    Executor memory: 66K bytes avg x 2 workers, 66K bytes max (seg0).
   (slice3)    Executor memory: 3232K bytes avg x 2 workers, 4258K bytes max (seg0).
 Memory used:  128000kB
 Optimizer: Postgres query optimizer
 Execution time: 3.839 ms
(26 rows)

abort;
-- partitioned table should have the same numsegments for parent and children
-- even in RANDOM mode.
select gp_debug_set_create_table_default_numsegments('random');
 gp_debug_set_create_table_default_numsegments 
-----------------------------------------------
 RANDOM
(1 row)

begin;
	create table t (c1 int, c2 int) distributed by (c1)
	partition by range(c2) (start(0) end(20) every(1));
	-- verify that parent and children have the same numsegments
	select count(a.localoid)
	  from gp_distribution_policy a
	  join pg_class c
	    on a.localoid = c.oid
	   and c.relname like 't_1_prt_%'
	  join gp_distribution_policy b
	    on a.numsegments = b.numsegments
	   and b.localoid = 't'::regclass
	;
 count 
-------
    20
(1 row)

abort;
select gp_debug_reset_create_table_default_numsegments();
 gp_debug_reset_create_table_default_numsegments 
-------------------------------------------------
 
(1 row)

-- verify numsegments in subplans
:explain select * from t1, t2
   where t1.c1 > any (select max(t2.c1) from t2 where t2.c2 = t1.c2)
     and t2.c1 > any (select max(t1.c1) from t1 where t1.c2 = t2.c2);
                                                                         QUERY PLAN                                                                         
------------------------------------------------------------------------------------------------------------------------------------------------------------
 Gather Motion 1:1  (slice4; segments: 1)  (cost=10000000000.00..10182108256.73 rows=1263802500 width=32) (actual time=0.570..0.570 rows=0 loops=2)
   ->  Nested Loop  (cost=10000000000.00..10182108256.73 rows=421267500 width=32) (actual time=0.000..0.053 rows=0 loops=1)
         ->  Seq Scan on t1  (cost=0.00..70516404.55 rows=11850 width=16) (actual time=0.000..0.041 rows=0 loops=1)
               Filter: (SubPlan 1)
               SubPlan 1  (slice4; segments: 1)
                 ->  Aggregate  (cost=991.77..991.78 rows=1 width=4) (never executed)
                       ->  Result  (cost=0.00..989.11 rows=24 width=4) (never executed)
                             Filter: (t2_1.c2 = t1.c2)
                             ->  Materialize  (cost=0.00..989.11 rows=24 width=4) (never executed)
                                   ->  Broadcast Motion 2:1  (slice1; segments: 2)  (cost=0.00..988.75 rows=24 width=4) (never executed)
                                         ->  Seq Scan on t2 t2_1  (cost=0.00..988.75 rows=24 width=4) (actual time=0.000..0.037 rows=0 loops=1)
         ->  Materialize  (cost=0.00..70518359.80 rows=35550 width=16) (never executed)
               ->  Broadcast Motion 2:1  (slice3; segments: 2)  (cost=0.00..70517826.55 rows=35550 width=16) (never executed)
                     ->  Seq Scan on t2  (cost=0.00..70516404.55 rows=11850 width=16) (actual time=0.000..0.087 rows=0 loops=1)
                           Filter: (SubPlan 2)
                           SubPlan 2  (slice3; segments: 2)
                             ->  Aggregate  (cost=991.77..991.78 rows=1 width=4) (never executed)
                                   ->  Result  (cost=0.00..989.11 rows=24 width=4) (never executed)
                                         Filter: (t1_1.c2 = t2.c2)
                                         ->  Materialize  (cost=0.00..989.11 rows=24 width=4) (never executed)
                                               ->  Broadcast Motion 1:2  (slice2; segments: 1)  (cost=0.00..988.75 rows=24 width=4) (never executed)
                                                     ->  Seq Scan on t1 t1_1  (cost=0.00..988.75 rows=24 width=4) (actual time=0.000..0.174 rows=0 loops=1)
   (slice0)    Executor memory: 514K bytes.
   (slice1)    Executor memory: 66K bytes avg x 3 workers, 66K bytes max (seg0).
   (slice2)    Executor memory: 66K bytes avg x 3 workers, 66K bytes max (seg0).
   (slice3)    Executor memory: 98K bytes avg x 3 workers, 98K bytes max (seg0).
   (slice4)    Executor memory: 129K bytes avg x 3 workers, 129K bytes max (seg0).
 Memory used:  128000kB
 Optimizer: Postgres query optimizer
 Total runtime: 14.189 ms
(30 rows)

--
-- It is used to test this case:
--   A: replicated table, distributed on 2 segments
--   B: replicated table, distributed on 1 segments
--   UPDATE A SET XXX FROM B WHERE XXX;
-- We have to add a broadcast motion on B so that A can update/delete correctly.
--
begin;
    insert into d1 select i,i,i,i from generate_series(1,2) i;
    insert into d2 select i,i,i,i from generate_series(1,3) i;
    explain update d2 a set c3=b.c3 from d1 b returning *;
                                                QUERY PLAN                                                
----------------------------------------------------------------------------------------------------------
 Explicit Gather Motion 2:1  (slice2; segments: 2)  (cost=10000000000.00..10000000002.08 rows=4 width=44)
   ->  Update on d2 a  (cost=10000000000.00..10000000002.08 rows=2 width=44)
         ->  Nested Loop  (cost=10000000000.00..10000000002.08 rows=2 width=44)
               ->  Seq Scan on d2 a  (cost=0.00..1.00 rows=1 width=22)
               ->  Materialize  (cost=0.00..1.05 rows=1 width=22)
                     ->  Broadcast Motion 1:2  (slice1; segments: 1)  (cost=0.00..1.04 rows=3 width=22)
                           ->  Seq Scan on d1 b  (cost=0.00..1.00 rows=1 width=22)
 Planning time: 0.915 ms
 Optimizer: Postgres query optimizer
(9 rows)

    update d2 a set c3=b.c3 from d1 b returning *;
 c1 | c2 | c3 | c4 | c1 | c2 | c3 | c4 
----+----+----+----+----+----+----+----
  1 |  1 |  1 |  1 |  1 |  1 |  1 |  1
  2 |  2 |  1 |  2 |  1 |  1 |  1 |  1
  3 |  3 |  1 |  3 |  1 |  1 |  1 |  1
(3 rows)

    explain update d1 a set c3=b.c3 from d2 b returning *;
                                                QUERY PLAN                                                
----------------------------------------------------------------------------------------------------------
 Explicit Gather Motion 1:1  (slice1; segments: 1)  (cost=10000000000.00..10000000002.01 rows=4 width=44)
   ->  Update on d1 a  (cost=10000000000.00..10000000002.01 rows=2 width=44)
         ->  Nested Loop  (cost=10000000000.00..10000000002.01 rows=2 width=44)
               ->  Seq Scan on d1 a  (cost=0.00..1.00 rows=1 width=22)
               ->  Seq Scan on d2 b  (cost=0.00..1.00 rows=1 width=22)
 Planning time: 0.799 ms
 Optimizer: Postgres query optimizer
(7 rows)

    update d1 a set c3=b.c3 from d2 b returning *;
 c1 | c2 | c3 | c4 | c1 | c2 | c3 | c4 
----+----+----+----+----+----+----+----
  1 |  1 |  1 |  1 |  1 |  1 |  1 |  1
  2 |  2 |  1 |  2 |  1 |  1 |  1 |  1
(2 rows)

abort;
-- restore the analyze information
analyze d1;
analyze d2;
--
-- create table: LIKE, INHERITS and DISTRIBUTED BY
--
-- tables are always created with DEFAULT as numsegments,
-- no matter there is LIKE, INHERITS or DISTRIBUTED BY.
select gp_debug_set_create_table_default_numsegments(2);
 gp_debug_set_create_table_default_numsegments 
-----------------------------------------------
 2
(1 row)

-- none of the clauses
create table t ();
NOTICE:  Table doesn't have 'DISTRIBUTED BY' clause, and no column type is suitable for a distribution key. Creating a NULL policy entry.
select localoid::regclass, distkey, policytype, numsegments
	from gp_distribution_policy where localoid in ('t'::regclass);
 localoid | distkey | policytype | numsegments 
----------+---------+------------+-------------
 t        |         | p          |           2
(1 row)

drop table t;
-- DISTRIBUTED BY only
create table t () distributed randomly;
select localoid::regclass, distkey, policytype, numsegments
	from gp_distribution_policy where localoid in ('t'::regclass);
 localoid | distkey | policytype | numsegments 
----------+---------+------------+-------------
 t        |         | p          |           2
(1 row)

drop table t;
-- INHERITS only
create table t () inherits (t2);
NOTICE:  table has parent, setting distribution columns to match parent table
select localoid::regclass, distkey, policytype, numsegments
	from gp_distribution_policy where localoid in ('t'::regclass);
 localoid | distkey | policytype | numsegments 
----------+---------+------------+-------------
 t        | 1 2     | p          |           2
(1 row)

drop table t;
-- LIKE only
create table t (like d1);
NOTICE:  table doesn't have 'DISTRIBUTED BY' clause, defaulting to distribution columns from LIKE table
select localoid::regclass, distkey, policytype, numsegments
	from gp_distribution_policy where localoid in ('t'::regclass);
 localoid | distkey | policytype | numsegments 
----------+---------+------------+-------------
 t        |         | r          |           2
(1 row)

drop table t;
-- DISTRIBUTED BY + INHERITS
create table t () inherits (t2) distributed randomly;
select localoid::regclass, distkey, policytype, numsegments
	from gp_distribution_policy where localoid in ('t'::regclass);
 localoid | distkey | policytype | numsegments 
----------+---------+------------+-------------
 t        |         | p          |           2
(1 row)

drop table t;
-- DISTRIBUTED BY + LIKE
create table t (like d1) distributed randomly;
select localoid::regclass, distkey, policytype, numsegments
	from gp_distribution_policy where localoid in ('t'::regclass);
 localoid | distkey | policytype | numsegments 
----------+---------+------------+-------------
 t        |         | p          |           2
(1 row)

drop table t;
-- INHERITS + LIKE
create table t (like d1) inherits (t2);
NOTICE:  table has parent, setting distribution columns to match parent table
NOTICE:  merging column "c1" with inherited definition
NOTICE:  merging column "c2" with inherited definition
NOTICE:  merging column "c3" with inherited definition
NOTICE:  merging column "c4" with inherited definition
select localoid::regclass, distkey, policytype, numsegments
	from gp_distribution_policy where localoid in ('t'::regclass);
 localoid | distkey | policytype | numsegments 
----------+---------+------------+-------------
 t        | 1 2     | p          |           2
(1 row)

drop table t;
-- DISTRIBUTED BY + INHERITS + LIKE
create table t (like d1) inherits (t2) distributed randomly;
NOTICE:  merging column "c1" with inherited definition
NOTICE:  merging column "c2" with inherited definition
NOTICE:  merging column "c3" with inherited definition
NOTICE:  merging column "c4" with inherited definition
select localoid::regclass, distkey, policytype, numsegments
	from gp_distribution_policy where localoid in ('t'::regclass);
 localoid | distkey | policytype | numsegments 
----------+---------+------------+-------------
 t        |         | p          |           2
(1 row)

drop table t;
-- INHERITS from multiple parents
create table t () inherits (r1, t2);
NOTICE:  table has parent, setting distribution columns to match parent table
NOTICE:  merging multiple inherited definitions of column "c1"
NOTICE:  merging multiple inherited definitions of column "c2"
NOTICE:  merging multiple inherited definitions of column "c3"
NOTICE:  merging multiple inherited definitions of column "c4"
select localoid::regclass, distkey, policytype, numsegments
	from gp_distribution_policy where localoid in ('t'::regclass);
 localoid | distkey | policytype | numsegments 
----------+---------+------------+-------------
 t        |         | p          |           2
(1 row)

drop table t;
-- DISTRIBUTED BY + INHERITS from multiple parents
create table t () inherits (r1, t2) distributed by (c1);
NOTICE:  merging multiple inherited definitions of column "c1"
NOTICE:  merging multiple inherited definitions of column "c2"
NOTICE:  merging multiple inherited definitions of column "c3"
NOTICE:  merging multiple inherited definitions of column "c4"
select localoid::regclass, distkey, policytype, numsegments
	from gp_distribution_policy where localoid in ('t'::regclass);
 localoid | distkey | policytype | numsegments 
----------+---------+------------+-------------
 t        | 1       | p          |           2
(1 row)

drop table t;
select gp_debug_reset_create_table_default_numsegments();
 gp_debug_reset_create_table_default_numsegments 
-------------------------------------------------
 
(1 row)

-- CTAS set numsegments with DEFAULT,
-- let it be a fixed value to get stable output
select gp_debug_set_create_table_default_numsegments('full');
 gp_debug_set_create_table_default_numsegments 
-----------------------------------------------
 FULL
(1 row)

create table t as table t1;
NOTICE:  Table doesn't have 'DISTRIBUTED BY' clause -- Using column(s) named 'c1, c2' as the Greenplum Database data distribution key for this table.
HINT:  The 'DISTRIBUTED BY' clause determines the distribution of data. Make sure column(s) chosen are the optimal data distribution key to minimize skew.
select localoid::regclass, distkey, policytype, numsegments
	from gp_distribution_policy where localoid in ('t'::regclass);
 localoid | distkey | policytype | numsegments 
----------+---------+------------+-------------
 t        | 1 2     | p          |           3
(1 row)

drop table t;
create table t as select * from t1;
NOTICE:  Table doesn't have 'DISTRIBUTED BY' clause -- Using column(s) named 'c1, c2' as the Greenplum Database data distribution key for this table.
HINT:  The 'DISTRIBUTED BY' clause determines the distribution of data. Make sure column(s) chosen are the optimal data distribution key to minimize skew.
select localoid::regclass, distkey, policytype, numsegments
	from gp_distribution_policy where localoid in ('t'::regclass);
 localoid | distkey | policytype | numsegments 
----------+---------+------------+-------------
 t        | 1 2     | p          |           3
(1 row)

drop table t;
create table t as select * from t1 distributed by (c1, c2);
select localoid::regclass, distkey, policytype, numsegments
	from gp_distribution_policy where localoid in ('t'::regclass);
 localoid | distkey | policytype | numsegments 
----------+---------+------------+-------------
 t        | 1 2     | p          |           3
(1 row)

drop table t;
create table t as select * from t1 distributed replicated;
select localoid::regclass, distkey, policytype, numsegments
	from gp_distribution_policy where localoid in ('t'::regclass);
 localoid | distkey | policytype | numsegments 
----------+---------+------------+-------------
 t        |         | r          |           3
(1 row)

drop table t;
create table t as select * from t1 distributed randomly;
select localoid::regclass, distkey, policytype, numsegments
	from gp_distribution_policy where localoid in ('t'::regclass);
 localoid | distkey | policytype | numsegments 
----------+---------+------------+-------------
 t        |         | p          |           3
(1 row)

drop table t;
select * into table t from t1;
NOTICE:  Table doesn't have 'DISTRIBUTED BY' clause -- Using column(s) named 'c1, c2' as the Greenplum Database data distribution key for this table.
HINT:  The 'DISTRIBUTED BY' clause determines the distribution of data. Make sure column(s) chosen are the optimal data distribution key to minimize skew.
select localoid::regclass, distkey, policytype, numsegments
	from gp_distribution_policy where localoid in ('t'::regclass);
 localoid | distkey | policytype | numsegments 
----------+---------+------------+-------------
 t        | 1 2     | p          |           3
(1 row)

drop table t;
select gp_debug_reset_create_table_default_numsegments();
 gp_debug_reset_create_table_default_numsegments 
-------------------------------------------------
 
(1 row)

--
-- alter table
--
-- numsegments should not be changed
select gp_debug_set_create_table_default_numsegments(1);
 gp_debug_set_create_table_default_numsegments 
-----------------------------------------------
 1
(1 row)

create table t (like t1);
NOTICE:  table doesn't have 'DISTRIBUTED BY' clause, defaulting to distribution columns from LIKE table
select localoid::regclass, distkey, policytype, numsegments
	from gp_distribution_policy where localoid in ('t'::regclass);
 localoid | distkey | policytype | numsegments 
----------+---------+------------+-------------
 t        | 1 2     | p          |           1
(1 row)

alter table t set distributed replicated;
select localoid::regclass, distkey, policytype, numsegments
	from gp_distribution_policy where localoid in ('t'::regclass);
 localoid | distkey | policytype | numsegments 
----------+---------+------------+-------------
 t        |         | r          |           1
(1 row)

alter table t set distributed randomly;
select localoid::regclass, distkey, policytype, numsegments
	from gp_distribution_policy where localoid in ('t'::regclass);
 localoid | distkey | policytype | numsegments 
----------+---------+------------+-------------
 t        |         | p          |           1
(1 row)

alter table t set distributed by (c1, c2);
select localoid::regclass, distkey, policytype, numsegments
	from gp_distribution_policy where localoid in ('t'::regclass);
 localoid | distkey | policytype | numsegments 
----------+---------+------------+-------------
 t        | 1 2     | p          |           1
(1 row)

alter table t add column c10 int;
select localoid::regclass, distkey, policytype, numsegments
	from gp_distribution_policy where localoid in ('t'::regclass);
 localoid | distkey | policytype | numsegments 
----------+---------+------------+-------------
 t        | 1 2     | p          |           1
(1 row)

alter table t alter column c10 type text;
select localoid::regclass, distkey, policytype, numsegments
	from gp_distribution_policy where localoid in ('t'::regclass);
 localoid | distkey | policytype | numsegments 
----------+---------+------------+-------------
 t        | 1 2     | p          |           1
(1 row)

drop table t;
select gp_debug_reset_create_table_default_numsegments();
 gp_debug_reset_create_table_default_numsegments 
-------------------------------------------------
 
(1 row)

-- below join cases cover all the combinations of
--
--     select * from {t,d,r}{1,2} a
--      {left,} join {t,d,r}{1,2} b
--      using (c1{',c2',});
--
-- there might be some duplicated ones, like 't1 join d1' and 'd1 join t1',
-- or 'd1 join r1 using (c1)' and 'd1 join r1 using (c1, c2)', this is because
-- we generate them via scripts and do not clean them up manually.
--
-- please do not remove the duplicated ones as we care about the motion
-- direction of different join orders, e.g. 't2 join t1' and 't1 join t2'
-- should both distribute t2 to t1.
--
-- JOIN
--
-- x1 join y1
:explain select * from t1 a join t1 b using (c1);
                                                             QUERY PLAN                                                              
-------------------------------------------------------------------------------------------------------------------------------------
 Gather Motion 1:1  (slice1; segments: 1)  (cost=1699.75..685141.85 rows=5055210 width=28) (actual time=0.239..0.239 rows=0 loops=2)
   ->  Hash Join  (cost=1699.75..685141.85 rows=1685070 width=28) (actual time=0.000..0.089 rows=0 loops=1)
         Hash Cond: (a.c1 = b.c1)
         ->  Seq Scan on t1 a  (cost=0.00..811.00 rows=23700 width=16) (actual time=0.000..0.088 rows=0 loops=1)
         ->  Hash  (cost=811.00..811.00 rows=23700 width=16) (never executed)
               ->  Seq Scan on t1 b  (cost=0.00..811.00 rows=23700 width=16) (never executed)
   (slice0)    Executor memory: 386K bytes.
   (slice1)    Executor memory: 66K bytes avg x 3 workers, 66K bytes max (seg0).
   (slice2)    Executor memory: 4170K bytes avg x 3 workers, 4170K bytes max (seg0).
 Memory used:  128000kB
 Optimizer: Postgres query optimizer
 Total runtime: 6.541 ms
(13 rows)

:explain select * from t1 a join t1 b using (c1, c2);
                                                            QUERY PLAN                                                             
-----------------------------------------------------------------------------------------------------------------------------------
 Gather Motion 1:1  (slice1; segments: 1)  (cost=1877.50..1266897.05 rows=5056 width=24) (actual time=0.247..0.247 rows=0 loops=2)
   ->  Hash Join  (cost=1877.50..1266897.05 rows=1686 width=24) (actual time=0.000..0.018 rows=0 loops=1)
         Hash Cond: a.c1 = b.c1 AND a.c2 = b.c2
         ->  Seq Scan on t1 a  (cost=0.00..811.00 rows=23700 width=16) (actual time=0.000..0.017 rows=0 loops=1)
         ->  Hash  (cost=811.00..811.00 rows=23700 width=16) (never executed)
               ->  Seq Scan on t1 b  (cost=0.00..811.00 rows=23700 width=16) (never executed)
   (slice0)    Executor memory: 386K bytes.
   (slice1)    Executor memory: 78K bytes avg x 3 workers, 78K bytes max (seg0).
 Memory used:  128000kB
 Optimizer: Postgres query optimizer
 Total runtime: 1.148 ms
(11 rows)

:explain select * from t1 a join d1 b using (c1);
                                                             QUERY PLAN                                                              
-------------------------------------------------------------------------------------------------------------------------------------
 Gather Motion 1:1  (slice1; segments: 1)  (cost=1699.75..685141.85 rows=5055210 width=28) (actual time=0.239..0.239 rows=0 loops=2)
   ->  Hash Join  (cost=1699.75..685141.85 rows=1685070 width=28) (actual time=0.000..0.018 rows=0 loops=1)
         Hash Cond: a.c1 = b.c1
         ->  Seq Scan on t1 a  (cost=0.00..811.00 rows=23700 width=16) (actual time=0.000..0.017 rows=0 loops=1)
         ->  Hash  (cost=811.00..811.00 rows=23700 width=16) (never executed)
               ->  Seq Scan on d1 b  (cost=0.00..811.00 rows=23700 width=16) (never executed)
   (slice0)    Executor memory: 386K bytes.
   (slice1)    Executor memory: 98K bytes avg x 3 workers, 98K bytes max (seg0).
 Memory used:  128000kB
 Optimizer: Postgres query optimizer
 Total runtime: 1.205 ms
(11 rows)

:explain select * from t1 a join d1 b using (c1, c2);
                                                            QUERY PLAN                                                             
-----------------------------------------------------------------------------------------------------------------------------------
 Gather Motion 1:1  (slice1; segments: 1)  (cost=1877.50..1266897.05 rows=5056 width=24) (actual time=0.179..0.179 rows=0 loops=2)
   ->  Hash Join  (cost=1877.50..1266897.05 rows=1686 width=24) (actual time=0.000..0.016 rows=0 loops=1)
         Hash Cond: a.c1 = b.c1 AND a.c2 = b.c2
         ->  Seq Scan on t1 a  (cost=0.00..811.00 rows=23700 width=16) (actual time=0.000..0.015 rows=0 loops=1)
         ->  Hash  (cost=811.00..811.00 rows=23700 width=16) (never executed)
               ->  Seq Scan on d1 b  (cost=0.00..811.00 rows=23700 width=16) (never executed)
   (slice0)    Executor memory: 386K bytes.
   (slice1)    Executor memory: 98K bytes avg x 3 workers, 98K bytes max (seg0).
 Memory used:  128000kB
 Optimizer: Postgres query optimizer
 Total runtime: 1.027 ms
(11 rows)

:explain select * from t1 a join r1 b using (c1);
                                                             QUERY PLAN                                                              
-------------------------------------------------------------------------------------------------------------------------------------
 Gather Motion 1:1  (slice1; segments: 1)  (cost=1699.75..685141.85 rows=5055210 width=28) (actual time=0.238..0.238 rows=0 loops=2)
   ->  Hash Join  (cost=1699.75..685141.85 rows=1685070 width=28) (actual time=0.000..0.013 rows=0 loops=1)
         Hash Cond: (a.c1 = b.c1)
         ->  Seq Scan on t1 a  (cost=0.00..811.00 rows=23700 width=16) (actual time=0.000..0.013 rows=0 loops=1)
         ->  Hash  (cost=811.00..811.00 rows=23700 width=16) (never executed)
               ->  Seq Scan on r1 b  (cost=0.00..811.00 rows=23700 width=16) (never executed)
   (slice0)    Executor memory: 386K bytes.
   (slice1)    Executor memory: 66K bytes avg x 3 workers, 66K bytes max (seg0).
   (slice2)    Executor memory: 4170K bytes avg x 3 workers, 4170K bytes max (seg0).
 Memory used:  128000kB
 Optimizer: Postgres query optimizer
 Total runtime: 4.919 ms
(13 rows)

:explain select * from t1 a join r1 b using (c1, c2);
                                                            QUERY PLAN                                                             
-----------------------------------------------------------------------------------------------------------------------------------
 Gather Motion 1:1  (slice1; segments: 1)  (cost=1877.50..1266897.05 rows=5056 width=24) (actual time=0.170..0.170 rows=0 loops=2)
   ->  Hash Join  (cost=1877.50..1266897.05 rows=1686 width=24) (actual time=0.000..0.013 rows=0 loops=1)
         Hash Cond: ((a.c1 = b.c1) AND (a.c2 = b.c2))
         ->  Seq Scan on t1 a  (cost=0.00..811.00 rows=23700 width=16) (actual time=0.000..0.013 rows=0 loops=1)
         ->  Hash  (cost=811.00..811.00 rows=23700 width=16) (never executed)
               ->  Seq Scan on r1 b  (cost=0.00..811.00 rows=23700 width=16) (never executed)
   (slice0)    Executor memory: 386K bytes.
   (slice1)    Executor memory: 66K bytes avg x 3 workers, 66K bytes max (seg0).
   (slice2)    Executor memory: 4182K bytes avg x 3 workers, 4182K bytes max (seg0).
 Memory used:  128000kB
 Optimizer: Postgres query optimizer
 Total runtime: 4.182 ms
(14 rows)

:explain select * from d1 a join t1 b using (c1);
                                                             QUERY PLAN                                                              
-------------------------------------------------------------------------------------------------------------------------------------
 Gather Motion 1:1  (slice1; segments: 1)  (cost=1699.75..685141.85 rows=5055210 width=28) (actual time=0.205..0.205 rows=0 loops=2)
   ->  Hash Join  (cost=1699.75..685141.85 rows=1685070 width=28) (actual time=0.000..0.103 rows=0 loops=1)
         Hash Cond: a.c1 = b.c1
         ->  Seq Scan on d1 a  (cost=0.00..811.00 rows=23700 width=16) (actual time=0.000..0.103 rows=0 loops=1)
         ->  Hash  (cost=811.00..811.00 rows=23700 width=16) (never executed)
               ->  Seq Scan on t1 b  (cost=0.00..811.00 rows=23700 width=16) (never executed)
   (slice0)    Executor memory: 386K bytes.
   (slice1)    Executor memory: 98K bytes avg x 3 workers, 98K bytes max (seg0).
 Memory used:  128000kB
 Optimizer: Postgres query optimizer
 Total runtime: 1.165 ms
(11 rows)

:explain select * from d1 a join t1 b using (c1, c2);
                                                            QUERY PLAN                                                             
-----------------------------------------------------------------------------------------------------------------------------------
 Gather Motion 1:1  (slice1; segments: 1)  (cost=1877.50..1266897.05 rows=5056 width=24) (actual time=0.181..0.181 rows=0 loops=2)
   ->  Hash Join  (cost=1877.50..1266897.05 rows=1686 width=24) (actual time=0.000..0.017 rows=0 loops=1)
         Hash Cond: a.c1 = b.c1 AND a.c2 = b.c2
         ->  Seq Scan on d1 a  (cost=0.00..811.00 rows=23700 width=16) (actual time=0.000..0.017 rows=0 loops=1)
         ->  Hash  (cost=811.00..811.00 rows=23700 width=16) (never executed)
               ->  Seq Scan on t1 b  (cost=0.00..811.00 rows=23700 width=16) (never executed)
   (slice0)    Executor memory: 386K bytes.
   (slice1)    Executor memory: 98K bytes avg x 3 workers, 98K bytes max (seg0).
 Memory used:  128000kB
 Optimizer: Postgres query optimizer
 Total runtime: 1.223 ms
(11 rows)

:explain select * from d1 a join d1 b using (c1);
                                                             QUERY PLAN                                                              
-------------------------------------------------------------------------------------------------------------------------------------
 Gather Motion 1:1  (slice1; segments: 1)  (cost=1699.75..685141.85 rows=5055210 width=28) (actual time=0.197..0.197 rows=0 loops=2)
   ->  Hash Join  (cost=1699.75..685141.85 rows=1685070 width=28) (actual time=0.000..0.015 rows=0 loops=1)
         Hash Cond: a.c1 = b.c1
         ->  Seq Scan on d1 a  (cost=0.00..811.00 rows=23700 width=16) (actual time=0.000..0.015 rows=0 loops=1)
         ->  Hash  (cost=811.00..811.00 rows=23700 width=16) (never executed)
               ->  Seq Scan on d1 b  (cost=0.00..811.00 rows=23700 width=16) (never executed)
   (slice0)    Executor memory: 386K bytes.
   (slice1)    Executor memory: 78K bytes (seg0).
 Memory used:  128000kB
 Optimizer: Postgres query optimizer
 Total runtime: 1.053 ms
(11 rows)

:explain select * from d1 a join d1 b using (c1, c2);
                                                            QUERY PLAN                                                             
-----------------------------------------------------------------------------------------------------------------------------------
 Gather Motion 1:1  (slice1; segments: 1)  (cost=1877.50..1266897.05 rows=5056 width=24) (actual time=0.198..0.198 rows=0 loops=2)
   ->  Hash Join  (cost=1877.50..1266897.05 rows=1686 width=24) (actual time=0.000..0.015 rows=0 loops=1)
         Hash Cond: a.c1 = b.c1 AND a.c2 = b.c2
         ->  Seq Scan on d1 a  (cost=0.00..811.00 rows=23700 width=16) (actual time=0.000..0.015 rows=0 loops=1)
         ->  Hash  (cost=811.00..811.00 rows=23700 width=16) (never executed)
               ->  Seq Scan on d1 b  (cost=0.00..811.00 rows=23700 width=16) (never executed)
   (slice0)    Executor memory: 386K bytes.
   (slice1)    Executor memory: 78K bytes (seg0).
 Memory used:  128000kB
 Optimizer: Postgres query optimizer
 Total runtime: 1.028 ms
(11 rows)

:explain select * from d1 a join r1 b using (c1);
                                                             QUERY PLAN                                                              
-------------------------------------------------------------------------------------------------------------------------------------
 Gather Motion 1:1  (slice1; segments: 1)  (cost=1699.75..685141.85 rows=5055210 width=28) (actual time=0.233..0.233 rows=0 loops=2)
   ->  Hash Join  (cost=1699.75..685141.85 rows=1685070 width=28) (actual time=0.000..0.017 rows=0 loops=1)
         Hash Cond: a.c1 = b.c1
         ->  Seq Scan on d1 a  (cost=0.00..811.00 rows=23700 width=16) (actual time=0.000..0.017 rows=0 loops=1)
         ->  Hash  (cost=811.00..811.00 rows=23700 width=16) (never executed)
               ->  Seq Scan on r1 b  (cost=0.00..811.00 rows=23700 width=16) (never executed)
   (slice0)    Executor memory: 386K bytes.
   (slice1)    Executor memory: 98K bytes avg x 3 workers, 98K bytes max (seg0).
 Memory used:  128000kB
 Optimizer: Postgres query optimizer
 Total runtime: 1.135 ms
(11 rows)

:explain select * from d1 a join r1 b using (c1, c2);
                                                            QUERY PLAN                                                             
-----------------------------------------------------------------------------------------------------------------------------------
 Gather Motion 1:1  (slice1; segments: 1)  (cost=1877.50..1266897.05 rows=5056 width=24) (actual time=0.179..0.179 rows=0 loops=2)
   ->  Hash Join  (cost=1877.50..1266897.05 rows=1686 width=24) (actual time=0.000..0.017 rows=0 loops=1)
         Hash Cond: a.c1 = b.c1 AND a.c2 = b.c2
         ->  Seq Scan on d1 a  (cost=0.00..811.00 rows=23700 width=16) (actual time=0.000..0.017 rows=0 loops=1)
         ->  Hash  (cost=811.00..811.00 rows=23700 width=16) (never executed)
               ->  Seq Scan on r1 b  (cost=0.00..811.00 rows=23700 width=16) (never executed)
   (slice0)    Executor memory: 386K bytes.
   (slice1)    Executor memory: 98K bytes avg x 3 workers, 98K bytes max (seg0).
 Memory used:  128000kB
 Optimizer: Postgres query optimizer
 Total runtime: 1.070 ms
(11 rows)

:explain select * from r1 a join t1 b using (c1);
                                                             QUERY PLAN                                                              
-------------------------------------------------------------------------------------------------------------------------------------
 Gather Motion 1:1  (slice1; segments: 1)  (cost=1699.75..685141.85 rows=5055210 width=28) (actual time=0.222..0.222 rows=0 loops=2)
   ->  Hash Join  (cost=1699.75..685141.85 rows=1685070 width=28) (actual time=0.000..0.014 rows=0 loops=1)
         Hash Cond: (a.c1 = b.c1)
         ->  Seq Scan on r1 a  (cost=0.00..811.00 rows=23700 width=16) (actual time=0.000..0.014 rows=0 loops=1)
         ->  Hash  (cost=811.00..811.00 rows=23700 width=16) (never executed)
               ->  Seq Scan on t1 b  (cost=0.00..811.00 rows=23700 width=16) (never executed)
   (slice0)    Executor memory: 386K bytes.
   (slice1)    Executor memory: 66K bytes avg x 3 workers, 66K bytes max (seg0).
   (slice2)    Executor memory: 4170K bytes avg x 3 workers, 4170K bytes max (seg0).
 Memory used:  128000kB
 Optimizer: Postgres query optimizer
 Total runtime: 6.008 ms
(13 rows)

:explain select * from r1 a join t1 b using (c1, c2);
                                                            QUERY PLAN                                                             
-----------------------------------------------------------------------------------------------------------------------------------
 Gather Motion 1:1  (slice1; segments: 1)  (cost=1877.50..1266897.05 rows=5056 width=24) (actual time=0.210..0.210 rows=0 loops=2)
   ->  Hash Join  (cost=1877.50..1266897.05 rows=1686 width=24) (actual time=0.000..0.149 rows=0 loops=1)
         Hash Cond: ((a.c1 = b.c1) AND (a.c2 = b.c2))
         ->  Seq Scan on r1 a  (cost=0.00..811.00 rows=23700 width=16) (actual time=0.000..0.148 rows=0 loops=1)
         ->  Hash  (cost=811.00..811.00 rows=23700 width=16) (never executed)
               ->  Seq Scan on t1 b  (cost=0.00..811.00 rows=23700 width=16) (never executed)
   (slice0)    Executor memory: 386K bytes.
   (slice1)    Executor memory: 66K bytes avg x 3 workers, 66K bytes max (seg0).
   (slice2)    Executor memory: 4182K bytes avg x 3 workers, 4182K bytes max (seg0).
 Memory used:  128000kB
 Optimizer: Postgres query optimizer
 Total runtime: 4.638 ms
(14 rows)

:explain select * from r1 a join d1 b using (c1);
                                                             QUERY PLAN                                                              
-------------------------------------------------------------------------------------------------------------------------------------
 Gather Motion 1:1  (slice1; segments: 1)  (cost=1699.75..685141.85 rows=5055210 width=28) (actual time=0.200..0.200 rows=0 loops=2)
   ->  Hash Join  (cost=1699.75..685141.85 rows=1685070 width=28) (actual time=0.000..0.017 rows=0 loops=1)
         Hash Cond: a.c1 = b.c1
         ->  Seq Scan on r1 a  (cost=0.00..811.00 rows=23700 width=16) (actual time=0.000..0.017 rows=0 loops=1)
         ->  Hash  (cost=811.00..811.00 rows=23700 width=16) (never executed)
               ->  Seq Scan on d1 b  (cost=0.00..811.00 rows=23700 width=16) (never executed)
   (slice0)    Executor memory: 386K bytes.
   (slice1)    Executor memory: 98K bytes avg x 3 workers, 98K bytes max (seg0).
 Memory used:  128000kB
 Optimizer: Postgres query optimizer
 Total runtime: 1.094 ms
(11 rows)

:explain select * from r1 a join d1 b using (c1, c2);
                                                            QUERY PLAN                                                             
-----------------------------------------------------------------------------------------------------------------------------------
 Gather Motion 1:1  (slice1; segments: 1)  (cost=1877.50..1266897.05 rows=5056 width=24) (actual time=0.200..0.200 rows=0 loops=2)
   ->  Hash Join  (cost=1877.50..1266897.05 rows=1686 width=24) (actual time=0.000..0.032 rows=0 loops=1)
         Hash Cond: a.c1 = b.c1 AND a.c2 = b.c2
         ->  Seq Scan on r1 a  (cost=0.00..811.00 rows=23700 width=16) (actual time=0.000..0.031 rows=0 loops=1)
         ->  Hash  (cost=811.00..811.00 rows=23700 width=16) (never executed)
               ->  Seq Scan on d1 b  (cost=0.00..811.00 rows=23700 width=16) (never executed)
   (slice0)    Executor memory: 386K bytes.
   (slice1)    Executor memory: 98K bytes avg x 3 workers, 98K bytes max (seg0).
 Memory used:  128000kB
 Optimizer: Postgres query optimizer
 Total runtime: 1.085 ms
(11 rows)

:explain select * from r1 a join r1 b using (c1);
                                                             QUERY PLAN                                                              
-------------------------------------------------------------------------------------------------------------------------------------
 Gather Motion 1:1  (slice1; segments: 1)  (cost=1699.75..685141.85 rows=5055210 width=28) (actual time=0.220..0.220 rows=0 loops=2)
   ->  Hash Join  (cost=1699.75..685141.85 rows=1685070 width=28) (actual time=0.000..0.013 rows=0 loops=1)
         Hash Cond: (a.c1 = b.c1)
         ->  Seq Scan on r1 a  (cost=0.00..811.00 rows=23700 width=16) (actual time=0.000..0.013 rows=0 loops=1)
         ->  Hash  (cost=811.00..811.00 rows=23700 width=16) (never executed)
               ->  Seq Scan on r1 b  (cost=0.00..811.00 rows=23700 width=16) (never executed)
   (slice0)    Executor memory: 386K bytes.
   (slice1)    Executor memory: 66K bytes avg x 3 workers, 66K bytes max (seg0).
   (slice2)    Executor memory: 4170K bytes avg x 3 workers, 4170K bytes max (seg0).
 Memory used:  128000kB
 Optimizer: Postgres query optimizer
 Total runtime: 4.583 ms
(13 rows)

:explain select * from r1 a join r1 b using (c1, c2);
                                                            QUERY PLAN                                                             
-----------------------------------------------------------------------------------------------------------------------------------
 Gather Motion 1:1  (slice1; segments: 1)  (cost=1877.50..1266897.05 rows=5056 width=24) (actual time=0.198..0.198 rows=0 loops=2)
   ->  Hash Join  (cost=1877.50..1266897.05 rows=1686 width=24) (actual time=0.000..0.013 rows=0 loops=1)
         Hash Cond: ((a.c1 = b.c1) AND (a.c2 = b.c2))
         ->  Seq Scan on r1 a  (cost=0.00..811.00 rows=23700 width=16) (actual time=0.000..0.013 rows=0 loops=1)
         ->  Hash  (cost=811.00..811.00 rows=23700 width=16) (never executed)
               ->  Seq Scan on r1 b  (cost=0.00..811.00 rows=23700 width=16) (never executed)
   (slice0)    Executor memory: 386K bytes.
   (slice1)    Executor memory: 66K bytes avg x 3 workers, 66K bytes max (seg0).
   (slice2)    Executor memory: 4170K bytes avg x 3 workers, 4170K bytes max (seg0).
 Memory used:  128000kB
 Optimizer: Postgres query optimizer
 Total runtime: 4.447 ms
(13 rows)

-- x1 join y2
:explain select * from t1 a join t2 b using (c1);
                                                              QUERY PLAN                                                              
--------------------------------------------------------------------------------------------------------------------------------------
 Gather Motion 1:1  (slice2; segments: 1)  (cost=1699.75..1952143.85 rows=5055210 width=28) (actual time=1.482..1.482 rows=0 loops=2)
   ->  Hash Join  (cost=1699.75..1952143.85 rows=1685070 width=28) (actual time=0.000..2.550 rows=0 loops=1)
         Hash Cond: b.c1 = a.c1
         ->  Broadcast Motion 2:1  (slice1; segments: 2)  (cost=0.00..3655.00 rows=71100 width=16) (never executed)
               ->  Seq Scan on t2 b  (cost=0.00..811.00 rows=23700 width=16) (actual time=0.000..0.011 rows=0 loops=1)
         ->  Hash  (cost=811.00..811.00 rows=23700 width=16) (actual time=0.000..0.055 rows=0 loops=1)
               ->  Seq Scan on t1 a  (cost=0.00..811.00 rows=23700 width=16) (actual time=0.000..0.053 rows=0 loops=1)
   (slice0)    Executor memory: 386K bytes.
   (slice1)    Executor memory: 66K bytes avg x 3 workers, 66K bytes max (seg0).
   (slice2)    Executor memory: 4182K bytes avg x 3 workers, 4182K bytes max (seg0).
 Memory used:  128000kB
 Optimizer: Postgres query optimizer
 Total runtime: 4.039 ms
(13 rows)

:explain select * from t1 a join t2 b using (c1, c2);
                                                                      QUERY PLAN                                                                      
------------------------------------------------------------------------------------------------------------------------------------------------------
 Gather Motion 1:1  (slice2; segments: 1)  (cost=3299.50..1268319.05 rows=5056 width=24) (actual time=2.173..2.173 rows=0 loops=2)
   ->  Hash Join  (cost=3299.50..1268319.05 rows=1686 width=24) (actual time=0.000..4.084 rows=0 loops=1)
         Hash Cond: a.c1 = b.c1 AND a.c2 = b.c2
         ->  Seq Scan on t1 a  (cost=0.00..811.00 rows=23700 width=16) (never executed)
         ->  Hash  (cost=2233.00..2233.00 rows=23700 width=16) (actual time=0.000..2.287 rows=0 loops=1)
               ->  Redistribute Motion 2:1  (slice1; segments: 2)  (cost=0.00..2233.00 rows=23700 width=16) (actual time=0.000..2.286 rows=0 loops=1)
                     Hash Key: b.c1, b.c2
                     ->  Seq Scan on t2 b  (cost=0.00..811.00 rows=23700 width=16) (actual time=0.000..0.013 rows=0 loops=1)
   (slice0)    Executor memory: 386K bytes.
   (slice1)    Executor memory: 66K bytes avg x 3 workers, 66K bytes max (seg0).
   (slice2)    Executor memory: 4170K bytes avg x 3 workers, 4170K bytes max (seg0).
 Memory used:  128000kB
 Optimizer: Postgres query optimizer
 Total runtime: 5.340 ms
(14 rows)

:explain select * from t1 a join d2 b using (c1);
                                                             QUERY PLAN                                                              
-------------------------------------------------------------------------------------------------------------------------------------
 Gather Motion 1:1  (slice1; segments: 1)  (cost=1699.75..685141.85 rows=5055210 width=28) (actual time=0.314..0.314 rows=0 loops=2)
   ->  Hash Join  (cost=1699.75..685141.85 rows=1685070 width=28) (actual time=0.000..0.018 rows=0 loops=1)
         Hash Cond: a.c1 = b.c1
         ->  Seq Scan on t1 a  (cost=0.00..811.00 rows=23700 width=16) (actual time=0.000..0.018 rows=0 loops=1)
         ->  Hash  (cost=811.00..811.00 rows=23700 width=16) (never executed)
               ->  Seq Scan on d2 b  (cost=0.00..811.00 rows=23700 width=16) (never executed)
   (slice0)    Executor memory: 386K bytes.
   (slice1)    Executor memory: 98K bytes avg x 3 workers, 98K bytes max (seg0).
 Memory used:  128000kB
 Optimizer: Postgres query optimizer
 Total runtime: 1.370 ms
(11 rows)

:explain select * from t1 a join d2 b using (c1, c2);
                                                            QUERY PLAN                                                             
-----------------------------------------------------------------------------------------------------------------------------------
 Gather Motion 1:1  (slice1; segments: 1)  (cost=1877.50..1266897.05 rows=5056 width=24) (actual time=0.190..0.190 rows=0 loops=2)
   ->  Hash Join  (cost=1877.50..1266897.05 rows=1686 width=24) (actual time=0.000..0.018 rows=0 loops=1)
         Hash Cond: a.c1 = b.c1 AND a.c2 = b.c2
         ->  Seq Scan on t1 a  (cost=0.00..811.00 rows=23700 width=16) (actual time=0.000..0.017 rows=0 loops=1)
         ->  Hash  (cost=811.00..811.00 rows=23700 width=16) (never executed)
               ->  Seq Scan on d2 b  (cost=0.00..811.00 rows=23700 width=16) (never executed)
   (slice0)    Executor memory: 386K bytes.
   (slice1)    Executor memory: 98K bytes avg x 3 workers, 98K bytes max (seg0).
 Memory used:  128000kB
 Optimizer: Postgres query optimizer
 Total runtime: 1.071 ms
(11 rows)

:explain select * from t1 a join r2 b using (c1);
                                                              QUERY PLAN                                                              
--------------------------------------------------------------------------------------------------------------------------------------
 Gather Motion 1:1  (slice2; segments: 1)  (cost=1699.75..1952143.85 rows=5055210 width=28) (actual time=1.824..1.824 rows=0 loops=2)
   ->  Hash Join  (cost=1699.75..1952143.85 rows=1685070 width=28) (actual time=0.000..2.478 rows=0 loops=1)
         Hash Cond: b.c1 = a.c1
         ->  Broadcast Motion 2:1  (slice1; segments: 2)  (cost=0.00..3655.00 rows=71100 width=16) (never executed)
               ->  Seq Scan on r2 b  (cost=0.00..811.00 rows=23700 width=16) (actual time=0.000..0.020 rows=0 loops=1)
         ->  Hash  (cost=811.00..811.00 rows=23700 width=16) (actual time=0.000..0.028 rows=0 loops=1)
               ->  Seq Scan on t1 a  (cost=0.00..811.00 rows=23700 width=16) (actual time=0.000..0.027 rows=0 loops=1)
   (slice0)    Executor memory: 386K bytes.
   (slice1)    Executor memory: 66K bytes avg x 3 workers, 66K bytes max (seg0).
   (slice2)    Executor memory: 4182K bytes avg x 3 workers, 4182K bytes max (seg0).
 Memory used:  128000kB
 Optimizer: Postgres query optimizer
 Total runtime: 4.588 ms
(13 rows)

:explain select * from t1 a join r2 b using (c1, c2);
                                                            QUERY PLAN                                                             
-----------------------------------------------------------------------------------------------------------------------------------
 Gather Motion 1:1  (slice2; segments: 1)  (cost=1877.50..1268319.05 rows=5056 width=24) (actual time=2.078..2.078 rows=0 loops=2)
   ->  Hash Join  (cost=1877.50..1268319.05 rows=1686 width=24) (actual time=0.000..2.362 rows=0 loops=1)
         Hash Cond: b.c1 = a.c1 AND b.c2 = a.c2
         ->  Redistribute Motion 2:1  (slice1; segments: 2)  (cost=0.00..2233.00 rows=23700 width=16) (never executed)
               Hash Key: b.c1, b.c2
               ->  Seq Scan on r2 b  (cost=0.00..811.00 rows=23700 width=16) (actual time=0.000..0.042 rows=0 loops=1)
         ->  Hash  (cost=811.00..811.00 rows=23700 width=16) (actual time=0.000..0.040 rows=0 loops=1)
               ->  Seq Scan on t1 a  (cost=0.00..811.00 rows=23700 width=16) (actual time=0.000..0.038 rows=0 loops=1)
   (slice0)    Executor memory: 386K bytes.
   (slice1)    Executor memory: 66K bytes avg x 3 workers, 66K bytes max (seg0).
   (slice2)    Executor memory: 4182K bytes avg x 3 workers, 4182K bytes max (seg0).
 Memory used:  128000kB
 Optimizer: Postgres query optimizer
 Total runtime: 5.159 ms
(14 rows)

:explain select * from d1 a join t2 b using (c1);
                                                                QUERY PLAN                                                                 
-------------------------------------------------------------------------------------------------------------------------------------------
 Hash Join  (cost=1699.75..686563.85 rows=5055210 width=28) (actual time=1.488..1.488 rows=0 loops=2)
   Hash Cond: b.c1 = a.c1
   Extra Text: Hash chain length 0.0 avg, 0 max, using 0 of 524288 buckets.
   ->  Gather Motion 2:1  (slice1; segments: 2)  (cost=0.00..2233.00 rows=71100 width=16) (never executed)
         ->  Seq Scan on t2 b  (cost=0.00..811.00 rows=23700 width=16) (actual time=0.000..0.058 rows=0 loops=1)
   ->  Hash  (cost=811.00..811.00 rows=23700 width=16) (actual time=0.004..0.004 rows=0 loops=2)
         Buckets: 524288  Batches: 1  Memory Usage: 0kB
         ->  Gather Motion 1:1  (slice2; segments: 1)  (cost=811.00..811.00 rows=71100 width=16) (actual time=0.003..0.003 rows=0 loops=2)
               ->  Seq Scan on d1 a  (cost=0.00..811.00 rows=23700 width=16) (actual time=0.000..0.010 rows=0 loops=1)
   (slice0)    Executor memory: 4234K bytes.
   (slice1)    Executor memory: 50K bytes avg x 3 workers, 50K bytes max (seg0).
   (slice2)    Executor memory: 66K bytes (seg0).
 Memory used:  128000kB
 Optimizer: Postgres query optimizer
 Total runtime: 4.018 ms
(16 rows)

:explain select * from d1 a join t2 b using (c1, c2);
                                                            QUERY PLAN                                                             
-----------------------------------------------------------------------------------------------------------------------------------
 Gather Motion 2:1  (slice2; segments: 2)  (cost=1877.50..1268319.05 rows=5056 width=24) (actual time=0.795..0.795 rows=0 loops=2)
   ->  Hash Join  (cost=1877.50..1268319.05 rows=1686 width=24) (actual time=0.000..2.185 rows=0 loops=1)
         Hash Cond: a.c1 = b.c1 AND a.c2 = b.c2
         ->  Redistribute Motion 1:2  (slice1; segments: 1)  (cost=0.00..2233.00 rows=71100 width=16) (never executed)
               Hash Key: a.c1, a.c2
               ->  Seq Scan on d1 a  (cost=0.00..811.00 rows=23700 width=16) (actual time=0.000..0.031 rows=0 loops=1)
         ->  Hash  (cost=811.00..811.00 rows=23700 width=16) (actual time=0.000..0.032 rows=0 loops=1)
               ->  Seq Scan on t2 b  (cost=0.00..811.00 rows=23700 width=16) (actual time=0.000..0.030 rows=0 loops=1)
   (slice0)    Executor memory: 386K bytes.
   (slice1)    Executor memory: 66K bytes (seg0).
   (slice2)    Executor memory: 4182K bytes avg x 3 workers, 4182K bytes max (seg0).
 Memory used:  128000kB
 Optimizer: Postgres query optimizer
 Total runtime: 3.289 ms
(14 rows)

:explain select * from d1 a join d2 b using (c1);
                                                             QUERY PLAN                                                              
-------------------------------------------------------------------------------------------------------------------------------------
 Gather Motion 1:1  (slice1; segments: 1)  (cost=1699.75..685141.85 rows=5055210 width=28) (actual time=0.214..0.214 rows=0 loops=2)
   ->  Hash Join  (cost=1699.75..685141.85 rows=1685070 width=28) (actual time=0.000..0.018 rows=0 loops=1)
         Hash Cond: a.c1 = b.c1
         ->  Seq Scan on d1 a  (cost=0.00..811.00 rows=23700 width=16) (actual time=0.000..0.018 rows=0 loops=1)
         ->  Hash  (cost=811.00..811.00 rows=23700 width=16) (never executed)
               ->  Seq Scan on d2 b  (cost=0.00..811.00 rows=23700 width=16) (never executed)
   (slice0)    Executor memory: 386K bytes.
   (slice1)    Executor memory: 98K bytes (seg0).
 Memory used:  128000kB
 Optimizer: Postgres query optimizer
 Total runtime: 1.036 ms
(11 rows)

:explain select * from d1 a join d2 b using (c1, c2);
                                                            QUERY PLAN                                                             
-----------------------------------------------------------------------------------------------------------------------------------
 Gather Motion 1:1  (slice1; segments: 1)  (cost=1877.50..1266897.05 rows=5056 width=24) (actual time=0.209..0.209 rows=0 loops=2)
   ->  Hash Join  (cost=1877.50..1266897.05 rows=1686 width=24) (actual time=0.000..0.017 rows=0 loops=1)
         Hash Cond: a.c1 = b.c1 AND a.c2 = b.c2
         ->  Seq Scan on d1 a  (cost=0.00..811.00 rows=23700 width=16) (actual time=0.000..0.017 rows=0 loops=1)
         ->  Hash  (cost=811.00..811.00 rows=23700 width=16) (never executed)
               ->  Seq Scan on d2 b  (cost=0.00..811.00 rows=23700 width=16) (never executed)
   (slice0)    Executor memory: 386K bytes.
   (slice1)    Executor memory: 98K bytes (seg0).
 Memory used:  128000kB
 Optimizer: Postgres query optimizer
 Total runtime: 1.005 ms
(11 rows)

:explain select * from d1 a join r2 b using (c1);
                                                                QUERY PLAN                                                                 
-------------------------------------------------------------------------------------------------------------------------------------------
 Hash Join  (cost=1699.75..686563.85 rows=5055210 width=28) (actual time=1.544..1.544 rows=0 loops=2)
   Hash Cond: b.c1 = a.c1
   Extra Text: Hash chain length 0.0 avg, 0 max, using 0 of 524288 buckets.
   ->  Gather Motion 2:1  (slice1; segments: 2)  (cost=0.00..2233.00 rows=71100 width=16) (never executed)
         ->  Seq Scan on r2 b  (cost=0.00..811.00 rows=23700 width=16) (actual time=0.000..0.017 rows=0 loops=1)
   ->  Hash  (cost=811.00..811.00 rows=23700 width=16) (actual time=0.324..0.324 rows=0 loops=2)
         Buckets: 524288  Batches: 1  Memory Usage: 0kB
         ->  Gather Motion 1:1  (slice2; segments: 1)  (cost=811.00..811.00 rows=71100 width=16) (actual time=0.323..0.323 rows=0 loops=2)
               ->  Seq Scan on d1 a  (cost=0.00..811.00 rows=23700 width=16) (actual time=0.000..0.010 rows=0 loops=1)
   (slice0)    Executor memory: 4234K bytes.
   (slice1)    Executor memory: 50K bytes avg x 3 workers, 50K bytes max (seg0).
   (slice2)    Executor memory: 66K bytes (seg0).
 Memory used:  128000kB
 Optimizer: Postgres query optimizer
 Total runtime: 3.589 ms
(16 rows)

:explain select * from d1 a join r2 b using (c1, c2);
                                                                QUERY PLAN                                                                 
-------------------------------------------------------------------------------------------------------------------------------------------
 Hash Join  (cost=1877.50..1268319.05 rows=5056 width=24) (actual time=0.919..0.919 rows=0 loops=2)
   Hash Cond: b.c1 = a.c1 AND b.c2 = a.c2
   Extra Text: Hash chain length 0.0 avg, 0 max, using 0 of 524288 buckets.
   ->  Gather Motion 2:1  (slice1; segments: 2)  (cost=0.00..2233.00 rows=71100 width=16) (never executed)
         ->  Seq Scan on r2 b  (cost=0.00..811.00 rows=23700 width=16) (actual time=0.000..0.020 rows=0 loops=1)
   ->  Hash  (cost=811.00..811.00 rows=23700 width=16) (actual time=0.003..0.003 rows=0 loops=2)
         Buckets: 524288  Batches: 1  Memory Usage: 0kB
         ->  Gather Motion 1:1  (slice2; segments: 1)  (cost=811.00..811.00 rows=71100 width=16) (actual time=0.002..0.002 rows=0 loops=2)
               ->  Seq Scan on d1 a  (cost=0.00..811.00 rows=23700 width=16) (actual time=0.000..0.009 rows=0 loops=1)
   (slice0)    Executor memory: 4234K bytes.
   (slice1)    Executor memory: 50K bytes avg x 3 workers, 50K bytes max (seg0).
   (slice2)    Executor memory: 66K bytes (seg0).
 Memory used:  128000kB
 Optimizer: Postgres query optimizer
 Total runtime: 2.643 ms
(16 rows)

:explain select * from r1 a join t2 b using (c1);
                                                              QUERY PLAN                                                              
--------------------------------------------------------------------------------------------------------------------------------------
 Gather Motion 1:1  (slice2; segments: 1)  (cost=1699.75..1952143.85 rows=5055210 width=28) (actual time=1.801..1.801 rows=0 loops=2)
   ->  Hash Join  (cost=1699.75..1952143.85 rows=1685070 width=28) (actual time=0.000..2.489 rows=0 loops=1)
         Hash Cond: b.c1 = a.c1
         ->  Broadcast Motion 2:1  (slice1; segments: 2)  (cost=0.00..3655.00 rows=71100 width=16) (never executed)
               ->  Seq Scan on t2 b  (cost=0.00..811.00 rows=23700 width=16) (actual time=0.000..0.017 rows=0 loops=1)
         ->  Hash  (cost=811.00..811.00 rows=23700 width=16) (actual time=0.000..0.025 rows=0 loops=1)
               ->  Seq Scan on r1 a  (cost=0.00..811.00 rows=23700 width=16) (actual time=0.000..0.024 rows=0 loops=1)
   (slice0)    Executor memory: 386K bytes.
   (slice1)    Executor memory: 66K bytes avg x 3 workers, 66K bytes max (seg0).
   (slice2)    Executor memory: 4182K bytes avg x 3 workers, 4182K bytes max (seg0).
 Memory used:  128000kB
 Optimizer: Postgres query optimizer
 Total runtime: 4.490 ms
(13 rows)

:explain select * from r1 a join t2 b using (c1, c2);
                                                            QUERY PLAN                                                             
-----------------------------------------------------------------------------------------------------------------------------------
 Gather Motion 2:1  (slice2; segments: 2)  (cost=1877.50..1268319.05 rows=5056 width=24) (actual time=1.266..1.266 rows=0 loops=2)
   ->  Hash Join  (cost=1877.50..1268319.05 rows=1686 width=24) (actual time=0.000..2.969 rows=0 loops=1)
         Hash Cond: a.c1 = b.c1 AND a.c2 = b.c2
         ->  Redistribute Motion 1:2  (slice1; segments: 1)  (cost=0.00..2233.00 rows=23700 width=16) (never executed)
               Hash Key: a.c1, a.c2
               ->  Seq Scan on r1 a  (cost=0.00..811.00 rows=23700 width=16) (actual time=0.000..0.016 rows=0 loops=1)
         ->  Hash  (cost=811.00..811.00 rows=23700 width=16) (actual time=0.000..0.029 rows=0 loops=1)
               ->  Seq Scan on t2 b  (cost=0.00..811.00 rows=23700 width=16) (actual time=0.000..0.027 rows=0 loops=1)
   (slice0)    Executor memory: 386K bytes.
   (slice1)    Executor memory: 66K bytes avg x 3 workers, 66K bytes max (seg0).
   (slice2)    Executor memory: 4182K bytes avg x 3 workers, 4182K bytes max (seg0).
 Memory used:  128000kB
 Optimizer: Postgres query optimizer
 Total runtime: 4.184 ms
(14 rows)

:explain select * from r1 a join d2 b using (c1);
                                                             QUERY PLAN                                                              
-------------------------------------------------------------------------------------------------------------------------------------
 Gather Motion 1:1  (slice1; segments: 1)  (cost=1699.75..685141.85 rows=5055210 width=28) (actual time=0.294..0.294 rows=0 loops=2)
   ->  Hash Join  (cost=1699.75..685141.85 rows=1685070 width=28) (actual time=0.000..0.073 rows=0 loops=1)
         Hash Cond: a.c1 = b.c1
         ->  Seq Scan on r1 a  (cost=0.00..811.00 rows=23700 width=16) (actual time=0.000..0.073 rows=0 loops=1)
         ->  Hash  (cost=811.00..811.00 rows=23700 width=16) (never executed)
               ->  Seq Scan on d2 b  (cost=0.00..811.00 rows=23700 width=16) (never executed)
   (slice0)    Executor memory: 386K bytes.
   (slice1)    Executor memory: 98K bytes avg x 3 workers, 98K bytes max (seg0).
 Memory used:  128000kB
 Optimizer: Postgres query optimizer
 Total runtime: 1.169 ms
(11 rows)

:explain select * from r1 a join d2 b using (c1, c2);
                                                            QUERY PLAN                                                             
-----------------------------------------------------------------------------------------------------------------------------------
 Gather Motion 1:1  (slice1; segments: 1)  (cost=1877.50..1266897.05 rows=5056 width=24) (actual time=0.199..0.199 rows=0 loops=2)
   ->  Hash Join  (cost=1877.50..1266897.05 rows=1686 width=24) (actual time=0.000..0.019 rows=0 loops=1)
         Hash Cond: a.c1 = b.c1 AND a.c2 = b.c2
         ->  Seq Scan on r1 a  (cost=0.00..811.00 rows=23700 width=16) (actual time=0.000..0.018 rows=0 loops=1)
         ->  Hash  (cost=811.00..811.00 rows=23700 width=16) (never executed)
               ->  Seq Scan on d2 b  (cost=0.00..811.00 rows=23700 width=16) (never executed)
   (slice0)    Executor memory: 386K bytes.
   (slice1)    Executor memory: 98K bytes avg x 3 workers, 98K bytes max (seg0).
 Memory used:  128000kB
 Optimizer: Postgres query optimizer
 Total runtime: 0.995 ms
(11 rows)

:explain select * from r1 a join r2 b using (c1);
                                                              QUERY PLAN                                                              
--------------------------------------------------------------------------------------------------------------------------------------
 Gather Motion 1:1  (slice2; segments: 1)  (cost=1699.75..1952143.85 rows=5055210 width=28) (actual time=1.734..1.734 rows=0 loops=2)
   ->  Hash Join  (cost=1699.75..1952143.85 rows=1685070 width=28) (actual time=0.000..2.483 rows=0 loops=1)
         Hash Cond: b.c1 = a.c1
         ->  Broadcast Motion 2:1  (slice1; segments: 2)  (cost=0.00..3655.00 rows=71100 width=16) (never executed)
               ->  Seq Scan on r2 b  (cost=0.00..811.00 rows=23700 width=16) (actual time=0.000..0.018 rows=0 loops=1)
         ->  Hash  (cost=811.00..811.00 rows=23700 width=16) (actual time=0.000..0.027 rows=0 loops=1)
               ->  Seq Scan on r1 a  (cost=0.00..811.00 rows=23700 width=16) (actual time=0.000..0.026 rows=0 loops=1)
   (slice0)    Executor memory: 386K bytes.
   (slice1)    Executor memory: 66K bytes avg x 3 workers, 66K bytes max (seg0).
   (slice2)    Executor memory: 4182K bytes avg x 3 workers, 4182K bytes max (seg0).
 Memory used:  128000kB
 Optimizer: Postgres query optimizer
 Total runtime: 4.364 ms
(13 rows)

:explain select * from r1 a join r2 b using (c1, c2);
                                                            QUERY PLAN                                                             
-----------------------------------------------------------------------------------------------------------------------------------
 Gather Motion 1:1  (slice2; segments: 1)  (cost=1877.50..3798057.05 rows=5056 width=24) (actual time=1.571..1.571 rows=0 loops=2)
   ->  Hash Join  (cost=1877.50..3798057.05 rows=1686 width=24) (actual time=0.000..2.437 rows=0 loops=1)
         Hash Cond: b.c1 = a.c1 AND b.c2 = a.c2
         ->  Broadcast Motion 2:1  (slice1; segments: 2)  (cost=0.00..3655.00 rows=71100 width=16) (never executed)
               ->  Seq Scan on r2 b  (cost=0.00..811.00 rows=23700 width=16) (actual time=0.000..0.017 rows=0 loops=1)
         ->  Hash  (cost=811.00..811.00 rows=23700 width=16) (actual time=0.000..0.029 rows=0 loops=1)
               ->  Seq Scan on r1 a  (cost=0.00..811.00 rows=23700 width=16) (actual time=0.000..0.028 rows=0 loops=1)
   (slice0)    Executor memory: 386K bytes.
   (slice1)    Executor memory: 66K bytes avg x 3 workers, 66K bytes max (seg0).
   (slice2)    Executor memory: 4182K bytes avg x 3 workers, 4182K bytes max (seg0).
 Memory used:  128000kB
 Optimizer: Postgres query optimizer
 Total runtime: 3.899 ms
(13 rows)

-- x2 join y1
:explain select * from t2 a join t1 b using (c1);
                                                              QUERY PLAN                                                              
--------------------------------------------------------------------------------------------------------------------------------------
 Gather Motion 1:1  (slice2; segments: 1)  (cost=1699.75..1952143.85 rows=5055210 width=28) (actual time=1.211..1.211 rows=0 loops=2)
   ->  Hash Join  (cost=1699.75..1952143.85 rows=1685070 width=28) (actual time=0.000..2.031 rows=0 loops=1)
         Hash Cond: a.c1 = b.c1
         ->  Broadcast Motion 2:1  (slice1; segments: 2)  (cost=0.00..3655.00 rows=71100 width=16) (never executed)
               ->  Seq Scan on t2 a  (cost=0.00..811.00 rows=23700 width=16) (actual time=0.000..0.011 rows=0 loops=1)
         ->  Hash  (cost=811.00..811.00 rows=23700 width=16) (actual time=0.000..0.027 rows=0 loops=1)
               ->  Seq Scan on t1 b  (cost=0.00..811.00 rows=23700 width=16) (actual time=0.000..0.025 rows=0 loops=1)
   (slice0)    Executor memory: 386K bytes.
   (slice1)    Executor memory: 66K bytes avg x 3 workers, 66K bytes max (seg0).
   (slice2)    Executor memory: 4182K bytes avg x 3 workers, 4182K bytes max (seg0).
 Memory used:  128000kB
 Optimizer: Postgres query optimizer
 Total runtime: 3.164 ms
(13 rows)

:explain select * from t2 a join t1 b using (c1, c2);
                                                                      QUERY PLAN                                                                      
------------------------------------------------------------------------------------------------------------------------------------------------------
 Gather Motion 2:1  (slice2; segments: 2)  (cost=3299.50..1268319.05 rows=5056 width=24) (actual time=1.479..1.479 rows=0 loops=2)
   ->  Hash Join  (cost=3299.50..1268319.05 rows=1686 width=24) (actual time=0.000..2.556 rows=0 loops=1)
         Hash Cond: a.c1 = b.c1 AND a.c2 = b.c2
         ->  Seq Scan on t2 a  (cost=0.00..811.00 rows=23700 width=16) (never executed)
         ->  Hash  (cost=2233.00..2233.00 rows=23700 width=16) (actual time=0.000..0.635 rows=0 loops=1)
               ->  Redistribute Motion 1:2  (slice1; segments: 1)  (cost=0.00..2233.00 rows=23700 width=16) (actual time=0.000..0.633 rows=0 loops=1)
                     Hash Key: b.c1, b.c2
                     ->  Seq Scan on t1 b  (cost=0.00..811.00 rows=23700 width=16) (actual time=0.000..0.013 rows=0 loops=1)
   (slice0)    Executor memory: 386K bytes.
   (slice1)    Executor memory: 66K bytes avg x 3 workers, 66K bytes max (seg0).
   (slice2)    Executor memory: 4170K bytes avg x 3 workers, 4170K bytes max (seg0).
 Memory used:  128000kB
 Optimizer: Postgres query optimizer
 Total runtime: 3.722 ms
(14 rows)

:explain select * from t2 a join d1 b using (c1);
                                                                QUERY PLAN                                                                 
-------------------------------------------------------------------------------------------------------------------------------------------
 Hash Join  (cost=1699.75..686563.85 rows=5055210 width=28) (actual time=1.470..1.470 rows=0 loops=2)
   Hash Cond: a.c1 = b.c1
   Extra Text: Hash chain length 0.0 avg, 0 max, using 0 of 524288 buckets.
   ->  Gather Motion 2:1  (slice1; segments: 2)  (cost=0.00..2233.00 rows=71100 width=16) (never executed)
         ->  Seq Scan on t2 a  (cost=0.00..811.00 rows=23700 width=16) (actual time=0.000..0.017 rows=0 loops=1)
   ->  Hash  (cost=811.00..811.00 rows=23700 width=16) (actual time=0.613..0.613 rows=0 loops=2)
         Buckets: 524288  Batches: 1  Memory Usage: 0kB
         ->  Gather Motion 1:1  (slice2; segments: 1)  (cost=811.00..811.00 rows=71100 width=16) (actual time=0.612..0.612 rows=0 loops=2)
               ->  Seq Scan on d1 b  (cost=0.00..811.00 rows=23700 width=16) (actual time=0.000..0.009 rows=0 loops=1)
   (slice0)    Executor memory: 4234K bytes.
   (slice1)    Executor memory: 50K bytes avg x 3 workers, 50K bytes max (seg0).
   (slice2)    Executor memory: 66K bytes (seg0).
 Memory used:  128000kB
 Optimizer: Postgres query optimizer
 Total runtime: 3.343 ms
(16 rows)

:explain select * from t2 a join d1 b using (c1, c2);
                                                            QUERY PLAN                                                             
-----------------------------------------------------------------------------------------------------------------------------------
 Gather Motion 2:1  (slice2; segments: 2)  (cost=1877.50..1268319.05 rows=5056 width=24) (actual time=1.815..1.815 rows=0 loops=2)
   ->  Hash Join  (cost=1877.50..1268319.05 rows=1686 width=24) (actual time=0.000..2.410 rows=0 loops=1)
         Hash Cond: b.c1 = a.c1 AND b.c2 = a.c2
         ->  Redistribute Motion 1:2  (slice1; segments: 1)  (cost=0.00..2233.00 rows=71100 width=16) (never executed)
               Hash Key: b.c1, b.c2
               ->  Seq Scan on d1 b  (cost=0.00..811.00 rows=23700 width=16) (actual time=0.000..0.008 rows=0 loops=1)
         ->  Hash  (cost=811.00..811.00 rows=23700 width=16) (actual time=0.000..0.026 rows=0 loops=1)
               ->  Seq Scan on t2 a  (cost=0.00..811.00 rows=23700 width=16) (actual time=0.000..0.025 rows=0 loops=1)
   (slice0)    Executor memory: 386K bytes.
   (slice1)    Executor memory: 66K bytes (seg0).
   (slice2)    Executor memory: 4182K bytes avg x 3 workers, 4182K bytes max (seg0).
 Memory used:  128000kB
 Optimizer: Postgres query optimizer
 Total runtime: 4.357 ms
(14 rows)

:explain select * from t2 a join r1 b using (c1);
                                                              QUERY PLAN                                                              
--------------------------------------------------------------------------------------------------------------------------------------
 Gather Motion 1:1  (slice2; segments: 1)  (cost=1699.75..1952143.85 rows=5055210 width=28) (actual time=1.463..1.463 rows=0 loops=2)
   ->  Hash Join  (cost=1699.75..1952143.85 rows=1685070 width=28) (actual time=0.000..2.380 rows=0 loops=1)
         Hash Cond: a.c1 = b.c1
         ->  Broadcast Motion 2:1  (slice1; segments: 2)  (cost=0.00..3655.00 rows=71100 width=16) (never executed)
               ->  Seq Scan on t2 a  (cost=0.00..811.00 rows=23700 width=16) (actual time=0.000..0.008 rows=0 loops=1)
         ->  Hash  (cost=811.00..811.00 rows=23700 width=16) (actual time=0.000..0.030 rows=0 loops=1)
               ->  Seq Scan on r1 b  (cost=0.00..811.00 rows=23700 width=16) (actual time=0.000..0.029 rows=0 loops=1)
   (slice0)    Executor memory: 386K bytes.
   (slice1)    Executor memory: 66K bytes avg x 3 workers, 66K bytes max (seg0).
   (slice2)    Executor memory: 4182K bytes avg x 3 workers, 4182K bytes max (seg0).
 Memory used:  128000kB
 Optimizer: Postgres query optimizer
 Total runtime: 3.651 ms
(13 rows)

:explain select * from t2 a join r1 b using (c1, c2);
                                                            QUERY PLAN                                                             
-----------------------------------------------------------------------------------------------------------------------------------
 Gather Motion 2:1  (slice2; segments: 2)  (cost=1877.50..1268319.05 rows=5056 width=24) (actual time=1.357..1.357 rows=0 loops=2)
   ->  Hash Join  (cost=1877.50..1268319.05 rows=1686 width=24) (actual time=0.000..2.370 rows=0 loops=1)
         Hash Cond: b.c1 = a.c1 AND b.c2 = a.c2
         ->  Redistribute Motion 1:2  (slice1; segments: 1)  (cost=0.00..2233.00 rows=23700 width=16) (never executed)
               Hash Key: b.c1, b.c2
               ->  Seq Scan on r1 b  (cost=0.00..811.00 rows=23700 width=16) (actual time=0.000..0.012 rows=0 loops=1)
         ->  Hash  (cost=811.00..811.00 rows=23700 width=16) (actual time=0.000..0.034 rows=0 loops=1)
               ->  Seq Scan on t2 a  (cost=0.00..811.00 rows=23700 width=16) (actual time=0.000..0.032 rows=0 loops=1)
   (slice0)    Executor memory: 386K bytes.
   (slice1)    Executor memory: 66K bytes avg x 3 workers, 66K bytes max (seg0).
   (slice2)    Executor memory: 4182K bytes avg x 3 workers, 4182K bytes max (seg0).
 Memory used:  128000kB
 Optimizer: Postgres query optimizer
 Total runtime: 3.546 ms
(14 rows)

:explain select * from d2 a join t1 b using (c1);
                                                             QUERY PLAN                                                              
-------------------------------------------------------------------------------------------------------------------------------------
 Gather Motion 1:1  (slice1; segments: 1)  (cost=1699.75..685141.85 rows=5055210 width=28) (actual time=0.283..0.283 rows=0 loops=2)
   ->  Hash Join  (cost=1699.75..685141.85 rows=1685070 width=28) (actual time=0.000..0.018 rows=0 loops=1)
         Hash Cond: a.c1 = b.c1
         ->  Seq Scan on d2 a  (cost=0.00..811.00 rows=23700 width=16) (actual time=0.000..0.018 rows=0 loops=1)
         ->  Hash  (cost=811.00..811.00 rows=23700 width=16) (never executed)
               ->  Seq Scan on t1 b  (cost=0.00..811.00 rows=23700 width=16) (never executed)
   (slice0)    Executor memory: 386K bytes.
   (slice1)    Executor memory: 98K bytes avg x 3 workers, 98K bytes max (seg0).
 Memory used:  128000kB
 Optimizer: Postgres query optimizer
 Total runtime: 1.190 ms
(11 rows)

:explain select * from d2 a join t1 b using (c1, c2);
                                                            QUERY PLAN                                                             
-----------------------------------------------------------------------------------------------------------------------------------
 Gather Motion 1:1  (slice1; segments: 1)  (cost=1877.50..1266897.05 rows=5056 width=24) (actual time=0.196..0.196 rows=0 loops=2)
   ->  Hash Join  (cost=1877.50..1266897.05 rows=1686 width=24) (actual time=0.000..0.016 rows=0 loops=1)
         Hash Cond: a.c1 = b.c1 AND a.c2 = b.c2
         ->  Seq Scan on d2 a  (cost=0.00..811.00 rows=23700 width=16) (actual time=0.000..0.016 rows=0 loops=1)
         ->  Hash  (cost=811.00..811.00 rows=23700 width=16) (never executed)
               ->  Seq Scan on t1 b  (cost=0.00..811.00 rows=23700 width=16) (never executed)
   (slice0)    Executor memory: 386K bytes.
   (slice1)    Executor memory: 98K bytes avg x 3 workers, 98K bytes max (seg0).
 Memory used:  128000kB
 Optimizer: Postgres query optimizer
 Total runtime: 1.001 ms
(11 rows)

:explain select * from d2 a join d1 b using (c1);
                                                             QUERY PLAN                                                              
-------------------------------------------------------------------------------------------------------------------------------------
 Gather Motion 1:1  (slice1; segments: 1)  (cost=1699.75..685141.85 rows=5055210 width=28) (actual time=0.192..0.192 rows=0 loops=2)
   ->  Hash Join  (cost=1699.75..685141.85 rows=1685070 width=28) (actual time=0.000..0.015 rows=0 loops=1)
         Hash Cond: a.c1 = b.c1
         ->  Seq Scan on d2 a  (cost=0.00..811.00 rows=23700 width=16) (actual time=0.000..0.015 rows=0 loops=1)
         ->  Hash  (cost=811.00..811.00 rows=23700 width=16) (never executed)
               ->  Seq Scan on d1 b  (cost=0.00..811.00 rows=23700 width=16) (never executed)
   (slice0)    Executor memory: 386K bytes.
   (slice1)    Executor memory: 98K bytes (seg0).
 Memory used:  128000kB
 Optimizer: Postgres query optimizer
 Total runtime: 0.951 ms
(11 rows)

:explain select * from d2 a join d1 b using (c1, c2);
                                                            QUERY PLAN                                                             
-----------------------------------------------------------------------------------------------------------------------------------
 Gather Motion 1:1  (slice1; segments: 1)  (cost=1877.50..1266897.05 rows=5056 width=24) (actual time=0.202..0.202 rows=0 loops=2)
   ->  Hash Join  (cost=1877.50..1266897.05 rows=1686 width=24) (actual time=0.000..0.014 rows=0 loops=1)
         Hash Cond: a.c1 = b.c1 AND a.c2 = b.c2
         ->  Seq Scan on d2 a  (cost=0.00..811.00 rows=23700 width=16) (actual time=0.000..0.014 rows=0 loops=1)
         ->  Hash  (cost=811.00..811.00 rows=23700 width=16) (never executed)
               ->  Seq Scan on d1 b  (cost=0.00..811.00 rows=23700 width=16) (never executed)
   (slice0)    Executor memory: 386K bytes.
   (slice1)    Executor memory: 98K bytes (seg0).
 Memory used:  128000kB
 Optimizer: Postgres query optimizer
 Total runtime: 0.969 ms
(11 rows)

:explain select * from d2 a join r1 b using (c1);
                                                             QUERY PLAN                                                              
-------------------------------------------------------------------------------------------------------------------------------------
 Gather Motion 1:1  (slice1; segments: 1)  (cost=1699.75..685141.85 rows=5055210 width=28) (actual time=0.200..0.200 rows=0 loops=2)
   ->  Hash Join  (cost=1699.75..685141.85 rows=1685070 width=28) (actual time=0.000..0.017 rows=0 loops=1)
         Hash Cond: a.c1 = b.c1
         ->  Seq Scan on d2 a  (cost=0.00..811.00 rows=23700 width=16) (actual time=0.000..0.016 rows=0 loops=1)
         ->  Hash  (cost=811.00..811.00 rows=23700 width=16) (never executed)
               ->  Seq Scan on r1 b  (cost=0.00..811.00 rows=23700 width=16) (never executed)
   (slice0)    Executor memory: 386K bytes.
   (slice1)    Executor memory: 98K bytes avg x 3 workers, 98K bytes max (seg0).
 Memory used:  128000kB
 Optimizer: Postgres query optimizer
 Total runtime: 1.075 ms
(11 rows)

:explain select * from d2 a join r1 b using (c1, c2);
                                                            QUERY PLAN                                                             
-----------------------------------------------------------------------------------------------------------------------------------
 Gather Motion 1:1  (slice1; segments: 1)  (cost=1877.50..1266897.05 rows=5056 width=24) (actual time=0.198..0.198 rows=0 loops=2)
   ->  Hash Join  (cost=1877.50..1266897.05 rows=1686 width=24) (actual time=0.000..0.016 rows=0 loops=1)
         Hash Cond: a.c1 = b.c1 AND a.c2 = b.c2
         ->  Seq Scan on d2 a  (cost=0.00..811.00 rows=23700 width=16) (actual time=0.000..0.016 rows=0 loops=1)
         ->  Hash  (cost=811.00..811.00 rows=23700 width=16) (never executed)
               ->  Seq Scan on r1 b  (cost=0.00..811.00 rows=23700 width=16) (never executed)
   (slice0)    Executor memory: 386K bytes.
   (slice1)    Executor memory: 98K bytes avg x 3 workers, 98K bytes max (seg0).
 Memory used:  128000kB
 Optimizer: Postgres query optimizer
 Total runtime: 1.028 ms
(11 rows)

:explain select * from r2 a join t1 b using (c1);
                                                              QUERY PLAN                                                              
--------------------------------------------------------------------------------------------------------------------------------------
 Gather Motion 1:1  (slice2; segments: 1)  (cost=1699.75..1952143.85 rows=5055210 width=28) (actual time=1.407..1.407 rows=0 loops=2)
   ->  Hash Join  (cost=1699.75..1952143.85 rows=1685070 width=28) (actual time=0.000..2.410 rows=0 loops=1)
         Hash Cond: a.c1 = b.c1
         ->  Broadcast Motion 2:1  (slice1; segments: 2)  (cost=0.00..3655.00 rows=71100 width=16) (never executed)
               ->  Seq Scan on r2 a  (cost=0.00..811.00 rows=23700 width=16) (actual time=0.000..0.009 rows=0 loops=1)
         ->  Hash  (cost=811.00..811.00 rows=23700 width=16) (actual time=0.000..0.022 rows=0 loops=1)
               ->  Seq Scan on t1 b  (cost=0.00..811.00 rows=23700 width=16) (actual time=0.000..0.022 rows=0 loops=1)
   (slice0)    Executor memory: 386K bytes.
   (slice1)    Executor memory: 66K bytes avg x 3 workers, 66K bytes max (seg0).
   (slice2)    Executor memory: 4182K bytes avg x 3 workers, 4182K bytes max (seg0).
 Memory used:  128000kB
 Optimizer: Postgres query optimizer
 Total runtime: 3.647 ms
(13 rows)

:explain select * from r2 a join t1 b using (c1, c2);
                                                            QUERY PLAN                                                             
-----------------------------------------------------------------------------------------------------------------------------------
 Gather Motion 1:1  (slice2; segments: 1)  (cost=1877.50..1268319.05 rows=5056 width=24) (actual time=1.370..1.370 rows=0 loops=2)
   ->  Hash Join  (cost=1877.50..1268319.05 rows=1686 width=24) (actual time=0.000..2.408 rows=0 loops=1)
         Hash Cond: a.c1 = b.c1 AND a.c2 = b.c2
         ->  Redistribute Motion 2:1  (slice1; segments: 2)  (cost=0.00..2233.00 rows=23700 width=16) (never executed)
               Hash Key: a.c1, a.c2
               ->  Seq Scan on r2 a  (cost=0.00..811.00 rows=23700 width=16) (actual time=0.000..0.009 rows=0 loops=1)
         ->  Hash  (cost=811.00..811.00 rows=23700 width=16) (actual time=0.000..0.034 rows=0 loops=1)
               ->  Seq Scan on t1 b  (cost=0.00..811.00 rows=23700 width=16) (actual time=0.000..0.032 rows=0 loops=1)
   (slice0)    Executor memory: 386K bytes.
   (slice1)    Executor memory: 66K bytes avg x 3 workers, 66K bytes max (seg0).
   (slice2)    Executor memory: 4182K bytes avg x 3 workers, 4182K bytes max (seg0).
 Memory used:  128000kB
 Optimizer: Postgres query optimizer
 Total runtime: 3.610 ms
(14 rows)

:explain select * from r2 a join d1 b using (c1);
                                                                QUERY PLAN                                                                 
-------------------------------------------------------------------------------------------------------------------------------------------
 Hash Join  (cost=1699.75..686563.85 rows=5055210 width=28) (actual time=1.540..1.540 rows=0 loops=2)
   Hash Cond: a.c1 = b.c1
   Extra Text: Hash chain length 0.0 avg, 0 max, using 0 of 524288 buckets.
   ->  Gather Motion 2:1  (slice1; segments: 2)  (cost=0.00..2233.00 rows=71100 width=16) (never executed)
         ->  Seq Scan on r2 a  (cost=0.00..811.00 rows=23700 width=16) (actual time=0.000..0.018 rows=0 loops=1)
   ->  Hash  (cost=811.00..811.00 rows=23700 width=16) (actual time=0.636..0.636 rows=0 loops=2)
         Buckets: 524288  Batches: 1  Memory Usage: 0kB
         ->  Gather Motion 1:1  (slice2; segments: 1)  (cost=811.00..811.00 rows=71100 width=16) (actual time=0.635..0.635 rows=0 loops=2)
               ->  Seq Scan on d1 b  (cost=0.00..811.00 rows=23700 width=16) (actual time=0.000..0.010 rows=0 loops=1)
   (slice0)    Executor memory: 4234K bytes.
   (slice1)    Executor memory: 50K bytes avg x 3 workers, 50K bytes max (seg0).
   (slice2)    Executor memory: 66K bytes (seg0).
 Memory used:  128000kB
 Optimizer: Postgres query optimizer
 Total runtime: 3.470 ms
(16 rows)

:explain select * from r2 a join d1 b using (c1, c2);
                                                                QUERY PLAN                                                                 
-------------------------------------------------------------------------------------------------------------------------------------------
 Hash Join  (cost=1877.50..1268319.05 rows=5056 width=24) (actual time=1.428..1.428 rows=0 loops=2)
   Hash Cond: a.c1 = b.c1 AND a.c2 = b.c2
   Extra Text: Hash chain length 0.0 avg, 0 max, using 0 of 524288 buckets.
   ->  Gather Motion 2:1  (slice1; segments: 2)  (cost=0.00..2233.00 rows=71100 width=16) (never executed)
         ->  Seq Scan on r2 a  (cost=0.00..811.00 rows=23700 width=16) (actual time=0.000..0.023 rows=0 loops=1)
   ->  Hash  (cost=811.00..811.00 rows=23700 width=16) (actual time=0.648..0.648 rows=0 loops=2)
         Buckets: 524288  Batches: 1  Memory Usage: 0kB
         ->  Gather Motion 1:1  (slice2; segments: 1)  (cost=811.00..811.00 rows=71100 width=16) (actual time=0.647..0.647 rows=0 loops=2)
               ->  Seq Scan on d1 b  (cost=0.00..811.00 rows=23700 width=16) (actual time=0.000..0.009 rows=0 loops=1)
   (slice0)    Executor memory: 4234K bytes.
   (slice1)    Executor memory: 50K bytes avg x 3 workers, 50K bytes max (seg0).
   (slice2)    Executor memory: 66K bytes (seg0).
 Memory used:  128000kB
 Optimizer: Postgres query optimizer
 Total runtime: 3.332 ms
(16 rows)

:explain select * from r2 a join r1 b using (c1);
                                                              QUERY PLAN                                                              
--------------------------------------------------------------------------------------------------------------------------------------
 Gather Motion 1:1  (slice2; segments: 1)  (cost=1699.75..1952143.85 rows=5055210 width=28) (actual time=1.328..1.328 rows=0 loops=2)
   ->  Hash Join  (cost=1699.75..1952143.85 rows=1685070 width=28) (actual time=0.000..2.378 rows=0 loops=1)
         Hash Cond: a.c1 = b.c1
         ->  Broadcast Motion 2:1  (slice1; segments: 2)  (cost=0.00..3655.00 rows=71100 width=16) (never executed)
               ->  Seq Scan on r2 a  (cost=0.00..811.00 rows=23700 width=16) (actual time=0.000..0.009 rows=0 loops=1)
         ->  Hash  (cost=811.00..811.00 rows=23700 width=16) (actual time=0.000..0.033 rows=0 loops=1)
               ->  Seq Scan on r1 b  (cost=0.00..811.00 rows=23700 width=16) (actual time=0.000..0.032 rows=0 loops=1)
   (slice0)    Executor memory: 386K bytes.
   (slice1)    Executor memory: 66K bytes avg x 3 workers, 66K bytes max (seg0).
   (slice2)    Executor memory: 4182K bytes avg x 3 workers, 4182K bytes max (seg0).
 Memory used:  128000kB
 Optimizer: Postgres query optimizer
 Total runtime: 3.497 ms
(13 rows)

:explain select * from r2 a join r1 b using (c1, c2);
                                                            QUERY PLAN                                                             
-----------------------------------------------------------------------------------------------------------------------------------
 Gather Motion 1:1  (slice2; segments: 1)  (cost=1877.50..3798057.05 rows=5056 width=24) (actual time=1.363..1.363 rows=0 loops=2)
   ->  Hash Join  (cost=1877.50..3798057.05 rows=1686 width=24) (actual time=0.000..2.437 rows=0 loops=1)
         Hash Cond: a.c1 = b.c1 AND a.c2 = b.c2
         ->  Broadcast Motion 2:1  (slice1; segments: 2)  (cost=0.00..3655.00 rows=71100 width=16) (never executed)
               ->  Seq Scan on r2 a  (cost=0.00..811.00 rows=23700 width=16) (actual time=0.000..0.017 rows=0 loops=1)
         ->  Hash  (cost=811.00..811.00 rows=23700 width=16) (actual time=0.000..0.035 rows=0 loops=1)
               ->  Seq Scan on r1 b  (cost=0.00..811.00 rows=23700 width=16) (actual time=0.000..0.033 rows=0 loops=1)
   (slice0)    Executor memory: 386K bytes.
   (slice1)    Executor memory: 66K bytes avg x 3 workers, 66K bytes max (seg0).
   (slice2)    Executor memory: 4182K bytes avg x 3 workers, 4182K bytes max (seg0).
 Memory used:  128000kB
 Optimizer: Postgres query optimizer
 Total runtime: 3.561 ms
(13 rows)

-- x2 join y2
:explain select * from t2 a join t2 b using (c1);
                                                                      QUERY PLAN                                                                      
------------------------------------------------------------------------------------------------------------------------------------------------------
 Gather Motion 2:1  (slice3; segments: 2)  (cost=3121.75..687985.85 rows=5055210 width=28) (actual time=2.625..2.625 rows=0 loops=2)
   ->  Hash Join  (cost=3121.75..687985.85 rows=1685070 width=28) (actual time=0.000..4.832 rows=0 loops=1)
         Hash Cond: a.c1 = b.c1
         ->  Redistribute Motion 2:2  (slice1; segments: 2)  (cost=0.00..2233.00 rows=23700 width=16) (never executed)
               Hash Key: a.c1
               ->  Seq Scan on t2 a  (cost=0.00..811.00 rows=23700 width=16) (actual time=0.000..0.012 rows=0 loops=1)
         ->  Hash  (cost=2233.00..2233.00 rows=23700 width=16) (actual time=0.000..3.169 rows=0 loops=1)
               ->  Redistribute Motion 2:2  (slice2; segments: 2)  (cost=0.00..2233.00 rows=23700 width=16) (actual time=0.000..3.167 rows=0 loops=1)
                     Hash Key: b.c1
                     ->  Seq Scan on t2 b  (cost=0.00..811.00 rows=23700 width=16) (actual time=0.000..0.024 rows=0 loops=1)
   (slice0)    Executor memory: 390K bytes.
   (slice1)    Executor memory: 66K bytes avg x 3 workers, 66K bytes max (seg0).
   (slice2)    Executor memory: 66K bytes avg x 3 workers, 66K bytes max (seg0).
   (slice3)    Executor memory: 4174K bytes avg x 3 workers, 4174K bytes max (seg0).
 Memory used:  128000kB
 Optimizer: Postgres query optimizer
 Total runtime: 12.201 ms
(17 rows)

:explain select * from t2 a join t2 b using (c1, c2);
                                                            QUERY PLAN                                                             
-----------------------------------------------------------------------------------------------------------------------------------
 Gather Motion 2:1  (slice1; segments: 2)  (cost=1877.50..1266897.05 rows=5056 width=24) (actual time=0.189..0.189 rows=0 loops=2)
   ->  Hash Join  (cost=1877.50..1266897.05 rows=1686 width=24) (actual time=0.000..0.017 rows=0 loops=1)
         Hash Cond: a.c1 = b.c1 AND a.c2 = b.c2
         ->  Seq Scan on t2 a  (cost=0.00..811.00 rows=23700 width=16) (actual time=0.000..0.017 rows=0 loops=1)
         ->  Hash  (cost=811.00..811.00 rows=23700 width=16) (never executed)
               ->  Seq Scan on t2 b  (cost=0.00..811.00 rows=23700 width=16) (never executed)
   (slice0)    Executor memory: 386K bytes.
   (slice1)    Executor memory: 78K bytes avg x 3 workers, 78K bytes max (seg0).
 Memory used:  128000kB
 Optimizer: Postgres query optimizer
 Total runtime: 0.957 ms
(11 rows)

:explain select * from t2 a join d2 b using (c1);
                                                             QUERY PLAN                                                              
-------------------------------------------------------------------------------------------------------------------------------------
 Gather Motion 2:1  (slice1; segments: 2)  (cost=1699.75..685141.85 rows=5055210 width=28) (actual time=0.287..0.287 rows=0 loops=2)
   ->  Hash Join  (cost=1699.75..685141.85 rows=1685070 width=28) (actual time=0.000..0.017 rows=0 loops=1)
         Hash Cond: a.c1 = b.c1
         ->  Seq Scan on t2 a  (cost=0.00..811.00 rows=23700 width=16) (actual time=0.000..0.015 rows=0 loops=1)
         ->  Hash  (cost=811.00..811.00 rows=23700 width=16) (never executed)
               ->  Seq Scan on d2 b  (cost=0.00..811.00 rows=23700 width=16) (never executed)
   (slice0)    Executor memory: 386K bytes.
   (slice1)    Executor memory: 98K bytes avg x 3 workers, 98K bytes max (seg0).
 Memory used:  128000kB
 Optimizer: Postgres query optimizer
 Total runtime: 0.908 ms
(11 rows)

:explain select * from t2 a join d2 b using (c1, c2);
                                                            QUERY PLAN                                                             
-----------------------------------------------------------------------------------------------------------------------------------
 Gather Motion 2:1  (slice1; segments: 2)  (cost=1877.50..1266897.05 rows=5056 width=24) (actual time=0.312..0.312 rows=0 loops=2)
   ->  Hash Join  (cost=1877.50..1266897.05 rows=1686 width=24) (actual time=0.000..0.017 rows=0 loops=1)
         Hash Cond: a.c1 = b.c1 AND a.c2 = b.c2
         ->  Seq Scan on t2 a  (cost=0.00..811.00 rows=23700 width=16) (actual time=0.000..0.017 rows=0 loops=1)
         ->  Hash  (cost=811.00..811.00 rows=23700 width=16) (never executed)
               ->  Seq Scan on d2 b  (cost=0.00..811.00 rows=23700 width=16) (never executed)
   (slice0)    Executor memory: 386K bytes.
   (slice1)    Executor memory: 98K bytes avg x 3 workers, 98K bytes max (seg0).
 Memory used:  128000kB
 Optimizer: Postgres query optimizer
 Total runtime: 0.960 ms
(11 rows)

:explain select * from t2 a join r2 b using (c1);
                                                                      QUERY PLAN                                                                      
------------------------------------------------------------------------------------------------------------------------------------------------------
 Gather Motion 2:1  (slice3; segments: 2)  (cost=3121.75..687985.85 rows=5055210 width=28) (actual time=1.421..1.421 rows=0 loops=2)
   ->  Hash Join  (cost=3121.75..687985.85 rows=1685070 width=28) (actual time=0.000..3.165 rows=0 loops=1)
         Hash Cond: a.c1 = b.c1
         ->  Redistribute Motion 2:2  (slice1; segments: 2)  (cost=0.00..2233.00 rows=23700 width=16) (never executed)
               Hash Key: a.c1
               ->  Seq Scan on t2 a  (cost=0.00..811.00 rows=23700 width=16) (actual time=0.000..0.016 rows=0 loops=1)
         ->  Hash  (cost=2233.00..2233.00 rows=23700 width=16) (actual time=0.000..1.204 rows=0 loops=1)
               ->  Redistribute Motion 2:2  (slice2; segments: 2)  (cost=0.00..2233.00 rows=23700 width=16) (actual time=0.000..1.203 rows=0 loops=1)
                     Hash Key: b.c1
                     ->  Seq Scan on r2 b  (cost=0.00..811.00 rows=23700 width=16) (actual time=0.000..0.010 rows=0 loops=1)
   (slice0)    Executor memory: 390K bytes.
   (slice1)    Executor memory: 66K bytes avg x 3 workers, 66K bytes max (seg0).
   (slice2)    Executor memory: 66K bytes avg x 3 workers, 66K bytes max (seg0).
   (slice3)    Executor memory: 4174K bytes avg x 3 workers, 4174K bytes max (seg0).
 Memory used:  128000kB
 Optimizer: Postgres query optimizer
 Total runtime: 4.328 ms
(17 rows)

:explain select * from t2 a join r2 b using (c1, c2);
                                                            QUERY PLAN                                                             
-----------------------------------------------------------------------------------------------------------------------------------
 Gather Motion 2:1  (slice2; segments: 2)  (cost=1877.50..1268319.05 rows=5056 width=24) (actual time=1.399..1.399 rows=0 loops=2)
   ->  Hash Join  (cost=1877.50..1268319.05 rows=1686 width=24) (actual time=0.000..2.266 rows=0 loops=1)
         Hash Cond: b.c1 = a.c1 AND b.c2 = a.c2
         ->  Redistribute Motion 2:2  (slice1; segments: 2)  (cost=0.00..2233.00 rows=23700 width=16) (never executed)
               Hash Key: b.c1, b.c2
               ->  Seq Scan on r2 b  (cost=0.00..811.00 rows=23700 width=16) (actual time=0.000..0.010 rows=0 loops=1)
         ->  Hash  (cost=811.00..811.00 rows=23700 width=16) (actual time=0.000..0.027 rows=0 loops=1)
               ->  Seq Scan on t2 a  (cost=0.00..811.00 rows=23700 width=16) (actual time=0.000..0.026 rows=0 loops=1)
   (slice0)    Executor memory: 386K bytes.
   (slice1)    Executor memory: 66K bytes avg x 3 workers, 66K bytes max (seg0).
   (slice2)    Executor memory: 4182K bytes avg x 3 workers, 4182K bytes max (seg0).
 Memory used:  128000kB
 Optimizer: Postgres query optimizer
 Total runtime: 3.556 ms
(14 rows)

:explain select * from d2 a join t2 b using (c1);
                                                             QUERY PLAN                                                              
-------------------------------------------------------------------------------------------------------------------------------------
 Gather Motion 2:1  (slice1; segments: 2)  (cost=1699.75..685141.85 rows=5055210 width=28) (actual time=0.185..0.185 rows=0 loops=2)
   ->  Hash Join  (cost=1699.75..685141.85 rows=1685070 width=28) (actual time=0.000..0.017 rows=0 loops=1)
         Hash Cond: a.c1 = b.c1
         ->  Seq Scan on d2 a  (cost=0.00..811.00 rows=23700 width=16) (actual time=0.000..0.017 rows=0 loops=1)
         ->  Hash  (cost=811.00..811.00 rows=23700 width=16) (never executed)
               ->  Seq Scan on t2 b  (cost=0.00..811.00 rows=23700 width=16) (never executed)
   (slice0)    Executor memory: 386K bytes.
   (slice1)    Executor memory: 98K bytes avg x 3 workers, 98K bytes max (seg0).
 Memory used:  128000kB
 Optimizer: Postgres query optimizer
 Total runtime: 0.972 ms
(11 rows)

:explain select * from d2 a join t2 b using (c1, c2);
                                                            QUERY PLAN                                                             
-----------------------------------------------------------------------------------------------------------------------------------
 Gather Motion 2:1  (slice1; segments: 2)  (cost=1877.50..1266897.05 rows=5056 width=24) (actual time=0.197..0.197 rows=0 loops=2)
   ->  Hash Join  (cost=1877.50..1266897.05 rows=1686 width=24) (actual time=0.000..0.017 rows=0 loops=1)
         Hash Cond: a.c1 = b.c1 AND a.c2 = b.c2
         ->  Seq Scan on d2 a  (cost=0.00..811.00 rows=23700 width=16) (actual time=0.000..0.016 rows=0 loops=1)
         ->  Hash  (cost=811.00..811.00 rows=23700 width=16) (never executed)
               ->  Seq Scan on t2 b  (cost=0.00..811.00 rows=23700 width=16) (never executed)
   (slice0)    Executor memory: 386K bytes.
   (slice1)    Executor memory: 98K bytes avg x 3 workers, 98K bytes max (seg0).
 Memory used:  128000kB
 Optimizer: Postgres query optimizer
 Total runtime: 0.972 ms
(11 rows)

:explain select * from d2 a join d2 b using (c1);
                                                             QUERY PLAN                                                              
-------------------------------------------------------------------------------------------------------------------------------------
 Gather Motion 1:1  (slice1; segments: 1)  (cost=1699.75..685141.85 rows=5055210 width=28) (actual time=0.196..0.196 rows=0 loops=2)
   ->  Hash Join  (cost=1699.75..685141.85 rows=1685070 width=28) (actual time=0.000..0.015 rows=0 loops=1)
         Hash Cond: a.c1 = b.c1
         ->  Seq Scan on d2 a  (cost=0.00..811.00 rows=23700 width=16) (actual time=0.000..0.015 rows=0 loops=1)
         ->  Hash  (cost=811.00..811.00 rows=23700 width=16) (never executed)
               ->  Seq Scan on d2 b  (cost=0.00..811.00 rows=23700 width=16) (never executed)
   (slice0)    Executor memory: 386K bytes.
   (slice1)    Executor memory: 78K bytes (seg0).
 Memory used:  128000kB
 Optimizer: Postgres query optimizer
 Total runtime: 0.893 ms
(11 rows)

:explain select * from d2 a join d2 b using (c1, c2);
                                                            QUERY PLAN                                                             
-----------------------------------------------------------------------------------------------------------------------------------
 Gather Motion 1:1  (slice1; segments: 1)  (cost=1877.50..1266897.05 rows=5056 width=24) (actual time=0.189..0.189 rows=0 loops=2)
   ->  Hash Join  (cost=1877.50..1266897.05 rows=1686 width=24) (actual time=0.000..0.013 rows=0 loops=1)
         Hash Cond: a.c1 = b.c1 AND a.c2 = b.c2
         ->  Seq Scan on d2 a  (cost=0.00..811.00 rows=23700 width=16) (actual time=0.000..0.013 rows=0 loops=1)
         ->  Hash  (cost=811.00..811.00 rows=23700 width=16) (never executed)
               ->  Seq Scan on d2 b  (cost=0.00..811.00 rows=23700 width=16) (never executed)
   (slice0)    Executor memory: 386K bytes.
   (slice1)    Executor memory: 78K bytes (seg0).
 Memory used:  128000kB
 Optimizer: Postgres query optimizer
 Total runtime: 0.869 ms
(11 rows)

:explain select * from d2 a join r2 b using (c1);
                                                             QUERY PLAN                                                              
-------------------------------------------------------------------------------------------------------------------------------------
 Gather Motion 2:1  (slice1; segments: 2)  (cost=1699.75..685141.85 rows=5055210 width=28) (actual time=0.201..0.201 rows=0 loops=2)
   ->  Hash Join  (cost=1699.75..685141.85 rows=1685070 width=28) (actual time=0.000..0.103 rows=0 loops=1)
         Hash Cond: a.c1 = b.c1
         ->  Seq Scan on d2 a  (cost=0.00..811.00 rows=23700 width=16) (actual time=0.000..0.103 rows=0 loops=1)
         ->  Hash  (cost=811.00..811.00 rows=23700 width=16) (never executed)
               ->  Seq Scan on r2 b  (cost=0.00..811.00 rows=23700 width=16) (never executed)
   (slice0)    Executor memory: 386K bytes.
   (slice1)    Executor memory: 98K bytes avg x 3 workers, 98K bytes max (seg0).
 Memory used:  128000kB
 Optimizer: Postgres query optimizer
 Total runtime: 1.087 ms
(11 rows)

:explain select * from d2 a join r2 b using (c1, c2);
                                                            QUERY PLAN                                                             
-----------------------------------------------------------------------------------------------------------------------------------
 Gather Motion 2:1  (slice1; segments: 2)  (cost=1877.50..1266897.05 rows=5056 width=24) (actual time=0.216..0.216 rows=0 loops=2)
   ->  Hash Join  (cost=1877.50..1266897.05 rows=1686 width=24) (actual time=0.000..0.019 rows=0 loops=1)
         Hash Cond: a.c1 = b.c1 AND a.c2 = b.c2
         ->  Seq Scan on d2 a  (cost=0.00..811.00 rows=23700 width=16) (actual time=0.000..0.019 rows=0 loops=1)
         ->  Hash  (cost=811.00..811.00 rows=23700 width=16) (never executed)
               ->  Seq Scan on r2 b  (cost=0.00..811.00 rows=23700 width=16) (never executed)
   (slice0)    Executor memory: 386K bytes.
   (slice1)    Executor memory: 98K bytes avg x 3 workers, 98K bytes max (seg0).
 Memory used:  128000kB
 Optimizer: Postgres query optimizer
 Total runtime: 1.045 ms
(11 rows)

:explain select * from r2 a join t2 b using (c1);
                                                                      QUERY PLAN                                                                      
------------------------------------------------------------------------------------------------------------------------------------------------------
 Gather Motion 2:1  (slice3; segments: 2)  (cost=3121.75..687985.85 rows=5055210 width=28) (actual time=1.552..1.552 rows=0 loops=2)
   ->  Hash Join  (cost=3121.75..687985.85 rows=1685070 width=28) (actual time=0.000..3.164 rows=0 loops=1)
         Hash Cond: a.c1 = b.c1
         ->  Redistribute Motion 2:2  (slice1; segments: 2)  (cost=0.00..2233.00 rows=23700 width=16) (never executed)
               Hash Key: a.c1
               ->  Seq Scan on r2 a  (cost=0.00..811.00 rows=23700 width=16) (actual time=0.000..0.016 rows=0 loops=1)
         ->  Hash  (cost=2233.00..2233.00 rows=23700 width=16) (actual time=0.000..1.273 rows=0 loops=1)
               ->  Redistribute Motion 2:2  (slice2; segments: 2)  (cost=0.00..2233.00 rows=23700 width=16) (actual time=0.000..1.271 rows=0 loops=1)
                     Hash Key: b.c1
                     ->  Seq Scan on t2 b  (cost=0.00..811.00 rows=23700 width=16) (actual time=0.000..0.015 rows=0 loops=1)
   (slice0)    Executor memory: 390K bytes.
   (slice1)    Executor memory: 66K bytes avg x 3 workers, 66K bytes max (seg0).
   (slice2)    Executor memory: 66K bytes avg x 3 workers, 66K bytes max (seg0).
   (slice3)    Executor memory: 4174K bytes avg x 3 workers, 4174K bytes max (seg0).
 Memory used:  128000kB
 Optimizer: Postgres query optimizer
 Total runtime: 4.302 ms
(17 rows)

:explain select * from r2 a join t2 b using (c1, c2);
                                                            QUERY PLAN                                                             
-----------------------------------------------------------------------------------------------------------------------------------
 Gather Motion 2:1  (slice2; segments: 2)  (cost=1877.50..1268319.05 rows=5056 width=24) (actual time=1.061..1.061 rows=0 loops=2)
   ->  Hash Join  (cost=1877.50..1268319.05 rows=1686 width=24) (actual time=0.000..2.453 rows=0 loops=1)
         Hash Cond: a.c1 = b.c1 AND a.c2 = b.c2
         ->  Redistribute Motion 2:2  (slice1; segments: 2)  (cost=0.00..2233.00 rows=23700 width=16) (never executed)
               Hash Key: a.c1, a.c2
               ->  Seq Scan on r2 a  (cost=0.00..811.00 rows=23700 width=16) (actual time=0.000..0.011 rows=0 loops=1)
         ->  Hash  (cost=811.00..811.00 rows=23700 width=16) (actual time=0.000..0.039 rows=0 loops=1)
               ->  Seq Scan on t2 b  (cost=0.00..811.00 rows=23700 width=16) (actual time=0.000..0.037 rows=0 loops=1)
   (slice0)    Executor memory: 386K bytes.
   (slice1)    Executor memory: 66K bytes avg x 3 workers, 66K bytes max (seg0).
   (slice2)    Executor memory: 4182K bytes avg x 3 workers, 4182K bytes max (seg0).
 Memory used:  128000kB
 Optimizer: Postgres query optimizer
 Total runtime: 3.654 ms
(14 rows)

:explain select * from r2 a join d2 b using (c1);
                                                             QUERY PLAN                                                              
-------------------------------------------------------------------------------------------------------------------------------------
 Gather Motion 2:1  (slice1; segments: 2)  (cost=1699.75..685141.85 rows=5055210 width=28) (actual time=0.245..0.245 rows=0 loops=2)
   ->  Hash Join  (cost=1699.75..685141.85 rows=1685070 width=28) (actual time=0.000..0.018 rows=0 loops=1)
         Hash Cond: a.c1 = b.c1
         ->  Seq Scan on r2 a  (cost=0.00..811.00 rows=23700 width=16) (actual time=0.000..0.017 rows=0 loops=1)
         ->  Hash  (cost=811.00..811.00 rows=23700 width=16) (never executed)
               ->  Seq Scan on d2 b  (cost=0.00..811.00 rows=23700 width=16) (never executed)
   (slice0)    Executor memory: 386K bytes.
   (slice1)    Executor memory: 98K bytes avg x 3 workers, 98K bytes max (seg0).
 Memory used:  128000kB
 Optimizer: Postgres query optimizer
 Total runtime: 1.075 ms
(11 rows)

:explain select * from r2 a join d2 b using (c1, c2);
                                                            QUERY PLAN                                                             
-----------------------------------------------------------------------------------------------------------------------------------
 Gather Motion 2:1  (slice1; segments: 2)  (cost=1877.50..1266897.05 rows=5056 width=24) (actual time=0.180..0.180 rows=0 loops=2)
   ->  Hash Join  (cost=1877.50..1266897.05 rows=1686 width=24) (actual time=0.000..0.017 rows=0 loops=1)
         Hash Cond: a.c1 = b.c1 AND a.c2 = b.c2
         ->  Seq Scan on r2 a  (cost=0.00..811.00 rows=23700 width=16) (actual time=0.000..0.017 rows=0 loops=1)
         ->  Hash  (cost=811.00..811.00 rows=23700 width=16) (never executed)
               ->  Seq Scan on d2 b  (cost=0.00..811.00 rows=23700 width=16) (never executed)
   (slice0)    Executor memory: 386K bytes.
   (slice1)    Executor memory: 98K bytes avg x 3 workers, 98K bytes max (seg0).
 Memory used:  128000kB
 Optimizer: Postgres query optimizer
 Total runtime: 0.943 ms
(11 rows)

:explain select * from r2 a join r2 b using (c1);
                                                                      QUERY PLAN                                                                      
------------------------------------------------------------------------------------------------------------------------------------------------------
 Gather Motion 2:1  (slice3; segments: 2)  (cost=3121.75..687985.85 rows=5055210 width=28) (actual time=1.821..1.821 rows=0 loops=2)
   ->  Hash Join  (cost=3121.75..687985.85 rows=1685070 width=28) (actual time=0.000..3.395 rows=0 loops=1)
         Hash Cond: a.c1 = b.c1
         ->  Redistribute Motion 2:2  (slice1; segments: 2)  (cost=0.00..2233.00 rows=23700 width=16) (never executed)
               Hash Key: a.c1
               ->  Seq Scan on r2 a  (cost=0.00..811.00 rows=23700 width=16) (actual time=0.000..0.017 rows=0 loops=1)
         ->  Hash  (cost=2233.00..2233.00 rows=23700 width=16) (actual time=0.000..1.527 rows=0 loops=1)
               ->  Redistribute Motion 2:2  (slice2; segments: 2)  (cost=0.00..2233.00 rows=23700 width=16) (actual time=0.000..1.526 rows=0 loops=1)
                     Hash Key: b.c1
                     ->  Seq Scan on r2 b  (cost=0.00..811.00 rows=23700 width=16) (actual time=0.000..0.014 rows=0 loops=1)
   (slice0)    Executor memory: 390K bytes.
   (slice1)    Executor memory: 66K bytes avg x 3 workers, 66K bytes max (seg0).
   (slice2)    Executor memory: 66K bytes avg x 3 workers, 66K bytes max (seg0).
   (slice3)    Executor memory: 4174K bytes avg x 3 workers, 4174K bytes max (seg0).
 Memory used:  128000kB
 Optimizer: Postgres query optimizer
 Total runtime: 4.498 ms
(17 rows)

:explain select * from r2 a join r2 b using (c1, c2);
                                                                      QUERY PLAN                                                                      
------------------------------------------------------------------------------------------------------------------------------------------------------
 Gather Motion 2:1  (slice3; segments: 2)  (cost=3299.50..1269741.05 rows=5056 width=24) (actual time=2.001..2.001 rows=0 loops=2)
   ->  Hash Join  (cost=3299.50..1269741.05 rows=1686 width=24) (actual time=0.000..3.243 rows=0 loops=1)
         Hash Cond: a.c1 = b.c1 AND a.c2 = b.c2
         ->  Redistribute Motion 2:2  (slice1; segments: 2)  (cost=0.00..2233.00 rows=23700 width=16) (never executed)
               Hash Key: a.c1, a.c2
               ->  Seq Scan on r2 a  (cost=0.00..811.00 rows=23700 width=16) (actual time=0.000..0.010 rows=0 loops=1)
         ->  Hash  (cost=2233.00..2233.00 rows=23700 width=16) (actual time=0.000..1.378 rows=0 loops=1)
               ->  Redistribute Motion 2:2  (slice2; segments: 2)  (cost=0.00..2233.00 rows=23700 width=16) (actual time=0.000..1.377 rows=0 loops=1)
                     Hash Key: b.c1, b.c2
                     ->  Seq Scan on r2 b  (cost=0.00..811.00 rows=23700 width=16) (actual time=0.000..0.009 rows=0 loops=1)
   (slice0)    Executor memory: 390K bytes.
   (slice1)    Executor memory: 66K bytes avg x 3 workers, 66K bytes max (seg0).
   (slice2)    Executor memory: 66K bytes avg x 3 workers, 66K bytes max (seg0).
   (slice3)    Executor memory: 4174K bytes avg x 3 workers, 4174K bytes max (seg0).
 Memory used:  128000kB
 Optimizer: Postgres query optimizer
 Total runtime: 4.819 ms
(17 rows)

-- x1 left join y1
:explain select * from t1 a left join t1 b using (c1);
                                                             QUERY PLAN                                                              
-------------------------------------------------------------------------------------------------------------------------------------
 Gather Motion 1:1  (slice1; segments: 1)  (cost=1699.75..685141.85 rows=5055210 width=28) (actual time=0.278..0.278 rows=0 loops=2)
   ->  Hash Left Join  (cost=1699.75..685141.85 rows=1685070 width=28) (actual time=0.000..0.021 rows=0 loops=1)
         Hash Cond: (a.c1 = b.c1)
         ->  Seq Scan on t1 a  (cost=0.00..811.00 rows=23700 width=16) (actual time=0.000..0.020 rows=0 loops=1)
         ->  Hash  (cost=811.00..811.00 rows=23700 width=16) (never executed)
               ->  Seq Scan on t1 b  (cost=0.00..811.00 rows=23700 width=16) (never executed)
   (slice0)    Executor memory: 386K bytes.
   (slice1)    Executor memory: 66K bytes avg x 3 workers, 66K bytes max (seg0).
   (slice2)    Executor memory: 4182K bytes avg x 3 workers, 4182K bytes max (seg0).
 Memory used:  128000kB
 Optimizer: Postgres query optimizer
 Total runtime: 3.543 ms
(13 rows)

:explain select * from t1 a left join t1 b using (c1, c2);
                                                             QUERY PLAN                                                             
------------------------------------------------------------------------------------------------------------------------------------
 Gather Motion 1:1  (slice1; segments: 1)  (cost=1877.50..1267557.50 rows=71100 width=24) (actual time=0.172..0.172 rows=0 loops=2)
   ->  Hash Left Join  (cost=1877.50..1267557.50 rows=23700 width=24) (actual time=0.000..0.017 rows=0 loops=1)
         Hash Cond: a.c1 = b.c1 AND a.c2 = b.c2
         ->  Seq Scan on t1 a  (cost=0.00..811.00 rows=23700 width=16) (actual time=0.000..0.016 rows=0 loops=1)
         ->  Hash  (cost=811.00..811.00 rows=23700 width=16) (never executed)
               ->  Seq Scan on t1 b  (cost=0.00..811.00 rows=23700 width=16) (never executed)
   (slice0)    Executor memory: 386K bytes.
   (slice1)    Executor memory: 78K bytes avg x 3 workers, 78K bytes max (seg0).
 Memory used:  128000kB
 Optimizer: Postgres query optimizer
 Total runtime: 0.907 ms
(11 rows)

:explain select * from t1 a left join d1 b using (c1);
                                                             QUERY PLAN                                                              
-------------------------------------------------------------------------------------------------------------------------------------
 Gather Motion 1:1  (slice1; segments: 1)  (cost=1699.75..685141.85 rows=5055210 width=28) (actual time=0.200..0.200 rows=0 loops=2)
   ->  Hash Left Join  (cost=1699.75..685141.85 rows=1685070 width=28) (actual time=0.000..0.017 rows=0 loops=1)
         Hash Cond: a.c1 = b.c1
         ->  Seq Scan on t1 a  (cost=0.00..811.00 rows=23700 width=16) (actual time=0.000..0.017 rows=0 loops=1)
         ->  Hash  (cost=811.00..811.00 rows=23700 width=16) (never executed)
               ->  Seq Scan on d1 b  (cost=0.00..811.00 rows=23700 width=16) (never executed)
   (slice0)    Executor memory: 386K bytes.
   (slice1)    Executor memory: 98K bytes avg x 3 workers, 98K bytes max (seg0).
 Memory used:  128000kB
 Optimizer: Postgres query optimizer
 Total runtime: 0.952 ms
(11 rows)

:explain select * from t1 a left join d1 b using (c1, c2);
                                                             QUERY PLAN                                                             
------------------------------------------------------------------------------------------------------------------------------------
 Gather Motion 1:1  (slice1; segments: 1)  (cost=1877.50..1267557.50 rows=71100 width=24) (actual time=0.183..0.183 rows=0 loops=2)
   ->  Hash Left Join  (cost=1877.50..1267557.50 rows=23700 width=24) (actual time=0.000..0.077 rows=0 loops=1)
         Hash Cond: a.c1 = b.c1 AND a.c2 = b.c2
         ->  Seq Scan on t1 a  (cost=0.00..811.00 rows=23700 width=16) (actual time=0.000..0.076 rows=0 loops=1)
         ->  Hash  (cost=811.00..811.00 rows=23700 width=16) (never executed)
               ->  Seq Scan on d1 b  (cost=0.00..811.00 rows=23700 width=16) (never executed)
   (slice0)    Executor memory: 386K bytes.
   (slice1)    Executor memory: 98K bytes avg x 3 workers, 98K bytes max (seg0).
 Memory used:  128000kB
 Optimizer: Postgres query optimizer
 Total runtime: 0.982 ms
(11 rows)

:explain select * from t1 a left join r1 b using (c1);
                                                             QUERY PLAN                                                              
-------------------------------------------------------------------------------------------------------------------------------------
 Gather Motion 1:1  (slice1; segments: 1)  (cost=1699.75..685141.85 rows=5055210 width=28) (actual time=0.282..0.282 rows=0 loops=2)
   ->  Hash Left Join  (cost=1699.75..685141.85 rows=1685070 width=28) (actual time=0.000..0.016 rows=0 loops=1)
         Hash Cond: (a.c1 = b.c1)
         ->  Seq Scan on t1 a  (cost=0.00..811.00 rows=23700 width=16) (actual time=0.000..0.015 rows=0 loops=1)
         ->  Hash  (cost=811.00..811.00 rows=23700 width=16) (never executed)
               ->  Seq Scan on r1 b  (cost=0.00..811.00 rows=23700 width=16) (never executed)
   (slice0)    Executor memory: 386K bytes.
   (slice1)    Executor memory: 66K bytes avg x 3 workers, 66K bytes max (seg0).
   (slice2)    Executor memory: 4182K bytes avg x 3 workers, 4182K bytes max (seg0).
 Memory used:  128000kB
 Optimizer: Postgres query optimizer
 Total runtime: 3.448 ms
(13 rows)

:explain select * from t1 a left join r1 b using (c1, c2);
                                                             QUERY PLAN                                                             
------------------------------------------------------------------------------------------------------------------------------------
 Gather Motion 1:1  (slice1; segments: 1)  (cost=1877.50..1267557.50 rows=71100 width=24) (actual time=0.259..0.259 rows=0 loops=2)
   ->  Hash Left Join  (cost=1877.50..1267557.50 rows=23700 width=24) (actual time=0.000..0.014 rows=0 loops=1)
         Hash Cond: ((a.c1 = b.c1) AND (a.c2 = b.c2))
         ->  Seq Scan on t1 a  (cost=0.00..811.00 rows=23700 width=16) (actual time=0.000..0.014 rows=0 loops=1)
         ->  Hash  (cost=811.00..811.00 rows=23700 width=16) (never executed)
               ->  Seq Scan on r1 b  (cost=0.00..811.00 rows=23700 width=16) (never executed)
   (slice0)    Executor memory: 386K bytes.
   (slice1)    Executor memory: 66K bytes avg x 3 workers, 66K bytes max (seg0).
   (slice2)    Executor memory: 4182K bytes avg x 3 workers, 4182K bytes max (seg0).
 Memory used:  128000kB
 Optimizer: Postgres query optimizer
 Total runtime: 3.552 ms
(14 rows)

:explain select * from d1 a left join t1 b using (c1);
                                                                QUERY PLAN                                                                 
-------------------------------------------------------------------------------------------------------------------------------------------
 Hash Right Join  (cost=1699.75..686563.85 rows=5055210 width=28) (actual time=1.584..1.584 rows=0 loops=2)
   Hash Cond: b.c1 = a.c1
   Extra Text: Hash chain length 0.0 avg, 0 max, using 0 of 524288 buckets.
   ->  Gather Motion 1:1  (slice1; segments: 1)  (cost=0.00..2233.00 rows=71100 width=16) (never executed)
         ->  Seq Scan on t1 b  (cost=0.00..811.00 rows=23700 width=16) (actual time=0.000..0.017 rows=0 loops=1)
   ->  Hash  (cost=811.00..811.00 rows=23700 width=16) (actual time=0.676..0.676 rows=0 loops=2)
         Buckets: 524288  Batches: 1  Memory Usage: 0kB
         ->  Gather Motion 1:1  (slice2; segments: 1)  (cost=811.00..811.00 rows=71100 width=16) (actual time=0.675..0.675 rows=0 loops=2)
               ->  Seq Scan on d1 a  (cost=0.00..811.00 rows=23700 width=16) (actual time=0.000..0.010 rows=0 loops=1)
   (slice0)    Executor memory: 4234K bytes.
   (slice1)    Executor memory: 50K bytes avg x 3 workers, 50K bytes max (seg0).
   (slice2)    Executor memory: 66K bytes (seg0).
 Memory used:  128000kB
 Optimizer: Postgres query optimizer
 Total runtime: 3.561 ms
(16 rows)

:explain select * from d1 a left join t1 b using (c1, c2);
                                                                QUERY PLAN                                                                 
-------------------------------------------------------------------------------------------------------------------------------------------
 Hash Right Join  (cost=1877.50..1268979.50 rows=71100 width=24) (actual time=0.991..0.991 rows=0 loops=2)
   Hash Cond: b.c1 = a.c1 AND b.c2 = a.c2
   Extra Text: Hash chain length 0.0 avg, 0 max, using 0 of 524288 buckets.
   ->  Gather Motion 1:1  (slice1; segments: 1)  (cost=0.00..2233.00 rows=71100 width=16) (never executed)
         ->  Seq Scan on t1 b  (cost=0.00..811.00 rows=23700 width=16) (actual time=0.000..0.017 rows=0 loops=1)
   ->  Hash  (cost=811.00..811.00 rows=23700 width=16) (actual time=0.200..0.200 rows=0 loops=2)
         Buckets: 524288  Batches: 1  Memory Usage: 0kB
         ->  Gather Motion 1:1  (slice2; segments: 1)  (cost=811.00..811.00 rows=71100 width=16) (actual time=0.200..0.200 rows=0 loops=2)
               ->  Seq Scan on d1 a  (cost=0.00..811.00 rows=23700 width=16) (actual time=0.000..0.008 rows=0 loops=1)
   (slice0)    Executor memory: 4234K bytes.
   (slice1)    Executor memory: 50K bytes avg x 3 workers, 50K bytes max (seg0).
   (slice2)    Executor memory: 66K bytes (seg0).
 Memory used:  128000kB
 Optimizer: Postgres query optimizer
 Total runtime: 2.434 ms
(16 rows)

:explain select * from d1 a left join d1 b using (c1);
                                                             QUERY PLAN                                                              
-------------------------------------------------------------------------------------------------------------------------------------
 Gather Motion 1:1  (slice1; segments: 1)  (cost=1699.75..685141.85 rows=5055210 width=28) (actual time=0.205..0.205 rows=0 loops=2)
   ->  Hash Left Join  (cost=1699.75..685141.85 rows=1685070 width=28) (actual time=0.000..0.017 rows=0 loops=1)
         Hash Cond: a.c1 = b.c1
         ->  Seq Scan on d1 a  (cost=0.00..811.00 rows=23700 width=16) (actual time=0.000..0.016 rows=0 loops=1)
         ->  Hash  (cost=811.00..811.00 rows=23700 width=16) (never executed)
               ->  Seq Scan on d1 b  (cost=0.00..811.00 rows=23700 width=16) (never executed)
   (slice0)    Executor memory: 386K bytes.
   (slice1)    Executor memory: 78K bytes (seg0).
 Memory used:  128000kB
 Optimizer: Postgres query optimizer
 Total runtime: 0.985 ms
(11 rows)

:explain select * from d1 a left join d1 b using (c1, c2);
                                                             QUERY PLAN                                                             
------------------------------------------------------------------------------------------------------------------------------------
 Gather Motion 1:1  (slice1; segments: 1)  (cost=1877.50..1267557.50 rows=71100 width=24) (actual time=0.200..0.200 rows=0 loops=2)
   ->  Hash Left Join  (cost=1877.50..1267557.50 rows=23700 width=24) (actual time=0.000..0.015 rows=0 loops=1)
         Hash Cond: a.c1 = b.c1 AND a.c2 = b.c2
         ->  Seq Scan on d1 a  (cost=0.00..811.00 rows=23700 width=16) (actual time=0.000..0.014 rows=0 loops=1)
         ->  Hash  (cost=811.00..811.00 rows=23700 width=16) (never executed)
               ->  Seq Scan on d1 b  (cost=0.00..811.00 rows=23700 width=16) (never executed)
   (slice0)    Executor memory: 386K bytes.
   (slice1)    Executor memory: 78K bytes (seg0).
 Memory used:  128000kB
 Optimizer: Postgres query optimizer
 Total runtime: 0.906 ms
(11 rows)

:explain select * from d1 a left join r1 b using (c1);
                                                                QUERY PLAN                                                                 
-------------------------------------------------------------------------------------------------------------------------------------------
 Hash Right Join  (cost=1699.75..686563.85 rows=5055210 width=28) (actual time=1.578..1.578 rows=0 loops=2)
   Hash Cond: b.c1 = a.c1
   Extra Text: Hash chain length 0.0 avg, 0 max, using 0 of 524288 buckets.
   ->  Gather Motion 1:1  (slice1; segments: 1)  (cost=0.00..2233.00 rows=71100 width=16) (never executed)
         ->  Seq Scan on r1 b  (cost=0.00..811.00 rows=23700 width=16) (actual time=0.000..0.018 rows=0 loops=1)
   ->  Hash  (cost=811.00..811.00 rows=23700 width=16) (actual time=0.702..0.702 rows=0 loops=2)
         Buckets: 524288  Batches: 1  Memory Usage: 0kB
         ->  Gather Motion 1:1  (slice2; segments: 1)  (cost=811.00..811.00 rows=71100 width=16) (actual time=0.700..0.700 rows=0 loops=2)
               ->  Seq Scan on d1 a  (cost=0.00..811.00 rows=23700 width=16) (actual time=0.000..0.010 rows=0 loops=1)
   (slice0)    Executor memory: 4234K bytes.
   (slice1)    Executor memory: 50K bytes avg x 3 workers, 50K bytes max (seg0).
   (slice2)    Executor memory: 66K bytes (seg0).
 Memory used:  128000kB
 Optimizer: Postgres query optimizer
 Total runtime: 3.536 ms
(16 rows)

:explain select * from d1 a left join r1 b using (c1, c2);
                                                                QUERY PLAN                                                                 
-------------------------------------------------------------------------------------------------------------------------------------------
 Hash Right Join  (cost=1877.50..1268979.50 rows=71100 width=24) (actual time=1.507..1.507 rows=0 loops=2)
   Hash Cond: b.c1 = a.c1 AND b.c2 = a.c2
   Extra Text: Hash chain length 0.0 avg, 0 max, using 0 of 524288 buckets.
   ->  Gather Motion 1:1  (slice1; segments: 1)  (cost=0.00..2233.00 rows=71100 width=16) (never executed)
         ->  Seq Scan on r1 b  (cost=0.00..811.00 rows=23700 width=16) (actual time=0.000..0.018 rows=0 loops=1)
   ->  Hash  (cost=811.00..811.00 rows=23700 width=16) (actual time=0.663..0.663 rows=0 loops=2)
         Buckets: 524288  Batches: 1  Memory Usage: 0kB
         ->  Gather Motion 1:1  (slice2; segments: 1)  (cost=811.00..811.00 rows=71100 width=16) (actual time=0.663..0.663 rows=0 loops=2)
               ->  Seq Scan on d1 a  (cost=0.00..811.00 rows=23700 width=16) (actual time=0.000..0.010 rows=0 loops=1)
   (slice0)    Executor memory: 4234K bytes.
   (slice1)    Executor memory: 50K bytes avg x 3 workers, 50K bytes max (seg0).
   (slice2)    Executor memory: 66K bytes (seg0).
 Memory used:  128000kB
 Optimizer: Postgres query optimizer
 Total runtime: 3.429 ms
(16 rows)

:explain select * from r1 a left join t1 b using (c1);
                                                             QUERY PLAN                                                              
-------------------------------------------------------------------------------------------------------------------------------------
 Gather Motion 1:1  (slice1; segments: 1)  (cost=1699.75..685141.85 rows=5055210 width=28) (actual time=0.267..0.267 rows=0 loops=2)
   ->  Hash Left Join  (cost=1699.75..685141.85 rows=1685070 width=28) (actual time=0.000..0.114 rows=0 loops=1)
         Hash Cond: (a.c1 = b.c1)
         ->  Seq Scan on r1 a  (cost=0.00..811.00 rows=23700 width=16) (actual time=0.000..0.114 rows=0 loops=1)
         ->  Hash  (cost=811.00..811.00 rows=23700 width=16) (never executed)
               ->  Seq Scan on t1 b  (cost=0.00..811.00 rows=23700 width=16) (never executed)
   (slice0)    Executor memory: 386K bytes.
   (slice1)    Executor memory: 66K bytes avg x 3 workers, 66K bytes max (seg0).
   (slice2)    Executor memory: 4182K bytes avg x 3 workers, 4182K bytes max (seg0).
 Memory used:  128000kB
 Optimizer: Postgres query optimizer
 Total runtime: 3.601 ms
(13 rows)

:explain select * from r1 a left join t1 b using (c1, c2);
                                                             QUERY PLAN                                                             
------------------------------------------------------------------------------------------------------------------------------------
 Gather Motion 1:1  (slice1; segments: 1)  (cost=1877.50..1267557.50 rows=71100 width=24) (actual time=0.282..0.282 rows=0 loops=2)
   ->  Hash Left Join  (cost=1877.50..1267557.50 rows=23700 width=24) (actual time=0.000..0.016 rows=0 loops=1)
         Hash Cond: ((a.c1 = b.c1) AND (a.c2 = b.c2))
         ->  Seq Scan on r1 a  (cost=0.00..811.00 rows=23700 width=16) (actual time=0.000..0.016 rows=0 loops=1)
         ->  Hash  (cost=811.00..811.00 rows=23700 width=16) (never executed)
               ->  Seq Scan on t1 b  (cost=0.00..811.00 rows=23700 width=16) (never executed)
   (slice0)    Executor memory: 386K bytes.
   (slice1)    Executor memory: 66K bytes avg x 3 workers, 66K bytes max (seg0).
   (slice2)    Executor memory: 4182K bytes avg x 3 workers, 4182K bytes max (seg0).
 Memory used:  128000kB
 Optimizer: Postgres query optimizer
 Total runtime: 4.023 ms
(14 rows)

:explain select * from r1 a left join d1 b using (c1);
                                                             QUERY PLAN                                                              
-------------------------------------------------------------------------------------------------------------------------------------
 Gather Motion 1:1  (slice1; segments: 1)  (cost=1699.75..685141.85 rows=5055210 width=28) (actual time=0.230..0.230 rows=0 loops=2)
   ->  Hash Left Join  (cost=1699.75..685141.85 rows=1685070 width=28) (actual time=0.000..0.017 rows=0 loops=1)
         Hash Cond: a.c1 = b.c1
         ->  Seq Scan on r1 a  (cost=0.00..811.00 rows=23700 width=16) (actual time=0.000..0.017 rows=0 loops=1)
         ->  Hash  (cost=811.00..811.00 rows=23700 width=16) (never executed)
               ->  Seq Scan on d1 b  (cost=0.00..811.00 rows=23700 width=16) (never executed)
   (slice0)    Executor memory: 386K bytes.
   (slice1)    Executor memory: 98K bytes avg x 3 workers, 98K bytes max (seg0).
 Memory used:  128000kB
 Optimizer: Postgres query optimizer
 Total runtime: 1.015 ms
(11 rows)

:explain select * from r1 a left join d1 b using (c1, c2);
                                                             QUERY PLAN                                                             
------------------------------------------------------------------------------------------------------------------------------------
 Gather Motion 1:1  (slice1; segments: 1)  (cost=1877.50..1267557.50 rows=71100 width=24) (actual time=0.194..0.194 rows=0 loops=2)
   ->  Hash Left Join  (cost=1877.50..1267557.50 rows=23700 width=24) (actual time=0.000..0.101 rows=0 loops=1)
         Hash Cond: a.c1 = b.c1 AND a.c2 = b.c2
         ->  Seq Scan on r1 a  (cost=0.00..811.00 rows=23700 width=16) (actual time=0.000..0.101 rows=0 loops=1)
         ->  Hash  (cost=811.00..811.00 rows=23700 width=16) (never executed)
               ->  Seq Scan on d1 b  (cost=0.00..811.00 rows=23700 width=16) (never executed)
   (slice0)    Executor memory: 386K bytes.
   (slice1)    Executor memory: 98K bytes avg x 3 workers, 98K bytes max (seg0).
 Memory used:  128000kB
 Optimizer: Postgres query optimizer
 Total runtime: 0.979 ms
(11 rows)

:explain select * from r1 a left join r1 b using (c1);
                                                             QUERY PLAN                                                              
-------------------------------------------------------------------------------------------------------------------------------------
 Gather Motion 1:1  (slice1; segments: 1)  (cost=1699.75..685141.85 rows=5055210 width=28) (actual time=0.245..0.245 rows=0 loops=2)
   ->  Hash Left Join  (cost=1699.75..685141.85 rows=1685070 width=28) (actual time=0.000..0.016 rows=0 loops=1)
         Hash Cond: (a.c1 = b.c1)
         ->  Seq Scan on r1 a  (cost=0.00..811.00 rows=23700 width=16) (actual time=0.000..0.016 rows=0 loops=1)
         ->  Hash  (cost=811.00..811.00 rows=23700 width=16) (never executed)
               ->  Seq Scan on r1 b  (cost=0.00..811.00 rows=23700 width=16) (never executed)
   (slice0)    Executor memory: 386K bytes.
   (slice1)    Executor memory: 66K bytes avg x 3 workers, 66K bytes max (seg0).
   (slice2)    Executor memory: 4182K bytes avg x 3 workers, 4182K bytes max (seg0).
 Memory used:  128000kB
 Optimizer: Postgres query optimizer
 Total runtime: 3.549 ms
(13 rows)

:explain select * from r1 a left join r1 b using (c1, c2);
                                                             QUERY PLAN                                                             
------------------------------------------------------------------------------------------------------------------------------------
 Gather Motion 1:1  (slice1; segments: 1)  (cost=1877.50..1267557.50 rows=71100 width=24) (actual time=0.230..0.230 rows=0 loops=2)
   ->  Hash Left Join  (cost=1877.50..1267557.50 rows=23700 width=24) (actual time=0.000..0.015 rows=0 loops=1)
         Hash Cond: ((a.c1 = b.c1) AND (a.c2 = b.c2))
         ->  Seq Scan on r1 a  (cost=0.00..811.00 rows=23700 width=16) (actual time=0.000..0.014 rows=0 loops=1)
         ->  Hash  (cost=811.00..811.00 rows=23700 width=16) (never executed)
               ->  Seq Scan on r1 b  (cost=0.00..811.00 rows=23700 width=16) (never executed)
   (slice0)    Executor memory: 386K bytes.
   (slice1)    Executor memory: 66K bytes avg x 3 workers, 66K bytes max (seg0).
   (slice2)    Executor memory: 4182K bytes avg x 3 workers, 4182K bytes max (seg0).
 Memory used:  128000kB
 Optimizer: Postgres query optimizer
 Total runtime: 3.448 ms
(13 rows)

-- x1 left join y2
:explain select * from t1 a left join t2 b using (c1);
                                                              QUERY PLAN                                                              
--------------------------------------------------------------------------------------------------------------------------------------
 Gather Motion 1:1  (slice2; segments: 1)  (cost=1699.75..1952143.85 rows=5055210 width=28) (actual time=1.409..1.409 rows=0 loops=2)
   ->  Hash Right Join  (cost=1699.75..1952143.85 rows=1685070 width=28) (actual time=0.000..2.453 rows=0 loops=1)
         Hash Cond: b.c1 = a.c1
         ->  Broadcast Motion 2:1  (slice1; segments: 2)  (cost=0.00..3655.00 rows=71100 width=16) (never executed)
               ->  Seq Scan on t2 b  (cost=0.00..811.00 rows=23700 width=16) (actual time=0.000..0.010 rows=0 loops=1)
         ->  Hash  (cost=811.00..811.00 rows=23700 width=16) (actual time=0.000..0.022 rows=0 loops=1)
               ->  Seq Scan on t1 a  (cost=0.00..811.00 rows=23700 width=16) (actual time=0.000..0.020 rows=0 loops=1)
   (slice0)    Executor memory: 386K bytes.
   (slice1)    Executor memory: 66K bytes avg x 3 workers, 66K bytes max (seg0).
   (slice2)    Executor memory: 4182K bytes avg x 3 workers, 4182K bytes max (seg0).
 Memory used:  128000kB
 Optimizer: Postgres query optimizer
 Total runtime: 3.737 ms
(13 rows)

:explain select * from t1 a left join t2 b using (c1, c2);
                                                                      QUERY PLAN                                                                      
------------------------------------------------------------------------------------------------------------------------------------------------------
 Gather Motion 1:1  (slice2; segments: 1)  (cost=3299.50..1268979.50 rows=71100 width=24) (actual time=1.793..1.793 rows=0 loops=2)
   ->  Hash Left Join  (cost=3299.50..1268979.50 rows=23700 width=24) (actual time=0.000..3.120 rows=0 loops=1)
         Hash Cond: a.c1 = b.c1 AND a.c2 = b.c2
         ->  Seq Scan on t1 a  (cost=0.00..811.00 rows=23700 width=16) (actual time=0.000..0.017 rows=0 loops=1)
         ->  Hash  (cost=2233.00..2233.00 rows=23700 width=16) (actual time=0.000..1.196 rows=0 loops=1)
               ->  Redistribute Motion 2:1  (slice1; segments: 2)  (cost=0.00..2233.00 rows=23700 width=16) (actual time=0.000..1.195 rows=0 loops=1)
                     Hash Key: b.c1, b.c2
                     ->  Seq Scan on t2 b  (cost=0.00..811.00 rows=23700 width=16) (actual time=0.000..0.011 rows=0 loops=1)
   (slice0)    Executor memory: 386K bytes.
   (slice1)    Executor memory: 66K bytes avg x 3 workers, 66K bytes max (seg0).
   (slice2)    Executor memory: 4182K bytes avg x 3 workers, 4182K bytes max (seg0).
 Memory used:  128000kB
 Optimizer: Postgres query optimizer
 Total runtime: 4.268 ms
(14 rows)

:explain select * from t1 a left join d2 b using (c1);
                                                             QUERY PLAN                                                              
-------------------------------------------------------------------------------------------------------------------------------------
 Gather Motion 1:1  (slice1; segments: 1)  (cost=1699.75..685141.85 rows=5055210 width=28) (actual time=0.201..0.201 rows=0 loops=2)
   ->  Hash Left Join  (cost=1699.75..685141.85 rows=1685070 width=28) (actual time=0.000..0.105 rows=0 loops=1)
         Hash Cond: a.c1 = b.c1
         ->  Seq Scan on t1 a  (cost=0.00..811.00 rows=23700 width=16) (actual time=0.000..0.104 rows=0 loops=1)
         ->  Hash  (cost=811.00..811.00 rows=23700 width=16) (never executed)
               ->  Seq Scan on d2 b  (cost=0.00..811.00 rows=23700 width=16) (never executed)
   (slice0)    Executor memory: 386K bytes.
   (slice1)    Executor memory: 98K bytes avg x 3 workers, 98K bytes max (seg0).
 Memory used:  128000kB
 Optimizer: Postgres query optimizer
 Total runtime: 0.996 ms
(11 rows)

:explain select * from t1 a left join d2 b using (c1, c2);
                                                             QUERY PLAN                                                             
------------------------------------------------------------------------------------------------------------------------------------
 Gather Motion 1:1  (slice1; segments: 1)  (cost=1877.50..1267557.50 rows=71100 width=24) (actual time=0.192..0.192 rows=0 loops=2)
   ->  Hash Left Join  (cost=1877.50..1267557.50 rows=23700 width=24) (actual time=0.000..0.024 rows=0 loops=1)
         Hash Cond: a.c1 = b.c1 AND a.c2 = b.c2
         ->  Seq Scan on t1 a  (cost=0.00..811.00 rows=23700 width=16) (actual time=0.000..0.024 rows=0 loops=1)
         ->  Hash  (cost=811.00..811.00 rows=23700 width=16) (never executed)
               ->  Seq Scan on d2 b  (cost=0.00..811.00 rows=23700 width=16) (never executed)
   (slice0)    Executor memory: 386K bytes.
   (slice1)    Executor memory: 98K bytes avg x 3 workers, 98K bytes max (seg0).
 Memory used:  128000kB
 Optimizer: Postgres query optimizer
 Total runtime: 1.024 ms
(11 rows)

:explain select * from t1 a left join r2 b using (c1);
                                                              QUERY PLAN                                                              
--------------------------------------------------------------------------------------------------------------------------------------
 Gather Motion 1:1  (slice2; segments: 1)  (cost=1699.75..1952143.85 rows=5055210 width=28) (actual time=1.427..1.427 rows=0 loops=2)
   ->  Hash Right Join  (cost=1699.75..1952143.85 rows=1685070 width=28) (actual time=0.000..2.190 rows=0 loops=1)
         Hash Cond: b.c1 = a.c1
         ->  Broadcast Motion 2:1  (slice1; segments: 2)  (cost=0.00..3655.00 rows=71100 width=16) (never executed)
               ->  Seq Scan on r2 b  (cost=0.00..811.00 rows=23700 width=16) (actual time=0.000..0.010 rows=0 loops=1)
         ->  Hash  (cost=811.00..811.00 rows=23700 width=16) (actual time=0.000..0.057 rows=0 loops=1)
               ->  Seq Scan on t1 a  (cost=0.00..811.00 rows=23700 width=16) (actual time=0.000..0.056 rows=0 loops=1)
   (slice0)    Executor memory: 386K bytes.
   (slice1)    Executor memory: 66K bytes avg x 3 workers, 66K bytes max (seg0).
   (slice2)    Executor memory: 4182K bytes avg x 3 workers, 4182K bytes max (seg0).
 Memory used:  128000kB
 Optimizer: Postgres query optimizer
 Total runtime: 3.685 ms
(13 rows)

:explain select * from t1 a left join r2 b using (c1, c2);
                                                             QUERY PLAN                                                             
------------------------------------------------------------------------------------------------------------------------------------
 Gather Motion 1:1  (slice2; segments: 1)  (cost=1877.50..1268979.50 rows=71100 width=24) (actual time=1.449..1.449 rows=0 loops=2)
   ->  Hash Right Join  (cost=1877.50..1268979.50 rows=23700 width=24) (actual time=0.000..2.436 rows=0 loops=1)
         Hash Cond: b.c1 = a.c1 AND b.c2 = a.c2
         ->  Redistribute Motion 2:1  (slice1; segments: 2)  (cost=0.00..2233.00 rows=23700 width=16) (never executed)
               Hash Key: b.c1, b.c2
               ->  Seq Scan on r2 b  (cost=0.00..811.00 rows=23700 width=16) (actual time=0.000..0.010 rows=0 loops=1)
         ->  Hash  (cost=811.00..811.00 rows=23700 width=16) (actual time=0.000..0.024 rows=0 loops=1)
               ->  Seq Scan on t1 a  (cost=0.00..811.00 rows=23700 width=16) (actual time=0.000..0.022 rows=0 loops=1)
   (slice0)    Executor memory: 386K bytes.
   (slice1)    Executor memory: 66K bytes avg x 3 workers, 66K bytes max (seg0).
   (slice2)    Executor memory: 4182K bytes avg x 3 workers, 4182K bytes max (seg0).
 Memory used:  128000kB
 Optimizer: Postgres query optimizer
 Total runtime: 3.813 ms
(14 rows)

:explain select * from d1 a left join t2 b using (c1);
                                                                QUERY PLAN                                                                 
-------------------------------------------------------------------------------------------------------------------------------------------
 Hash Right Join  (cost=1699.75..686563.85 rows=5055210 width=28) (actual time=1.573..1.573 rows=0 loops=2)
   Hash Cond: b.c1 = a.c1
   Extra Text: Hash chain length 0.0 avg, 0 max, using 0 of 524288 buckets.
   ->  Gather Motion 2:1  (slice1; segments: 2)  (cost=0.00..2233.00 rows=71100 width=16) (never executed)
         ->  Seq Scan on t2 b  (cost=0.00..811.00 rows=23700 width=16) (actual time=0.000..0.033 rows=0 loops=1)
   ->  Hash  (cost=811.00..811.00 rows=23700 width=16) (actual time=0.674..0.674 rows=0 loops=2)
         Buckets: 524288  Batches: 1  Memory Usage: 0kB
         ->  Gather Motion 1:1  (slice2; segments: 1)  (cost=811.00..811.00 rows=71100 width=16) (actual time=0.674..0.674 rows=0 loops=2)
               ->  Seq Scan on d1 a  (cost=0.00..811.00 rows=23700 width=16) (actual time=0.000..0.010 rows=0 loops=1)
   (slice0)    Executor memory: 4234K bytes.
   (slice1)    Executor memory: 50K bytes avg x 3 workers, 50K bytes max (seg0).
   (slice2)    Executor memory: 66K bytes (seg0).
 Memory used:  128000kB
 Optimizer: Postgres query optimizer
 Total runtime: 3.531 ms
(16 rows)

:explain select * from d1 a left join t2 b using (c1, c2);
                                                                QUERY PLAN                                                                 
-------------------------------------------------------------------------------------------------------------------------------------------
 Hash Right Join  (cost=1877.50..1268979.50 rows=71100 width=24) (actual time=1.542..1.542 rows=0 loops=2)
   Hash Cond: b.c1 = a.c1 AND b.c2 = a.c2
   Extra Text: Hash chain length 0.0 avg, 0 max, using 0 of 524288 buckets.
   ->  Gather Motion 2:1  (slice1; segments: 2)  (cost=0.00..2233.00 rows=71100 width=16) (never executed)
         ->  Seq Scan on t2 b  (cost=0.00..811.00 rows=23700 width=16) (actual time=0.000..0.021 rows=0 loops=1)
   ->  Hash  (cost=811.00..811.00 rows=23700 width=16) (actual time=0.700..0.700 rows=0 loops=2)
         Buckets: 524288  Batches: 1  Memory Usage: 0kB
         ->  Gather Motion 1:1  (slice2; segments: 1)  (cost=811.00..811.00 rows=71100 width=16) (actual time=0.699..0.699 rows=0 loops=2)
               ->  Seq Scan on d1 a  (cost=0.00..811.00 rows=23700 width=16) (actual time=0.000..0.011 rows=0 loops=1)
   (slice0)    Executor memory: 4234K bytes.
   (slice1)    Executor memory: 50K bytes avg x 3 workers, 50K bytes max (seg0).
   (slice2)    Executor memory: 66K bytes (seg0).
 Memory used:  128000kB
 Optimizer: Postgres query optimizer
 Total runtime: 3.583 ms
(16 rows)

:explain select * from d1 a left join d2 b using (c1);
                                                             QUERY PLAN                                                              
-------------------------------------------------------------------------------------------------------------------------------------
 Gather Motion 1:1  (slice1; segments: 1)  (cost=1699.75..685141.85 rows=5055210 width=28) (actual time=0.230..0.230 rows=0 loops=2)
   ->  Hash Left Join  (cost=1699.75..685141.85 rows=1685070 width=28) (actual time=0.000..0.017 rows=0 loops=1)
         Hash Cond: a.c1 = b.c1
         ->  Seq Scan on d1 a  (cost=0.00..811.00 rows=23700 width=16) (actual time=0.000..0.017 rows=0 loops=1)
         ->  Hash  (cost=811.00..811.00 rows=23700 width=16) (never executed)
               ->  Seq Scan on d2 b  (cost=0.00..811.00 rows=23700 width=16) (never executed)
   (slice0)    Executor memory: 386K bytes.
   (slice1)    Executor memory: 98K bytes (seg0).
 Memory used:  128000kB
 Optimizer: Postgres query optimizer
 Total runtime: 1.013 ms
(11 rows)

:explain select * from d1 a left join d2 b using (c1, c2);
                                                             QUERY PLAN                                                             
------------------------------------------------------------------------------------------------------------------------------------
 Gather Motion 1:1  (slice1; segments: 1)  (cost=1877.50..1267557.50 rows=71100 width=24) (actual time=0.226..0.226 rows=0 loops=2)
   ->  Hash Left Join  (cost=1877.50..1267557.50 rows=23700 width=24) (actual time=0.000..0.015 rows=0 loops=1)
         Hash Cond: a.c1 = b.c1 AND a.c2 = b.c2
         ->  Seq Scan on d1 a  (cost=0.00..811.00 rows=23700 width=16) (actual time=0.000..0.015 rows=0 loops=1)
         ->  Hash  (cost=811.00..811.00 rows=23700 width=16) (never executed)
               ->  Seq Scan on d2 b  (cost=0.00..811.00 rows=23700 width=16) (never executed)
   (slice0)    Executor memory: 386K bytes.
   (slice1)    Executor memory: 98K bytes (seg0).
 Memory used:  128000kB
 Optimizer: Postgres query optimizer
 Total runtime: 0.973 ms
(11 rows)

:explain select * from d1 a left join r2 b using (c1);
                                                                QUERY PLAN                                                                 
-------------------------------------------------------------------------------------------------------------------------------------------
 Hash Right Join  (cost=1699.75..686563.85 rows=5055210 width=28) (actual time=1.550..1.550 rows=0 loops=2)
   Hash Cond: b.c1 = a.c1
   Extra Text: Hash chain length 0.0 avg, 0 max, using 0 of 524288 buckets.
   ->  Gather Motion 2:1  (slice1; segments: 2)  (cost=0.00..2233.00 rows=71100 width=16) (never executed)
         ->  Seq Scan on r2 b  (cost=0.00..811.00 rows=23700 width=16) (actual time=0.000..0.018 rows=0 loops=1)
   ->  Hash  (cost=811.00..811.00 rows=23700 width=16) (actual time=0.690..0.690 rows=0 loops=2)
         Buckets: 524288  Batches: 1  Memory Usage: 0kB
         ->  Gather Motion 1:1  (slice2; segments: 1)  (cost=811.00..811.00 rows=71100 width=16) (actual time=0.689..0.689 rows=0 loops=2)
               ->  Seq Scan on d1 a  (cost=0.00..811.00 rows=23700 width=16) (actual time=0.000..0.009 rows=0 loops=1)
   (slice0)    Executor memory: 4234K bytes.
   (slice1)    Executor memory: 50K bytes avg x 3 workers, 50K bytes max (seg0).
   (slice2)    Executor memory: 66K bytes (seg0).
 Memory used:  128000kB
 Optimizer: Postgres query optimizer
 Total runtime: 3.479 ms
(16 rows)

:explain select * from d1 a left join r2 b using (c1, c2);
                                                                QUERY PLAN                                                                 
-------------------------------------------------------------------------------------------------------------------------------------------
 Hash Right Join  (cost=1877.50..1268979.50 rows=71100 width=24) (actual time=1.553..1.553 rows=0 loops=2)
   Hash Cond: b.c1 = a.c1 AND b.c2 = a.c2
   Extra Text: Hash chain length 0.0 avg, 0 max, using 0 of 524288 buckets.
   ->  Gather Motion 2:1  (slice1; segments: 2)  (cost=0.00..2233.00 rows=71100 width=16) (never executed)
         ->  Seq Scan on r2 b  (cost=0.00..811.00 rows=23700 width=16) (actual time=0.000..0.018 rows=0 loops=1)
   ->  Hash  (cost=811.00..811.00 rows=23700 width=16) (actual time=0.710..0.710 rows=0 loops=2)
         Buckets: 524288  Batches: 1  Memory Usage: 0kB
         ->  Gather Motion 1:1  (slice2; segments: 1)  (cost=811.00..811.00 rows=71100 width=16) (actual time=0.709..0.709 rows=0 loops=2)
               ->  Seq Scan on d1 a  (cost=0.00..811.00 rows=23700 width=16) (actual time=0.000..0.009 rows=0 loops=1)
   (slice0)    Executor memory: 4234K bytes.
   (slice1)    Executor memory: 50K bytes avg x 3 workers, 50K bytes max (seg0).
   (slice2)    Executor memory: 66K bytes (seg0).
 Memory used:  128000kB
 Optimizer: Postgres query optimizer
 Total runtime: 3.539 ms
(16 rows)

:explain select * from r1 a left join t2 b using (c1);
                                                              QUERY PLAN                                                              
--------------------------------------------------------------------------------------------------------------------------------------
 Gather Motion 1:1  (slice2; segments: 1)  (cost=1699.75..1952143.85 rows=5055210 width=28) (actual time=1.381..1.381 rows=0 loops=2)
   ->  Hash Right Join  (cost=1699.75..1952143.85 rows=1685070 width=28) (actual time=0.000..2.357 rows=0 loops=1)
         Hash Cond: b.c1 = a.c1
         ->  Broadcast Motion 2:1  (slice1; segments: 2)  (cost=0.00..3655.00 rows=71100 width=16) (never executed)
               ->  Seq Scan on t2 b  (cost=0.00..811.00 rows=23700 width=16) (actual time=0.000..0.050 rows=0 loops=1)
         ->  Hash  (cost=811.00..811.00 rows=23700 width=16) (actual time=0.000..0.022 rows=0 loops=1)
               ->  Seq Scan on r1 a  (cost=0.00..811.00 rows=23700 width=16) (actual time=0.000..0.020 rows=0 loops=1)
   (slice0)    Executor memory: 386K bytes.
   (slice1)    Executor memory: 66K bytes avg x 3 workers, 66K bytes max (seg0).
   (slice2)    Executor memory: 4182K bytes avg x 3 workers, 4182K bytes max (seg0).
 Memory used:  128000kB
 Optimizer: Postgres query optimizer
 Total runtime: 3.531 ms
(13 rows)

:explain select * from r1 a left join t2 b using (c1, c2);
                                                                   QUERY PLAN                                                                   
------------------------------------------------------------------------------------------------------------------------------------------------
 Gather Motion 2:1  (slice2; segments: 2)  (cost=1877.50..1268979.50 rows=71100 width=24) (actual time=1.752..1.752 rows=0 loops=2)
   ->  Hash Left Join  (cost=1877.50..1268979.50 rows=23700 width=24) (actual time=0.000..2.998 rows=0 loops=1)
         Hash Cond: a.c1 = b.c1 AND a.c2 = b.c2
         ->  Redistribute Motion 1:2  (slice1; segments: 1)  (cost=0.00..2233.00 rows=23700 width=16) (actual time=0.000..1.113 rows=0 loops=1)
               Hash Key: a.c1, a.c2
               ->  Seq Scan on r1 a  (cost=0.00..811.00 rows=23700 width=16) (actual time=0.000..0.009 rows=0 loops=1)
         ->  Hash  (cost=811.00..811.00 rows=23700 width=16) (actual time=0.000..0.034 rows=0 loops=1)
               ->  Seq Scan on t2 b  (cost=0.00..811.00 rows=23700 width=16) (actual time=0.000..0.032 rows=0 loops=1)
   (slice0)    Executor memory: 386K bytes.
   (slice1)    Executor memory: 66K bytes avg x 3 workers, 66K bytes max (seg0).
   (slice2)    Executor memory: 4182K bytes avg x 3 workers, 4182K bytes max (seg0).
 Memory used:  128000kB
 Optimizer: Postgres query optimizer
 Total runtime: 4.228 ms
(14 rows)

:explain select * from r1 a left join d2 b using (c1);
                                                             QUERY PLAN                                                              
-------------------------------------------------------------------------------------------------------------------------------------
 Gather Motion 1:1  (slice1; segments: 1)  (cost=1699.75..685141.85 rows=5055210 width=28) (actual time=0.175..0.175 rows=0 loops=2)
   ->  Hash Left Join  (cost=1699.75..685141.85 rows=1685070 width=28) (actual time=0.000..0.018 rows=0 loops=1)
         Hash Cond: a.c1 = b.c1
         ->  Seq Scan on r1 a  (cost=0.00..811.00 rows=23700 width=16) (actual time=0.000..0.017 rows=0 loops=1)
         ->  Hash  (cost=811.00..811.00 rows=23700 width=16) (never executed)
               ->  Seq Scan on d2 b  (cost=0.00..811.00 rows=23700 width=16) (never executed)
   (slice0)    Executor memory: 386K bytes.
   (slice1)    Executor memory: 98K bytes avg x 3 workers, 98K bytes max (seg0).
 Memory used:  128000kB
 Optimizer: Postgres query optimizer
 Total runtime: 0.921 ms
(11 rows)

:explain select * from r1 a left join d2 b using (c1, c2);
                                                             QUERY PLAN                                                             
------------------------------------------------------------------------------------------------------------------------------------
 Gather Motion 1:1  (slice1; segments: 1)  (cost=1877.50..1267557.50 rows=71100 width=24) (actual time=0.202..0.202 rows=0 loops=2)
   ->  Hash Left Join  (cost=1877.50..1267557.50 rows=23700 width=24) (actual time=0.000..0.018 rows=0 loops=1)
         Hash Cond: a.c1 = b.c1 AND a.c2 = b.c2
         ->  Seq Scan on r1 a  (cost=0.00..811.00 rows=23700 width=16) (actual time=0.000..0.018 rows=0 loops=1)
         ->  Hash  (cost=811.00..811.00 rows=23700 width=16) (never executed)
               ->  Seq Scan on d2 b  (cost=0.00..811.00 rows=23700 width=16) (never executed)
   (slice0)    Executor memory: 386K bytes.
   (slice1)    Executor memory: 98K bytes avg x 3 workers, 98K bytes max (seg0).
 Memory used:  128000kB
 Optimizer: Postgres query optimizer
 Total runtime: 1.033 ms
(11 rows)

:explain select * from r1 a left join r2 b using (c1);
                                                              QUERY PLAN                                                              
--------------------------------------------------------------------------------------------------------------------------------------
 Gather Motion 1:1  (slice2; segments: 1)  (cost=1699.75..1952143.85 rows=5055210 width=28) (actual time=1.422..1.422 rows=0 loops=2)
   ->  Hash Right Join  (cost=1699.75..1952143.85 rows=1685070 width=28) (actual time=0.000..2.366 rows=0 loops=1)
         Hash Cond: b.c1 = a.c1
         ->  Broadcast Motion 2:1  (slice1; segments: 2)  (cost=0.00..3655.00 rows=71100 width=16) (never executed)
               ->  Seq Scan on r2 b  (cost=0.00..811.00 rows=23700 width=16) (actual time=0.000..0.037 rows=0 loops=1)
         ->  Hash  (cost=811.00..811.00 rows=23700 width=16) (actual time=0.000..0.028 rows=0 loops=1)
               ->  Seq Scan on r1 a  (cost=0.00..811.00 rows=23700 width=16) (actual time=0.000..0.026 rows=0 loops=1)
   (slice0)    Executor memory: 386K bytes.
   (slice1)    Executor memory: 66K bytes avg x 3 workers, 66K bytes max (seg0).
   (slice2)    Executor memory: 4182K bytes avg x 3 workers, 4182K bytes max (seg0).
 Memory used:  128000kB
 Optimizer: Postgres query optimizer
 Total runtime: 3.668 ms
(13 rows)

:explain select * from r1 a left join r2 b using (c1, c2);
                                                             QUERY PLAN                                                             
------------------------------------------------------------------------------------------------------------------------------------
 Gather Motion 1:1  (slice2; segments: 1)  (cost=1877.50..3798717.50 rows=71100 width=24) (actual time=1.442..1.442 rows=0 loops=2)
   ->  Hash Right Join  (cost=1877.50..3798717.50 rows=23700 width=24) (actual time=0.000..2.549 rows=0 loops=1)
         Hash Cond: b.c1 = a.c1 AND b.c2 = a.c2
         ->  Broadcast Motion 2:1  (slice1; segments: 2)  (cost=0.00..3655.00 rows=71100 width=16) (never executed)
               ->  Seq Scan on r2 b  (cost=0.00..811.00 rows=23700 width=16) (actual time=0.000..0.009 rows=0 loops=1)
         ->  Hash  (cost=811.00..811.00 rows=23700 width=16) (actual time=0.000..0.033 rows=0 loops=1)
               ->  Seq Scan on r1 a  (cost=0.00..811.00 rows=23700 width=16) (actual time=0.000..0.031 rows=0 loops=1)
   (slice0)    Executor memory: 386K bytes.
   (slice1)    Executor memory: 66K bytes avg x 3 workers, 66K bytes max (seg0).
   (slice2)    Executor memory: 4182K bytes avg x 3 workers, 4182K bytes max (seg0).
 Memory used:  128000kB
 Optimizer: Postgres query optimizer
 Total runtime: 3.610 ms
(13 rows)

-- x2 left join y1
:explain select * from t2 a left join t1 b using (c1);
                                                                      QUERY PLAN                                                                      
------------------------------------------------------------------------------------------------------------------------------------------------------
 Gather Motion 1:1  (slice3; segments: 1)  (cost=3121.75..687985.85 rows=5055210 width=28) (actual time=2.356..2.356 rows=0 loops=2)
   ->  Hash Left Join  (cost=3121.75..687985.85 rows=1685070 width=28) (actual time=0.000..3.760 rows=0 loops=1)
         Hash Cond: a.c1 = b.c1
         ->  Redistribute Motion 2:1  (slice1; segments: 2)  (cost=0.00..2233.00 rows=23700 width=16) (actual time=0.000..0.003 rows=0 loops=1)
               Hash Key: a.c1
               ->  Seq Scan on t2 a  (cost=0.00..811.00 rows=23700 width=16) (actual time=0.000..0.009 rows=0 loops=1)
         ->  Hash  (cost=2233.00..2233.00 rows=23700 width=16) (actual time=0.000..2.152 rows=0 loops=1)
               ->  Redistribute Motion 1:1  (slice2; segments: 1)  (cost=0.00..2233.00 rows=23700 width=16) (actual time=0.000..2.151 rows=0 loops=1)
                     Hash Key: b.c1
                     ->  Seq Scan on t1 b  (cost=0.00..811.00 rows=23700 width=16) (actual time=0.000..0.010 rows=0 loops=1)
   (slice0)    Executor memory: 390K bytes.
   (slice1)    Executor memory: 66K bytes avg x 3 workers, 66K bytes max (seg0).
   (slice2)    Executor memory: 66K bytes avg x 3 workers, 66K bytes max (seg0).
   (slice3)    Executor memory: 4174K bytes avg x 3 workers, 4174K bytes max (seg0).
 Memory used:  128000kB
 Optimizer: Postgres query optimizer
 Total runtime: 5.593 ms
(17 rows)

:explain select * from t2 a left join t1 b using (c1, c2);
                                                                      QUERY PLAN                                                                      
------------------------------------------------------------------------------------------------------------------------------------------------------
 Gather Motion 2:1  (slice2; segments: 2)  (cost=3299.50..1268979.50 rows=71100 width=24) (actual time=1.287..1.287 rows=0 loops=2)
   ->  Hash Left Join  (cost=3299.50..1268979.50 rows=23700 width=24) (actual time=0.000..2.759 rows=0 loops=1)
         Hash Cond: a.c1 = b.c1 AND a.c2 = b.c2
         ->  Seq Scan on t2 a  (cost=0.00..811.00 rows=23700 width=16) (actual time=0.000..0.018 rows=0 loops=1)
         ->  Hash  (cost=2233.00..2233.00 rows=23700 width=16) (actual time=0.000..0.943 rows=0 loops=1)
               ->  Redistribute Motion 1:2  (slice1; segments: 1)  (cost=0.00..2233.00 rows=23700 width=16) (actual time=0.000..0.942 rows=0 loops=1)
                     Hash Key: b.c1, b.c2
                     ->  Seq Scan on t1 b  (cost=0.00..811.00 rows=23700 width=16) (actual time=0.000..0.009 rows=0 loops=1)
   (slice0)    Executor memory: 386K bytes.
   (slice1)    Executor memory: 66K bytes avg x 3 workers, 66K bytes max (seg0).
   (slice2)    Executor memory: 4182K bytes avg x 3 workers, 4182K bytes max (seg0).
 Memory used:  128000kB
 Optimizer: Postgres query optimizer
 Total runtime: 3.922 ms
(14 rows)

:explain select * from t2 a left join d1 b using (c1);
                                                                QUERY PLAN                                                                 
-------------------------------------------------------------------------------------------------------------------------------------------
 Hash Left Join  (cost=1699.75..686563.85 rows=5055210 width=28) (actual time=0.920..0.920 rows=0 loops=2)
   Hash Cond: a.c1 = b.c1
   Extra Text: Hash chain length 0.0 avg, 0 max, using 0 of 524288 buckets.
   ->  Gather Motion 2:1  (slice1; segments: 2)  (cost=0.00..2233.00 rows=71100 width=16) (actual time=0.002..0.002 rows=0 loops=2)
         ->  Seq Scan on t2 a  (cost=0.00..811.00 rows=23700 width=16) (actual time=0.000..0.577 rows=0 loops=1)
   ->  Hash  (cost=811.00..811.00 rows=23700 width=16) (actual time=0.003..0.003 rows=0 loops=2)
         Buckets: 524288  Batches: 1  Memory Usage: 0kB
         ->  Gather Motion 1:1  (slice2; segments: 1)  (cost=811.00..811.00 rows=71100 width=16) (actual time=0.002..0.002 rows=0 loops=2)
               ->  Seq Scan on d1 b  (cost=0.00..811.00 rows=23700 width=16) (actual time=0.000..0.009 rows=0 loops=1)
   (slice0)    Executor memory: 4238K bytes.
   (slice1)    Executor memory: 50K bytes avg x 3 workers, 50K bytes max (seg0).
   (slice2)    Executor memory: 66K bytes (seg0).
 Memory used:  128000kB
 Optimizer: Postgres query optimizer
 Total runtime: 2.487 ms
(16 rows)

:explain select * from t2 a left join d1 b using (c1, c2);
                                                             QUERY PLAN                                                             
------------------------------------------------------------------------------------------------------------------------------------
 Gather Motion 2:1  (slice2; segments: 2)  (cost=1877.50..1268979.50 rows=71100 width=24) (actual time=0.002..0.002 rows=0 loops=2)
   ->  Hash Right Join  (cost=1877.50..1268979.50 rows=23700 width=24) (actual time=0.000..1.866 rows=0 loops=1)
         Hash Cond: b.c1 = a.c1 AND b.c2 = a.c2
         ->  Redistribute Motion 1:2  (slice1; segments: 1)  (cost=0.00..2233.00 rows=71100 width=16) (never executed)
               Hash Key: b.c1, b.c2
               ->  Seq Scan on d1 b  (cost=0.00..811.00 rows=23700 width=16) (actual time=0.000..0.033 rows=0 loops=1)
         ->  Hash  (cost=811.00..811.00 rows=23700 width=16) (actual time=0.000..0.036 rows=0 loops=1)
               ->  Seq Scan on t2 a  (cost=0.00..811.00 rows=23700 width=16) (actual time=0.000..0.034 rows=0 loops=1)
   (slice0)    Executor memory: 386K bytes.
   (slice1)    Executor memory: 66K bytes (seg0).
   (slice2)    Executor memory: 4182K bytes avg x 3 workers, 4182K bytes max (seg0).
 Memory used:  128000kB
 Optimizer: Postgres query optimizer
 Total runtime: 3.554 ms
(14 rows)

:explain select * from t2 a left join r1 b using (c1);
                                                                      QUERY PLAN                                                                      
------------------------------------------------------------------------------------------------------------------------------------------------------
 Gather Motion 1:1  (slice3; segments: 1)  (cost=3121.75..687985.85 rows=5055210 width=28) (actual time=1.841..1.841 rows=0 loops=2)
   ->  Hash Left Join  (cost=3121.75..687985.85 rows=1685070 width=28) (actual time=0.000..4.616 rows=0 loops=1)
         Hash Cond: a.c1 = b.c1
         ->  Redistribute Motion 2:1  (slice1; segments: 2)  (cost=0.00..2233.00 rows=23700 width=16) (actual time=0.000..0.003 rows=0 loops=1)
               Hash Key: a.c1
               ->  Seq Scan on t2 a  (cost=0.00..811.00 rows=23700 width=16) (actual time=0.000..0.011 rows=0 loops=1)
         ->  Hash  (cost=2233.00..2233.00 rows=23700 width=16) (actual time=0.000..2.932 rows=0 loops=1)
               ->  Redistribute Motion 1:1  (slice2; segments: 1)  (cost=0.00..2233.00 rows=23700 width=16) (actual time=0.000..2.930 rows=0 loops=1)
                     Hash Key: b.c1
                     ->  Seq Scan on r1 b  (cost=0.00..811.00 rows=23700 width=16) (actual time=0.000..0.019 rows=0 loops=1)
   (slice0)    Executor memory: 390K bytes.
   (slice1)    Executor memory: 66K bytes avg x 3 workers, 66K bytes max (seg0).
   (slice2)    Executor memory: 66K bytes avg x 3 workers, 66K bytes max (seg0).
   (slice3)    Executor memory: 4174K bytes avg x 3 workers, 4174K bytes max (seg0).
 Memory used:  128000kB
 Optimizer: Postgres query optimizer
 Total runtime: 5.554 ms
(17 rows)

:explain select * from t2 a left join r1 b using (c1, c2);
                                                             QUERY PLAN                                                             
------------------------------------------------------------------------------------------------------------------------------------
 Gather Motion 2:1  (slice2; segments: 2)  (cost=1877.50..1268979.50 rows=71100 width=24) (actual time=1.105..1.105 rows=0 loops=2)
   ->  Hash Right Join  (cost=1877.50..1268979.50 rows=23700 width=24) (actual time=0.000..1.888 rows=0 loops=1)
         Hash Cond: b.c1 = a.c1 AND b.c2 = a.c2
         ->  Redistribute Motion 1:2  (slice1; segments: 1)  (cost=0.00..2233.00 rows=23700 width=16) (never executed)
               Hash Key: b.c1, b.c2
               ->  Seq Scan on r1 b  (cost=0.00..811.00 rows=23700 width=16) (actual time=0.000..0.010 rows=0 loops=1)
         ->  Hash  (cost=811.00..811.00 rows=23700 width=16) (actual time=0.000..0.027 rows=0 loops=1)
               ->  Seq Scan on t2 a  (cost=0.00..811.00 rows=23700 width=16) (actual time=0.000..0.026 rows=0 loops=1)
   (slice0)    Executor memory: 386K bytes.
   (slice1)    Executor memory: 66K bytes avg x 3 workers, 66K bytes max (seg0).
   (slice2)    Executor memory: 4182K bytes avg x 3 workers, 4182K bytes max (seg0).
 Memory used:  128000kB
 Optimizer: Postgres query optimizer
 Total runtime: 4.969 ms
(14 rows)

:explain select * from d2 a left join t1 b using (c1);
                                                                QUERY PLAN                                                                 
-------------------------------------------------------------------------------------------------------------------------------------------
 Hash Right Join  (cost=1699.75..686563.85 rows=5055210 width=28) (actual time=1.737..1.737 rows=0 loops=2)
   Hash Cond: b.c1 = a.c1
   Extra Text: Hash chain length 0.0 avg, 0 max, using 0 of 524288 buckets.
   ->  Gather Motion 1:1  (slice1; segments: 1)  (cost=0.00..2233.00 rows=71100 width=16) (never executed)
         ->  Seq Scan on t1 b  (cost=0.00..811.00 rows=23700 width=16) (actual time=0.000..0.017 rows=0 loops=1)
   ->  Hash  (cost=811.00..811.00 rows=23700 width=16) (actual time=0.887..0.887 rows=0 loops=2)
         Buckets: 524288  Batches: 1  Memory Usage: 0kB
         ->  Gather Motion 1:1  (slice2; segments: 1)  (cost=811.00..811.00 rows=71100 width=16) (actual time=0.886..0.886 rows=0 loops=2)
               ->  Seq Scan on d2 a  (cost=0.00..811.00 rows=23700 width=16) (actual time=0.000..0.011 rows=0 loops=1)
   (slice0)    Executor memory: 4234K bytes.
   (slice1)    Executor memory: 50K bytes avg x 3 workers, 50K bytes max (seg0).
   (slice2)    Executor memory: 66K bytes (seg0).
 Memory used:  128000kB
 Optimizer: Postgres query optimizer
 Total runtime: 3.870 ms
(16 rows)

:explain select * from d2 a left join t1 b using (c1, c2);
                                                                QUERY PLAN                                                                 
-------------------------------------------------------------------------------------------------------------------------------------------
 Hash Right Join  (cost=1877.50..1268979.50 rows=71100 width=24) (actual time=1.373..1.373 rows=0 loops=2)
   Hash Cond: b.c1 = a.c1 AND b.c2 = a.c2
   Extra Text: Hash chain length 0.0 avg, 0 max, using 0 of 524288 buckets.
   ->  Gather Motion 1:1  (slice1; segments: 1)  (cost=0.00..2233.00 rows=71100 width=16) (never executed)
         ->  Seq Scan on t1 b  (cost=0.00..811.00 rows=23700 width=16) (actual time=0.000..0.018 rows=0 loops=1)
   ->  Hash  (cost=811.00..811.00 rows=23700 width=16) (actual time=0.606..0.606 rows=0 loops=2)
         Buckets: 524288  Batches: 1  Memory Usage: 0kB
         ->  Gather Motion 1:1  (slice2; segments: 1)  (cost=811.00..811.00 rows=71100 width=16) (actual time=0.605..0.605 rows=0 loops=2)
               ->  Seq Scan on d2 a  (cost=0.00..811.00 rows=23700 width=16) (actual time=0.000..0.009 rows=0 loops=1)
   (slice0)    Executor memory: 4234K bytes.
   (slice1)    Executor memory: 50K bytes avg x 3 workers, 50K bytes max (seg0).
   (slice2)    Executor memory: 66K bytes (seg0).
 Memory used:  128000kB
 Optimizer: Postgres query optimizer
 Total runtime: 3.182 ms
(16 rows)

:explain select * from d2 a left join d1 b using (c1);
                                                             QUERY PLAN                                                              
-------------------------------------------------------------------------------------------------------------------------------------
 Gather Motion 1:1  (slice1; segments: 1)  (cost=1699.75..685141.85 rows=5055210 width=28) (actual time=0.214..0.214 rows=0 loops=2)
   ->  Hash Left Join  (cost=1699.75..685141.85 rows=1685070 width=28) (actual time=0.000..0.018 rows=0 loops=1)
         Hash Cond: a.c1 = b.c1
         ->  Seq Scan on d2 a  (cost=0.00..811.00 rows=23700 width=16) (actual time=0.000..0.018 rows=0 loops=1)
         ->  Hash  (cost=811.00..811.00 rows=23700 width=16) (never executed)
               ->  Seq Scan on d1 b  (cost=0.00..811.00 rows=23700 width=16) (never executed)
   (slice0)    Executor memory: 386K bytes.
   (slice1)    Executor memory: 98K bytes (seg0).
 Memory used:  128000kB
 Optimizer: Postgres query optimizer
 Total runtime: 1.074 ms
(11 rows)

:explain select * from d2 a left join d1 b using (c1, c2);
                                                             QUERY PLAN                                                             
------------------------------------------------------------------------------------------------------------------------------------
 Gather Motion 1:1  (slice1; segments: 1)  (cost=1877.50..1267557.50 rows=71100 width=24) (actual time=0.184..0.184 rows=0 loops=2)
   ->  Hash Left Join  (cost=1877.50..1267557.50 rows=23700 width=24) (actual time=0.000..0.015 rows=0 loops=1)
         Hash Cond: a.c1 = b.c1 AND a.c2 = b.c2
         ->  Seq Scan on d2 a  (cost=0.00..811.00 rows=23700 width=16) (actual time=0.000..0.015 rows=0 loops=1)
         ->  Hash  (cost=811.00..811.00 rows=23700 width=16) (never executed)
               ->  Seq Scan on d1 b  (cost=0.00..811.00 rows=23700 width=16) (never executed)
   (slice0)    Executor memory: 386K bytes.
   (slice1)    Executor memory: 98K bytes (seg0).
 Memory used:  128000kB
 Optimizer: Postgres query optimizer
 Total runtime: 0.981 ms
(11 rows)

:explain select * from d2 a left join r1 b using (c1);
                                                                QUERY PLAN                                                                 
-------------------------------------------------------------------------------------------------------------------------------------------
 Hash Right Join  (cost=1699.75..686563.85 rows=5055210 width=28) (actual time=0.832..0.832 rows=0 loops=2)
   Hash Cond: b.c1 = a.c1
   Extra Text: Hash chain length 0.0 avg, 0 max, using 0 of 524288 buckets.
   ->  Gather Motion 1:1  (slice1; segments: 1)  (cost=0.00..2233.00 rows=71100 width=16) (never executed)
         ->  Seq Scan on r1 b  (cost=0.00..811.00 rows=23700 width=16) (actual time=0.000..0.015 rows=0 loops=1)
   ->  Hash  (cost=811.00..811.00 rows=23700 width=16) (actual time=0.002..0.002 rows=0 loops=2)
         Buckets: 524288  Batches: 1  Memory Usage: 0kB
         ->  Gather Motion 1:1  (slice2; segments: 1)  (cost=811.00..811.00 rows=71100 width=16) (actual time=0.002..0.002 rows=0 loops=2)
               ->  Seq Scan on d2 a  (cost=0.00..811.00 rows=23700 width=16) (actual time=0.000..0.009 rows=0 loops=1)
   (slice0)    Executor memory: 4234K bytes.
   (slice1)    Executor memory: 50K bytes avg x 3 workers, 50K bytes max (seg0).
   (slice2)    Executor memory: 66K bytes (seg0).
 Memory used:  128000kB
 Optimizer: Postgres query optimizer
 Total runtime: 2.081 ms
(16 rows)

:explain select * from d2 a left join r1 b using (c1, c2);
                                                                QUERY PLAN                                                                 
-------------------------------------------------------------------------------------------------------------------------------------------
 Hash Right Join  (cost=1877.50..1268979.50 rows=71100 width=24) (actual time=1.465..1.465 rows=0 loops=2)
   Hash Cond: b.c1 = a.c1 AND b.c2 = a.c2
   Extra Text: Hash chain length 0.0 avg, 0 max, using 0 of 524288 buckets.
   ->  Gather Motion 1:1  (slice1; segments: 1)  (cost=0.00..2233.00 rows=71100 width=16) (never executed)
         ->  Seq Scan on r1 b  (cost=0.00..811.00 rows=23700 width=16) (actual time=0.000..0.018 rows=0 loops=1)
   ->  Hash  (cost=811.00..811.00 rows=23700 width=16) (actual time=0.595..0.595 rows=0 loops=2)
         Buckets: 524288  Batches: 1  Memory Usage: 0kB
         ->  Gather Motion 1:1  (slice2; segments: 1)  (cost=811.00..811.00 rows=71100 width=16) (actual time=0.594..0.594 rows=0 loops=2)
               ->  Seq Scan on d2 a  (cost=0.00..811.00 rows=23700 width=16) (actual time=0.000..0.009 rows=0 loops=1)
   (slice0)    Executor memory: 4234K bytes.
   (slice1)    Executor memory: 50K bytes avg x 3 workers, 50K bytes max (seg0).
   (slice2)    Executor memory: 66K bytes (seg0).
 Memory used:  128000kB
 Optimizer: Postgres query optimizer
 Total runtime: 3.325 ms
(16 rows)

:explain select * from r2 a left join t1 b using (c1);
                                                                      QUERY PLAN                                                                      
------------------------------------------------------------------------------------------------------------------------------------------------------
 Gather Motion 1:1  (slice3; segments: 1)  (cost=3121.75..687985.85 rows=5055210 width=28) (actual time=2.688..2.688 rows=0 loops=2)
   ->  Hash Left Join  (cost=3121.75..687985.85 rows=1685070 width=28) (actual time=0.000..3.979 rows=0 loops=1)
         Hash Cond: a.c1 = b.c1
         ->  Redistribute Motion 2:1  (slice1; segments: 2)  (cost=0.00..2233.00 rows=23700 width=16) (actual time=0.000..1.906 rows=0 loops=1)
               Hash Key: a.c1
               ->  Seq Scan on r2 a  (cost=0.00..811.00 rows=23700 width=16) (actual time=0.000..0.011 rows=0 loops=1)
         ->  Hash  (cost=2233.00..2233.00 rows=23700 width=16) (actual time=0.000..1.287 rows=0 loops=1)
               ->  Redistribute Motion 1:1  (slice2; segments: 1)  (cost=0.00..2233.00 rows=23700 width=16) (actual time=0.000..1.285 rows=0 loops=1)
                     Hash Key: b.c1
                     ->  Seq Scan on t1 b  (cost=0.00..811.00 rows=23700 width=16) (actual time=0.000..0.014 rows=0 loops=1)
   (slice0)    Executor memory: 390K bytes.
   (slice1)    Executor memory: 66K bytes avg x 3 workers, 66K bytes max (seg0).
   (slice2)    Executor memory: 66K bytes avg x 3 workers, 66K bytes max (seg0).
   (slice3)    Executor memory: 4174K bytes avg x 3 workers, 4174K bytes max (seg0).
 Memory used:  128000kB
 Optimizer: Postgres query optimizer
 Total runtime: 6.261 ms
(17 rows)

:explain select * from r2 a left join t1 b using (c1, c2);
                                                                   QUERY PLAN                                                                   
------------------------------------------------------------------------------------------------------------------------------------------------
 Gather Motion 1:1  (slice2; segments: 1)  (cost=1877.50..1268979.50 rows=71100 width=24) (actual time=1.612..1.612 rows=0 loops=2)
   ->  Hash Left Join  (cost=1877.50..1268979.50 rows=23700 width=24) (actual time=0.000..2.797 rows=0 loops=1)
         Hash Cond: a.c1 = b.c1 AND a.c2 = b.c2
         ->  Redistribute Motion 2:1  (slice1; segments: 2)  (cost=0.00..2233.00 rows=23700 width=16) (actual time=0.000..0.923 rows=0 loops=1)
               Hash Key: a.c1, a.c2
               ->  Seq Scan on r2 a  (cost=0.00..811.00 rows=23700 width=16) (actual time=0.000..0.018 rows=0 loops=1)
         ->  Hash  (cost=811.00..811.00 rows=23700 width=16) (actual time=0.000..0.033 rows=0 loops=1)
               ->  Seq Scan on t1 b  (cost=0.00..811.00 rows=23700 width=16) (actual time=0.000..0.031 rows=0 loops=1)
   (slice0)    Executor memory: 386K bytes.
   (slice1)    Executor memory: 66K bytes avg x 3 workers, 66K bytes max (seg0).
   (slice2)    Executor memory: 4182K bytes avg x 3 workers, 4182K bytes max (seg0).
 Memory used:  128000kB
 Optimizer: Postgres query optimizer
 Total runtime: 4.018 ms
(14 rows)

:explain select * from r2 a left join d1 b using (c1);
                                                                QUERY PLAN                                                                 
-------------------------------------------------------------------------------------------------------------------------------------------
 Hash Left Join  (cost=1699.75..686563.85 rows=5055210 width=28) (actual time=1.099..1.099 rows=0 loops=2)
   Hash Cond: a.c1 = b.c1
   Extra Text: Hash chain length 0.0 avg, 0 max, using 0 of 524288 buckets.
   ->  Gather Motion 2:1  (slice1; segments: 2)  (cost=0.00..2233.00 rows=71100 width=16) (actual time=0.198..0.198 rows=0 loops=2)
         ->  Seq Scan on r2 a  (cost=0.00..811.00 rows=23700 width=16) (actual time=0.000..0.014 rows=0 loops=1)
   ->  Hash  (cost=811.00..811.00 rows=23700 width=16) (actual time=0.087..0.087 rows=0 loops=2)
         Buckets: 524288  Batches: 1  Memory Usage: 0kB
         ->  Gather Motion 1:1  (slice2; segments: 1)  (cost=811.00..811.00 rows=71100 width=16) (actual time=0.086..0.086 rows=0 loops=2)
               ->  Seq Scan on d1 b  (cost=0.00..811.00 rows=23700 width=16) (actual time=0.000..0.009 rows=0 loops=1)
   (slice0)    Executor memory: 4238K bytes.
   (slice1)    Executor memory: 50K bytes avg x 3 workers, 50K bytes max (seg0).
   (slice2)    Executor memory: 66K bytes (seg0).
 Memory used:  128000kB
 Optimizer: Postgres query optimizer
 Total runtime: 2.591 ms
(16 rows)

:explain select * from r2 a left join d1 b using (c1, c2);
                                                                QUERY PLAN                                                                 
-------------------------------------------------------------------------------------------------------------------------------------------
 Hash Left Join  (cost=1877.50..1268979.50 rows=71100 width=24) (actual time=1.158..1.158 rows=0 loops=2)
   Hash Cond: a.c1 = b.c1 AND a.c2 = b.c2
   Extra Text: Hash chain length 0.0 avg, 0 max, using 0 of 524288 buckets.
   ->  Gather Motion 2:1  (slice1; segments: 2)  (cost=0.00..2233.00 rows=71100 width=16) (actual time=0.258..0.258 rows=0 loops=2)
         ->  Seq Scan on r2 a  (cost=0.00..811.00 rows=23700 width=16) (actual time=0.000..0.017 rows=0 loops=1)
   ->  Hash  (cost=811.00..811.00 rows=23700 width=16) (actual time=0.138..0.138 rows=0 loops=2)
         Buckets: 524288  Batches: 1  Memory Usage: 0kB
         ->  Gather Motion 1:1  (slice2; segments: 1)  (cost=811.00..811.00 rows=71100 width=16) (actual time=0.137..0.137 rows=0 loops=2)
               ->  Seq Scan on d1 b  (cost=0.00..811.00 rows=23700 width=16) (actual time=0.000..0.013 rows=0 loops=1)
   (slice0)    Executor memory: 4238K bytes.
   (slice1)    Executor memory: 50K bytes avg x 3 workers, 50K bytes max (seg0).
   (slice2)    Executor memory: 66K bytes (seg0).
 Memory used:  128000kB
 Optimizer: Postgres query optimizer
 Total runtime: 2.802 ms
(16 rows)

:explain select * from r2 a left join r1 b using (c1);
                                                                      QUERY PLAN                                                                      
------------------------------------------------------------------------------------------------------------------------------------------------------
 Gather Motion 1:1  (slice3; segments: 1)  (cost=3121.75..687985.85 rows=5055210 width=28) (actual time=1.945..1.945 rows=0 loops=2)
   ->  Hash Left Join  (cost=3121.75..687985.85 rows=1685070 width=28) (actual time=0.000..3.466 rows=0 loops=1)
         Hash Cond: a.c1 = b.c1
         ->  Redistribute Motion 2:1  (slice1; segments: 2)  (cost=0.00..2233.00 rows=23700 width=16) (actual time=0.000..0.003 rows=0 loops=1)
               Hash Key: a.c1
               ->  Seq Scan on r2 a  (cost=0.00..811.00 rows=23700 width=16) (actual time=0.000..0.010 rows=0 loops=1)
         ->  Hash  (cost=2233.00..2233.00 rows=23700 width=16) (actual time=0.000..1.634 rows=0 loops=1)
               ->  Redistribute Motion 1:1  (slice2; segments: 1)  (cost=0.00..2233.00 rows=23700 width=16) (actual time=0.000..1.634 rows=0 loops=1)
                     Hash Key: b.c1
                     ->  Seq Scan on r1 b  (cost=0.00..811.00 rows=23700 width=16) (actual time=0.000..0.010 rows=0 loops=1)
   (slice0)    Executor memory: 390K bytes.
   (slice1)    Executor memory: 66K bytes avg x 3 workers, 66K bytes max (seg0).
   (slice2)    Executor memory: 66K bytes avg x 3 workers, 66K bytes max (seg0).
   (slice3)    Executor memory: 4174K bytes avg x 3 workers, 4174K bytes max (seg0).
 Memory used:  128000kB
 Optimizer: Postgres query optimizer
 Total runtime: 4.749 ms
(17 rows)

:explain select * from r2 a left join r1 b using (c1, c2);
                                                                      QUERY PLAN                                                                      
------------------------------------------------------------------------------------------------------------------------------------------------------
 Gather Motion 1:1  (slice3; segments: 1)  (cost=3299.50..1270401.50 rows=71100 width=24) (actual time=2.230..2.230 rows=0 loops=2)
   ->  Hash Left Join  (cost=3299.50..1270401.50 rows=23700 width=24) (actual time=0.000..3.825 rows=0 loops=1)
         Hash Cond: a.c1 = b.c1 AND a.c2 = b.c2
         ->  Redistribute Motion 2:1  (slice1; segments: 2)  (cost=0.00..2233.00 rows=23700 width=16) (actual time=0.000..1.693 rows=0 loops=1)
               Hash Key: a.c1, a.c2
               ->  Seq Scan on r2 a  (cost=0.00..811.00 rows=23700 width=16) (actual time=0.000..0.009 rows=0 loops=1)
         ->  Hash  (cost=2233.00..2233.00 rows=23700 width=16) (actual time=0.000..0.810 rows=0 loops=1)
               ->  Redistribute Motion 1:1  (slice2; segments: 1)  (cost=0.00..2233.00 rows=23700 width=16) (actual time=0.000..0.808 rows=0 loops=1)
                     Hash Key: b.c1, b.c2
                     ->  Seq Scan on r1 b  (cost=0.00..811.00 rows=23700 width=16) (actual time=0.000..0.073 rows=0 loops=1)
   (slice0)    Executor memory: 390K bytes.
   (slice1)    Executor memory: 66K bytes avg x 3 workers, 66K bytes max (seg0).
   (slice2)    Executor memory: 66K bytes avg x 3 workers, 66K bytes max (seg0).
   (slice3)    Executor memory: 4174K bytes avg x 3 workers, 4174K bytes max (seg0).
 Memory used:  128000kB
 Optimizer: Postgres query optimizer
 Total runtime: 5.359 ms
(17 rows)

-- x2 left join y2
:explain select * from t2 a left join t2 b using (c1);
                                                                      QUERY PLAN                                                                      
------------------------------------------------------------------------------------------------------------------------------------------------------
 Gather Motion 2:1  (slice3; segments: 2)  (cost=3121.75..687985.85 rows=5055210 width=28) (actual time=1.972..1.972 rows=0 loops=2)
   ->  Hash Left Join  (cost=3121.75..687985.85 rows=1685070 width=28) (actual time=0.000..3.288 rows=0 loops=1)
         Hash Cond: a.c1 = b.c1
         ->  Redistribute Motion 2:2  (slice1; segments: 2)  (cost=0.00..2233.00 rows=23700 width=16) (actual time=0.000..0.003 rows=0 loops=1)
               Hash Key: a.c1
               ->  Seq Scan on t2 a  (cost=0.00..811.00 rows=23700 width=16) (actual time=0.000..0.009 rows=0 loops=1)
         ->  Hash  (cost=2233.00..2233.00 rows=23700 width=16) (actual time=0.000..1.506 rows=0 loops=1)
               ->  Redistribute Motion 2:2  (slice2; segments: 2)  (cost=0.00..2233.00 rows=23700 width=16) (actual time=0.000..1.505 rows=0 loops=1)
                     Hash Key: b.c1
                     ->  Seq Scan on t2 b  (cost=0.00..811.00 rows=23700 width=16) (actual time=0.000..0.010 rows=0 loops=1)
   (slice0)    Executor memory: 390K bytes.
   (slice1)    Executor memory: 66K bytes avg x 3 workers, 66K bytes max (seg0).
   (slice2)    Executor memory: 66K bytes avg x 3 workers, 66K bytes max (seg0).
   (slice3)    Executor memory: 4174K bytes avg x 3 workers, 4174K bytes max (seg0).
 Memory used:  128000kB
 Optimizer: Postgres query optimizer
 Total runtime: 4.784 ms
(17 rows)

:explain select * from t2 a left join t2 b using (c1, c2);
                                                             QUERY PLAN                                                             
------------------------------------------------------------------------------------------------------------------------------------
 Gather Motion 2:1  (slice1; segments: 2)  (cost=1877.50..1267557.50 rows=71100 width=24) (actual time=0.167..0.167 rows=0 loops=2)
   ->  Hash Left Join  (cost=1877.50..1267557.50 rows=23700 width=24) (actual time=0.000..0.018 rows=0 loops=1)
         Hash Cond: a.c1 = b.c1 AND a.c2 = b.c2
         ->  Seq Scan on t2 a  (cost=0.00..811.00 rows=23700 width=16) (actual time=0.000..0.017 rows=0 loops=1)
         ->  Hash  (cost=811.00..811.00 rows=23700 width=16) (never executed)
               ->  Seq Scan on t2 b  (cost=0.00..811.00 rows=23700 width=16) (never executed)
   (slice0)    Executor memory: 386K bytes.
   (slice1)    Executor memory: 78K bytes avg x 3 workers, 78K bytes max (seg0).
 Memory used:  128000kB
 Optimizer: Postgres query optimizer
 Total runtime: 0.954 ms
(11 rows)

:explain select * from t2 a left join d2 b using (c1);
                                                             QUERY PLAN                                                              
-------------------------------------------------------------------------------------------------------------------------------------
 Gather Motion 2:1  (slice1; segments: 2)  (cost=1699.75..685141.85 rows=5055210 width=28) (actual time=0.216..0.216 rows=0 loops=2)
   ->  Hash Left Join  (cost=1699.75..685141.85 rows=1685070 width=28) (actual time=0.000..0.017 rows=0 loops=1)
         Hash Cond: a.c1 = b.c1
         ->  Seq Scan on t2 a  (cost=0.00..811.00 rows=23700 width=16) (actual time=0.000..0.016 rows=0 loops=1)
         ->  Hash  (cost=811.00..811.00 rows=23700 width=16) (never executed)
               ->  Seq Scan on d2 b  (cost=0.00..811.00 rows=23700 width=16) (never executed)
   (slice0)    Executor memory: 386K bytes.
   (slice1)    Executor memory: 98K bytes avg x 3 workers, 98K bytes max (seg0).
 Memory used:  128000kB
 Optimizer: Postgres query optimizer
 Total runtime: 1.063 ms
(11 rows)

:explain select * from t2 a left join d2 b using (c1, c2);
                                                             QUERY PLAN                                                             
------------------------------------------------------------------------------------------------------------------------------------
 Gather Motion 2:1  (slice1; segments: 2)  (cost=1877.50..1267557.50 rows=71100 width=24) (actual time=0.196..0.196 rows=0 loops=2)
   ->  Hash Left Join  (cost=1877.50..1267557.50 rows=23700 width=24) (actual time=0.000..0.016 rows=0 loops=1)
         Hash Cond: a.c1 = b.c1 AND a.c2 = b.c2
         ->  Seq Scan on t2 a  (cost=0.00..811.00 rows=23700 width=16) (actual time=0.000..0.016 rows=0 loops=1)
         ->  Hash  (cost=811.00..811.00 rows=23700 width=16) (never executed)
               ->  Seq Scan on d2 b  (cost=0.00..811.00 rows=23700 width=16) (never executed)
   (slice0)    Executor memory: 386K bytes.
   (slice1)    Executor memory: 98K bytes avg x 3 workers, 98K bytes max (seg0).
 Memory used:  128000kB
 Optimizer: Postgres query optimizer
 Total runtime: 0.968 ms
(11 rows)

:explain select * from t2 a left join r2 b using (c1);
                                                                      QUERY PLAN                                                                      
------------------------------------------------------------------------------------------------------------------------------------------------------
 Gather Motion 2:1  (slice3; segments: 2)  (cost=3121.75..687985.85 rows=5055210 width=28) (actual time=2.635..2.635 rows=0 loops=2)
   ->  Hash Left Join  (cost=3121.75..687985.85 rows=1685070 width=28) (actual time=0.000..4.959 rows=0 loops=1)
         Hash Cond: a.c1 = b.c1
         ->  Redistribute Motion 2:2  (slice1; segments: 2)  (cost=0.00..2233.00 rows=23700 width=16) (actual time=0.000..1.997 rows=0 loops=1)
               Hash Key: a.c1
               ->  Seq Scan on t2 a  (cost=0.00..811.00 rows=23700 width=16) (actual time=0.000..0.019 rows=0 loops=1)
         ->  Hash  (cost=2233.00..2233.00 rows=23700 width=16) (actual time=0.000..1.252 rows=0 loops=1)
               ->  Redistribute Motion 2:2  (slice2; segments: 2)  (cost=0.00..2233.00 rows=23700 width=16) (actual time=0.000..1.251 rows=0 loops=1)
                     Hash Key: b.c1
                     ->  Seq Scan on r2 b  (cost=0.00..811.00 rows=23700 width=16) (actual time=0.000..0.013 rows=0 loops=1)
   (slice0)    Executor memory: 390K bytes.
   (slice1)    Executor memory: 66K bytes avg x 3 workers, 66K bytes max (seg0).
   (slice2)    Executor memory: 66K bytes avg x 3 workers, 66K bytes max (seg0).
   (slice3)    Executor memory: 4174K bytes avg x 3 workers, 4174K bytes max (seg0).
 Memory used:  128000kB
 Optimizer: Postgres query optimizer
 Total runtime: 6.142 ms
(17 rows)

:explain select * from t2 a left join r2 b using (c1, c2);
                                                             QUERY PLAN                                                             
------------------------------------------------------------------------------------------------------------------------------------
 Gather Motion 2:1  (slice2; segments: 2)  (cost=1877.50..1268979.50 rows=71100 width=24) (actual time=1.633..1.633 rows=0 loops=2)
   ->  Hash Right Join  (cost=1877.50..1268979.50 rows=23700 width=24) (actual time=0.000..2.559 rows=0 loops=1)
         Hash Cond: b.c1 = a.c1 AND b.c2 = a.c2
         ->  Redistribute Motion 2:2  (slice1; segments: 2)  (cost=0.00..2233.00 rows=23700 width=16) (never executed)
               Hash Key: b.c1, b.c2
               ->  Seq Scan on r2 b  (cost=0.00..811.00 rows=23700 width=16) (actual time=0.000..0.009 rows=0 loops=1)
         ->  Hash  (cost=811.00..811.00 rows=23700 width=16) (actual time=0.000..0.022 rows=0 loops=1)
               ->  Seq Scan on t2 a  (cost=0.00..811.00 rows=23700 width=16) (actual time=0.000..0.020 rows=0 loops=1)
   (slice0)    Executor memory: 386K bytes.
   (slice1)    Executor memory: 66K bytes avg x 3 workers, 66K bytes max (seg0).
   (slice2)    Executor memory: 4182K bytes avg x 3 workers, 4182K bytes max (seg0).
 Memory used:  128000kB
 Optimizer: Postgres query optimizer
 Total runtime: 3.862 ms
(14 rows)

:explain select * from d2 a left join t2 b using (c1);
                                                                QUERY PLAN                                                                 
-------------------------------------------------------------------------------------------------------------------------------------------
 Hash Right Join  (cost=1699.75..686563.85 rows=5055210 width=28) (actual time=1.438..1.438 rows=0 loops=2)
   Hash Cond: b.c1 = a.c1
   Extra Text: Hash chain length 0.0 avg, 0 max, using 0 of 524288 buckets.
   ->  Gather Motion 2:1  (slice1; segments: 2)  (cost=0.00..2233.00 rows=71100 width=16) (never executed)
         ->  Seq Scan on t2 b  (cost=0.00..811.00 rows=23700 width=16) (actual time=0.000..0.018 rows=0 loops=1)
   ->  Hash  (cost=811.00..811.00 rows=23700 width=16) (actual time=0.617..0.617 rows=0 loops=2)
         Buckets: 524288  Batches: 1  Memory Usage: 0kB
         ->  Gather Motion 1:1  (slice2; segments: 1)  (cost=811.00..811.00 rows=71100 width=16) (actual time=0.617..0.617 rows=0 loops=2)
               ->  Seq Scan on d2 a  (cost=0.00..811.00 rows=23700 width=16) (actual time=0.000..0.009 rows=0 loops=1)
   (slice0)    Executor memory: 4234K bytes.
   (slice1)    Executor memory: 50K bytes avg x 3 workers, 50K bytes max (seg0).
   (slice2)    Executor memory: 66K bytes (seg0).
 Memory used:  128000kB
 Optimizer: Postgres query optimizer
 Total runtime: 3.285 ms
(16 rows)

:explain select * from d2 a left join t2 b using (c1, c2);
                                                                QUERY PLAN                                                                 
-------------------------------------------------------------------------------------------------------------------------------------------
 Hash Right Join  (cost=1877.50..1268979.50 rows=71100 width=24) (actual time=1.335..1.335 rows=0 loops=2)
   Hash Cond: b.c1 = a.c1 AND b.c2 = a.c2
   Extra Text: Hash chain length 0.0 avg, 0 max, using 0 of 524288 buckets.
   ->  Gather Motion 2:1  (slice1; segments: 2)  (cost=0.00..2233.00 rows=71100 width=16) (never executed)
         ->  Seq Scan on t2 b  (cost=0.00..811.00 rows=23700 width=16) (actual time=0.000..0.018 rows=0 loops=1)
   ->  Hash  (cost=811.00..811.00 rows=23700 width=16) (actual time=0.561..0.561 rows=0 loops=2)
         Buckets: 524288  Batches: 1  Memory Usage: 0kB
         ->  Gather Motion 1:1  (slice2; segments: 1)  (cost=811.00..811.00 rows=71100 width=16) (actual time=0.560..0.560 rows=0 loops=2)
               ->  Seq Scan on d2 a  (cost=0.00..811.00 rows=23700 width=16) (actual time=0.000..0.009 rows=0 loops=1)
   (slice0)    Executor memory: 4234K bytes.
   (slice1)    Executor memory: 50K bytes avg x 3 workers, 50K bytes max (seg0).
   (slice2)    Executor memory: 66K bytes (seg0).
 Memory used:  128000kB
 Optimizer: Postgres query optimizer
 Total runtime: 3.063 ms
(16 rows)

:explain select * from d2 a left join d2 b using (c1);
                                                             QUERY PLAN                                                              
-------------------------------------------------------------------------------------------------------------------------------------
 Gather Motion 1:1  (slice1; segments: 1)  (cost=1699.75..685141.85 rows=5055210 width=28) (actual time=0.206..0.206 rows=0 loops=2)
   ->  Hash Left Join  (cost=1699.75..685141.85 rows=1685070 width=28) (actual time=0.000..0.017 rows=0 loops=1)
         Hash Cond: a.c1 = b.c1
         ->  Seq Scan on d2 a  (cost=0.00..811.00 rows=23700 width=16) (actual time=0.000..0.016 rows=0 loops=1)
         ->  Hash  (cost=811.00..811.00 rows=23700 width=16) (never executed)
               ->  Seq Scan on d2 b  (cost=0.00..811.00 rows=23700 width=16) (never executed)
   (slice0)    Executor memory: 386K bytes.
   (slice1)    Executor memory: 78K bytes (seg0).
 Memory used:  128000kB
 Optimizer: Postgres query optimizer
 Total runtime: 0.946 ms
(11 rows)

:explain select * from d2 a left join d2 b using (c1, c2);
                                                             QUERY PLAN                                                             
------------------------------------------------------------------------------------------------------------------------------------
 Gather Motion 1:1  (slice1; segments: 1)  (cost=1877.50..1267557.50 rows=71100 width=24) (actual time=0.192..0.192 rows=0 loops=2)
   ->  Hash Left Join  (cost=1877.50..1267557.50 rows=23700 width=24) (actual time=0.000..0.014 rows=0 loops=1)
         Hash Cond: a.c1 = b.c1 AND a.c2 = b.c2
         ->  Seq Scan on d2 a  (cost=0.00..811.00 rows=23700 width=16) (actual time=0.000..0.014 rows=0 loops=1)
         ->  Hash  (cost=811.00..811.00 rows=23700 width=16) (never executed)
               ->  Seq Scan on d2 b  (cost=0.00..811.00 rows=23700 width=16) (never executed)
   (slice0)    Executor memory: 386K bytes.
   (slice1)    Executor memory: 78K bytes (seg0).
 Memory used:  128000kB
 Optimizer: Postgres query optimizer
 Total runtime: 0.883 ms
(11 rows)

:explain select * from d2 a left join r2 b using (c1);
                                                                QUERY PLAN                                                                 
-------------------------------------------------------------------------------------------------------------------------------------------
 Hash Right Join  (cost=1699.75..686563.85 rows=5055210 width=28) (actual time=1.487..1.487 rows=0 loops=2)
   Hash Cond: b.c1 = a.c1
   Extra Text: Hash chain length 0.0 avg, 0 max, using 0 of 524288 buckets.
   ->  Gather Motion 2:1  (slice1; segments: 2)  (cost=0.00..2233.00 rows=71100 width=16) (never executed)
         ->  Seq Scan on r2 b  (cost=0.00..811.00 rows=23700 width=16) (actual time=0.000..0.017 rows=0 loops=1)
   ->  Hash  (cost=811.00..811.00 rows=23700 width=16) (actual time=0.662..0.662 rows=0 loops=2)
         Buckets: 524288  Batches: 1  Memory Usage: 0kB
         ->  Gather Motion 1:1  (slice2; segments: 1)  (cost=811.00..811.00 rows=71100 width=16) (actual time=0.662..0.662 rows=0 loops=2)
               ->  Seq Scan on d2 a  (cost=0.00..811.00 rows=23700 width=16) (actual time=0.000..0.010 rows=0 loops=1)
   (slice0)    Executor memory: 4234K bytes.
   (slice1)    Executor memory: 50K bytes avg x 3 workers, 50K bytes max (seg0).
   (slice2)    Executor memory: 66K bytes (seg0).
 Memory used:  128000kB
 Optimizer: Postgres query optimizer
 Total runtime: 3.353 ms
(16 rows)

:explain select * from d2 a left join r2 b using (c1, c2);
                                                                QUERY PLAN                                                                 
-------------------------------------------------------------------------------------------------------------------------------------------
 Hash Right Join  (cost=1877.50..1268979.50 rows=71100 width=24) (actual time=1.478..1.478 rows=0 loops=2)
   Hash Cond: b.c1 = a.c1 AND b.c2 = a.c2
   Extra Text: Hash chain length 0.0 avg, 0 max, using 0 of 524288 buckets.
   ->  Gather Motion 2:1  (slice1; segments: 2)  (cost=0.00..2233.00 rows=71100 width=16) (never executed)
         ->  Seq Scan on r2 b  (cost=0.00..811.00 rows=23700 width=16) (actual time=0.000..0.018 rows=0 loops=1)
   ->  Hash  (cost=811.00..811.00 rows=23700 width=16) (actual time=0.662..0.662 rows=0 loops=2)
         Buckets: 524288  Batches: 1  Memory Usage: 0kB
         ->  Gather Motion 1:1  (slice2; segments: 1)  (cost=811.00..811.00 rows=71100 width=16) (actual time=0.662..0.662 rows=0 loops=2)
               ->  Seq Scan on d2 a  (cost=0.00..811.00 rows=23700 width=16) (actual time=0.000..0.009 rows=0 loops=1)
   (slice0)    Executor memory: 4234K bytes.
   (slice1)    Executor memory: 50K bytes avg x 3 workers, 50K bytes max (seg0).
   (slice2)    Executor memory: 66K bytes (seg0).
 Memory used:  128000kB
 Optimizer: Postgres query optimizer
 Total runtime: 3.353 ms
(16 rows)

:explain select * from r2 a left join t2 b using (c1);
                                                                      QUERY PLAN                                                                      
------------------------------------------------------------------------------------------------------------------------------------------------------
 Gather Motion 2:1  (slice3; segments: 2)  (cost=3121.75..687985.85 rows=5055210 width=28) (actual time=2.192..2.192 rows=0 loops=2)
   ->  Hash Left Join  (cost=3121.75..687985.85 rows=1685070 width=28) (actual time=0.000..4.022 rows=0 loops=1)
         Hash Cond: a.c1 = b.c1
         ->  Redistribute Motion 2:2  (slice1; segments: 2)  (cost=0.00..2233.00 rows=23700 width=16) (actual time=0.000..0.003 rows=0 loops=1)
               Hash Key: a.c1
               ->  Seq Scan on r2 a  (cost=0.00..811.00 rows=23700 width=16) (actual time=0.000..0.009 rows=0 loops=1)
         ->  Hash  (cost=2233.00..2233.00 rows=23700 width=16) (actual time=0.000..2.100 rows=0 loops=1)
               ->  Redistribute Motion 2:2  (slice2; segments: 2)  (cost=0.00..2233.00 rows=23700 width=16) (actual time=0.000..2.099 rows=0 loops=1)
                     Hash Key: b.c1
                     ->  Seq Scan on t2 b  (cost=0.00..811.00 rows=23700 width=16) (actual time=0.000..0.011 rows=0 loops=1)
   (slice0)    Executor memory: 390K bytes.
   (slice1)    Executor memory: 66K bytes avg x 3 workers, 66K bytes max (seg0).
   (slice2)    Executor memory: 66K bytes avg x 3 workers, 66K bytes max (seg0).
   (slice3)    Executor memory: 4174K bytes avg x 3 workers, 4174K bytes max (seg0).
 Memory used:  128000kB
 Optimizer: Postgres query optimizer
 Total runtime: 5.253 ms
(17 rows)

:explain select * from r2 a left join t2 b using (c1, c2);
                                                                   QUERY PLAN                                                                   
------------------------------------------------------------------------------------------------------------------------------------------------
 Gather Motion 2:1  (slice2; segments: 2)  (cost=1877.50..1268979.50 rows=71100 width=24) (actual time=1.683..1.683 rows=0 loops=2)
   ->  Hash Left Join  (cost=1877.50..1268979.50 rows=23700 width=24) (actual time=0.000..2.974 rows=0 loops=1)
         Hash Cond: a.c1 = b.c1 AND a.c2 = b.c2
         ->  Redistribute Motion 2:2  (slice1; segments: 2)  (cost=0.00..2233.00 rows=23700 width=16) (actual time=0.000..1.021 rows=0 loops=1)
               Hash Key: a.c1, a.c2
               ->  Seq Scan on r2 a  (cost=0.00..811.00 rows=23700 width=16) (actual time=0.000..0.009 rows=0 loops=1)
         ->  Hash  (cost=811.00..811.00 rows=23700 width=16) (actual time=0.000..0.033 rows=0 loops=1)
               ->  Seq Scan on t2 b  (cost=0.00..811.00 rows=23700 width=16) (actual time=0.000..0.032 rows=0 loops=1)
   (slice0)    Executor memory: 386K bytes.
   (slice1)    Executor memory: 66K bytes avg x 3 workers, 66K bytes max (seg0).
   (slice2)    Executor memory: 4182K bytes avg x 3 workers, 4182K bytes max (seg0).
 Memory used:  128000kB
 Optimizer: Postgres query optimizer
 Total runtime: 4.098 ms
(14 rows)

:explain select * from r2 a left join d2 b using (c1);
                                                             QUERY PLAN                                                              
-------------------------------------------------------------------------------------------------------------------------------------
 Gather Motion 2:1  (slice1; segments: 2)  (cost=1699.75..685141.85 rows=5055210 width=28) (actual time=0.237..0.237 rows=0 loops=2)
   ->  Hash Left Join  (cost=1699.75..685141.85 rows=1685070 width=28) (actual time=0.000..0.103 rows=0 loops=1)
         Hash Cond: a.c1 = b.c1
         ->  Seq Scan on r2 a  (cost=0.00..811.00 rows=23700 width=16) (actual time=0.000..0.018 rows=0 loops=1)
         ->  Hash  (cost=811.00..811.00 rows=23700 width=16) (never executed)
               ->  Seq Scan on d2 b  (cost=0.00..811.00 rows=23700 width=16) (never executed)
   (slice0)    Executor memory: 386K bytes.
   (slice1)    Executor memory: 98K bytes avg x 3 workers, 98K bytes max (seg0).
 Memory used:  128000kB
 Optimizer: Postgres query optimizer
 Total runtime: 1.022 ms
(11 rows)

:explain select * from r2 a left join d2 b using (c1, c2);
                                                             QUERY PLAN                                                             
------------------------------------------------------------------------------------------------------------------------------------
 Gather Motion 2:1  (slice1; segments: 2)  (cost=1877.50..1267557.50 rows=71100 width=24) (actual time=0.171..0.171 rows=0 loops=2)
   ->  Hash Left Join  (cost=1877.50..1267557.50 rows=23700 width=24) (actual time=0.000..0.017 rows=0 loops=1)
         Hash Cond: a.c1 = b.c1 AND a.c2 = b.c2
         ->  Seq Scan on r2 a  (cost=0.00..811.00 rows=23700 width=16) (actual time=0.000..0.017 rows=0 loops=1)
         ->  Hash  (cost=811.00..811.00 rows=23700 width=16) (never executed)
               ->  Seq Scan on d2 b  (cost=0.00..811.00 rows=23700 width=16) (never executed)
   (slice0)    Executor memory: 386K bytes.
   (slice1)    Executor memory: 98K bytes avg x 3 workers, 98K bytes max (seg0).
 Memory used:  128000kB
 Optimizer: Postgres query optimizer
 Total runtime: 0.923 ms
(11 rows)

:explain select * from r2 a left join r2 b using (c1);
                                                                      QUERY PLAN                                                                      
------------------------------------------------------------------------------------------------------------------------------------------------------
 Gather Motion 2:1  (slice3; segments: 2)  (cost=3121.75..687985.85 rows=5055210 width=28) (actual time=2.649..2.649 rows=0 loops=2)
   ->  Hash Left Join  (cost=3121.75..687985.85 rows=1685070 width=28) (actual time=0.000..4.693 rows=0 loops=1)
         Hash Cond: a.c1 = b.c1
         ->  Redistribute Motion 2:2  (slice1; segments: 2)  (cost=0.00..2233.00 rows=23700 width=16) (actual time=0.000..0.019 rows=0 loops=1)
               Hash Key: a.c1
               ->  Seq Scan on r2 a  (cost=0.00..811.00 rows=23700 width=16) (actual time=0.000..0.019 rows=0 loops=1)
         ->  Hash  (cost=2233.00..2233.00 rows=23700 width=16) (actual time=0.000..3.142 rows=0 loops=1)
               ->  Redistribute Motion 2:2  (slice2; segments: 2)  (cost=0.00..2233.00 rows=23700 width=16) (actual time=0.000..3.141 rows=0 loops=1)
                     Hash Key: b.c1
                     ->  Seq Scan on r2 b  (cost=0.00..811.00 rows=23700 width=16) (actual time=0.000..0.012 rows=0 loops=1)
   (slice0)    Executor memory: 390K bytes.
   (slice1)    Executor memory: 66K bytes avg x 3 workers, 66K bytes max (seg0).
   (slice2)    Executor memory: 66K bytes avg x 3 workers, 66K bytes max (seg0).
   (slice3)    Executor memory: 4174K bytes avg x 3 workers, 4174K bytes max (seg0).
 Memory used:  128000kB
 Optimizer: Postgres query optimizer
 Total runtime: 6.083 ms
(17 rows)

:explain select * from r2 a left join r2 b using (c1, c2);
                                                                      QUERY PLAN                                                                      
------------------------------------------------------------------------------------------------------------------------------------------------------
 Gather Motion 2:1  (slice3; segments: 2)  (cost=3299.50..1270401.50 rows=71100 width=24) (actual time=2.026..2.026 rows=0 loops=2)
   ->  Hash Left Join  (cost=3299.50..1270401.50 rows=23700 width=24) (actual time=0.000..3.432 rows=0 loops=1)
         Hash Cond: a.c1 = b.c1 AND a.c2 = b.c2
         ->  Redistribute Motion 2:2  (slice1; segments: 2)  (cost=0.00..2233.00 rows=23700 width=16) (actual time=0.000..0.607 rows=0 loops=1)
               Hash Key: a.c1, a.c2
               ->  Seq Scan on r2 a  (cost=0.00..811.00 rows=23700 width=16) (actual time=0.000..0.014 rows=0 loops=1)
         ->  Hash  (cost=2233.00..2233.00 rows=23700 width=16) (actual time=0.000..1.445 rows=0 loops=1)
               ->  Redistribute Motion 2:2  (slice2; segments: 2)  (cost=0.00..2233.00 rows=23700 width=16) (actual time=0.000..1.444 rows=0 loops=1)
                     Hash Key: b.c1, b.c2
                     ->  Seq Scan on r2 b  (cost=0.00..811.00 rows=23700 width=16) (actual time=0.000..0.010 rows=0 loops=1)
   (slice0)    Executor memory: 390K bytes.
   (slice1)    Executor memory: 66K bytes avg x 3 workers, 66K bytes max (seg0).
   (slice2)    Executor memory: 66K bytes avg x 3 workers, 66K bytes max (seg0).
   (slice3)    Executor memory: 4174K bytes avg x 3 workers, 4174K bytes max (seg0).
 Memory used:  128000kB
 Optimizer: Postgres query optimizer
 Total runtime: 4.955 ms
(17 rows)

--
-- insert
--
insert into t1 (c1) values (1), (2), (3), (4), (5), (6)
	returning c1, c2;
 c1 | c2 
----+----
  1 |   
  2 |   
  3 |   
  4 |   
  5 |   
  6 |   
(6 rows)

insert into t2 (c1) values (1), (2), (3), (4), (5), (6)
	returning c1, c2;
 c1 | c2 
----+----
  1 |   
  2 |   
  3 |   
  6 |   
  4 |   
  5 |   
(6 rows)

insert into d1 (c1) values (1), (2), (3), (4), (5), (6)
	returning c1, c2;
 c1 | c2 
----+----
  1 |   
  2 |   
  3 |   
  4 |   
  5 |   
  6 |   
(6 rows)

insert into d2 (c1) values (1), (2), (3), (4), (5), (6)
	returning c1, c2;
 c1 | c2 
----+----
  1 |   
  2 |   
  3 |   
  4 |   
  5 |   
  6 |   
(6 rows)

insert into r1 (c1) values (1), (2), (3), (4), (5), (6)
	returning c1, c2;
 c1 | c2 
----+----
  1 |   
  2 |   
  3 |   
  4 |   
  5 |   
  6 |   
(6 rows)

insert into r2 (c1) values (1), (2), (3), (4), (5), (6)
	returning c1, c2;
 c1 | c2 
----+----
  1 |   
  3 |   
  4 |   
  5 |   
  6 |   
  2 |   
(6 rows)

begin;
insert into t1 (c1) values (1) returning c1, c2;
 c1 | c2 
----+----
  1 |   
(1 row)

insert into d1 (c1) values (1) returning c1, c2;
 c1 | c2 
----+----
  1 |   
(1 row)

insert into r1 (c1) values (1) returning c1, c2;
 c1 | c2 
----+----
  1 |   
(1 row)

insert into t2 (c1) values (1) returning c1, c2;
 c1 | c2 
----+----
  1 |   
(1 row)

insert into d2 (c1) values (1) returning c1, c2;
 c1 | c2 
----+----
  1 |   
(1 row)

insert into r2 (c1) values (1) returning c1, c2;
 c1 | c2 
----+----
  1 |   
(1 row)

rollback;
begin;
insert into t1 (c1) select i from generate_series(1, 20) i
	returning c1, c2;
 c1 | c2 
----+----
  1 |   
  2 |   
  3 |   
  4 |   
  5 |   
  6 |   
  7 |   
  8 |   
  9 |   
 10 |   
 11 |   
 12 |   
 13 |   
 14 |   
 15 |   
 16 |   
 17 |   
 18 |   
 19 |   
 20 |   
(20 rows)

insert into d1 (c1) select i from generate_series(1, 20) i
	returning c1, c2;
 c1 | c2 
----+----
  1 |   
  2 |   
  3 |   
  4 |   
  5 |   
  6 |   
  7 |   
  8 |   
  9 |   
 10 |   
 11 |   
 12 |   
 13 |   
 14 |   
 15 |   
 16 |   
 17 |   
 18 |   
 19 |   
 20 |   
(20 rows)

insert into r1 (c1) select i from generate_series(1, 20) i
	returning c1, c2;
 c1 | c2 
----+----
  1 |   
  2 |   
  3 |   
  4 |   
  5 |   
  6 |   
  7 |   
  8 |   
  9 |   
 10 |   
 11 |   
 12 |   
 13 |   
 14 |   
 15 |   
 16 |   
 17 |   
 18 |   
 19 |   
 20 |   
(20 rows)

insert into t2 (c1) select i from generate_series(1, 20) i
	returning c1, c2;
 c1 | c2 
----+----
  4 |   
  5 |   
 11 |   
 12 |   
 13 |   
 14 |   
 19 |   
  1 |   
  2 |   
  3 |   
  6 |   
  7 |   
  8 |   
  9 |   
 10 |   
 15 |   
 16 |   
 17 |   
 18 |   
 20 |   
(20 rows)

insert into d2 (c1) select i from generate_series(1, 20) i
	returning c1, c2;
 c1 | c2 
----+----
  1 |   
  2 |   
  3 |   
  4 |   
  5 |   
  6 |   
  7 |   
  8 |   
  9 |   
 10 |   
 11 |   
 12 |   
 13 |   
 14 |   
 15 |   
 16 |   
 17 |   
 18 |   
 19 |   
 20 |   
(20 rows)

insert into r2 (c1) select i from generate_series(1, 20) i
	returning c1, c2;
 c1 | c2 
----+----
  4 |   
  6 |   
 14 |   
 15 |   
 16 |   
 18 |   
 19 |   
  1 |   
  2 |   
  3 |   
  5 |   
  7 |   
  8 |   
  9 |   
 10 |   
 11 |   
 12 |   
 13 |   
 17 |   
 20 |   
(20 rows)

rollback;
begin;
insert into t1 (c1, c2) select c1, c2 from t1 returning c1, c2;
 c1 | c2 
----+----
  1 |   
  2 |   
  3 |   
  4 |   
  5 |   
  6 |   
(6 rows)

insert into t1 (c1, c2) select c2, c1 from t1 returning c1, c2;
 c1 | c2 
----+----
    |  1
    |  2
    |  3
    |  4
    |  5
    |  6
    |  1
    |  2
    |  3
    |  4
    |  5
    |  6
(12 rows)

insert into t1 (c1, c2) select c1, c2 from t2 returning c1, c2;
 c1 | c2 
----+----
  4 |   
  5 |   
  1 |   
  2 |   
  3 |   
  6 |   
(6 rows)

insert into t1 (c1, c2) select c2, c1 from t2 returning c1, c2;
 c1 | c2 
----+----
    |  1
    |  2
    |  3
    |  6
    |  4
    |  5
(6 rows)

insert into t1 (c1, c2) select c1, c2 from d1 returning c1, c2;
 c1 | c2 
----+----
  1 |   
  2 |   
  3 |   
  4 |   
  5 |   
  6 |   
(6 rows)

insert into t1 (c1, c2) select c1, c2 from d2 returning c1, c2;
 c1 | c2 
----+----
  1 |   
  2 |   
  3 |   
  4 |   
  5 |   
  6 |   
(6 rows)

insert into t1 (c1, c2) select c1, c2 from r1 returning c1, c2;
 c1 | c2 
----+----
  1 |   
  2 |   
  3 |   
  4 |   
  5 |   
  6 |   
(6 rows)

insert into t1 (c1, c2) select c1, c2 from r2 returning c1, c2;
 c1 | c2 
----+----
  2 |   
  1 |   
  3 |   
  4 |   
  5 |   
  6 |   
(6 rows)

rollback;
begin;
insert into t2 (c1, c2) select c1, c2 from t1 returning c1, c2;
 c1 | c2 
----+----
  1 |   
  2 |   
  3 |   
  6 |   
  4 |   
  5 |   
(6 rows)

insert into t2 (c1, c2) select c2, c1 from t1 returning c1, c2;
 c1 | c2 
----+----
    |  2
    |  4
    |  6
    |  1
    |  3
    |  5
(6 rows)

insert into t2 (c1, c2) select c1, c2 from d1 returning c1, c2;
 c1 | c2 
----+----
  1 |   
  2 |   
  3 |   
  6 |   
  4 |   
  5 |   
(6 rows)

insert into t2 (c1, c2) select c1, c2 from d2 returning c1, c2;
 c1 | c2 
----+----
  1 |   
  2 |   
  3 |   
  6 |   
  4 |   
  5 |   
(6 rows)

insert into t2 (c1, c2) select c1, c2 from r1 returning c1, c2;
 c1 | c2 
----+----
  1 |   
  2 |   
  3 |   
  6 |   
  4 |   
  5 |   
(6 rows)

insert into t2 (c1, c2) select c1, c2 from r2 returning c1, c2;
 c1 | c2 
----+----
  4 |   
  5 |   
  2 |   
  1 |   
  3 |   
  6 |   
(6 rows)

rollback;
begin;
insert into d1 (c1, c2) select c1, c2 from t1 returning c1, c2;
 c1 | c2 
----+----
  1 |   
  2 |   
  3 |   
  4 |   
  5 |   
  6 |   
(6 rows)

insert into d1 (c1, c2) select c2, c1 from t1 returning c1, c2;
 c1 | c2 
----+----
    |  1
    |  2
    |  3
    |  4
    |  5
    |  6
(6 rows)

insert into d1 (c1, c2) select c1, c2 from t2 returning c1, c2;
 c1 | c2 
----+----
  1 |   
  2 |   
  3 |   
  6 |   
  4 |   
  5 |   
(6 rows)

insert into d1 (c1, c2) select c2, c1 from t2 returning c1, c2;
 c1 | c2 
----+----
    |  1
    |  2
    |  3
    |  6
    |  4
    |  5
(6 rows)

insert into d1 (c1, c2) select c1, c2 from d1 returning c1, c2;
 c1 | c2 
----+----
  1 |   
  2 |   
  3 |   
  4 |   
  5 |   
  6 |   
  1 |   
  2 |   
  3 |   
  4 |   
  5 |   
  6 |   
    |  1
    |  2
    |  3
    |  4
    |  5
    |  6
  1 |   
  2 |   
  3 |   
  6 |   
  4 |   
  5 |   
    |  1
    |  2
    |  3
    |  6
    |  4
    |  5
(30 rows)

insert into d1 (c1, c2) select c1, c2 from d2 returning c1, c2;
 c1 | c2 
----+----
  1 |   
  2 |   
  3 |   
  4 |   
  5 |   
  6 |   
(6 rows)

insert into d1 (c1, c2) select c1, c2 from r1 returning c1, c2;
 c1 | c2 
----+----
  1 |   
  2 |   
  3 |   
  4 |   
  5 |   
  6 |   
(6 rows)

insert into d1 (c1, c2) select c1, c2 from r2 returning c1, c2;
 c1 | c2 
----+----
  2 |   
  1 |   
  3 |   
  4 |   
  5 |   
  6 |   
(6 rows)

rollback;
begin;
insert into d2 (c1, c2) select c1, c2 from t1 returning c1, c2;
 c1 | c2 
----+----
  1 |   
  2 |   
  3 |   
  4 |   
  5 |   
  6 |   
(6 rows)

insert into d2 (c1, c2) select c2, c1 from t1 returning c1, c2;
 c1 | c2 
----+----
    |  1
    |  2
    |  3
    |  4
    |  5
    |  6
(6 rows)

insert into d2 (c1, c2) select c1, c2 from d1 returning c1, c2;
 c1 | c2 
----+----
  1 |   
  2 |   
  3 |   
  4 |   
  5 |   
  6 |   
(6 rows)

insert into d2 (c1, c2) select c1, c2 from d2 returning c1, c2;
 c1 | c2 
----+----
  1 |   
  2 |   
  3 |   
  4 |   
  5 |   
  6 |   
  1 |   
  2 |   
  3 |   
  4 |   
  5 |   
  6 |   
    |  1
    |  2
    |  3
    |  4
    |  5
    |  6
  1 |   
  2 |   
  3 |   
  4 |   
  5 |   
  6 |   
(24 rows)

insert into d2 (c1, c2) select c1, c2 from r1 returning c1, c2;
 c1 | c2 
----+----
  1 |   
  2 |   
  3 |   
  4 |   
  5 |   
  6 |   
(6 rows)

insert into d2 (c1, c2) select c1, c2 from r2 returning c1, c2;
 c1 | c2 
----+----
  2 |   
  1 |   
  3 |   
  4 |   
  5 |   
  6 |   
(6 rows)

rollback;
begin;
insert into r1 (c1, c2) select c1, c2 from t1 returning c1, c2;
 c1 | c2 
----+----
  1 |   
  2 |   
  3 |   
  4 |   
  5 |   
  6 |   
(6 rows)

insert into r1 (c1, c2) select c2, c1 from t1 returning c1, c2;
 c1 | c2 
----+----
    |  1
    |  2
    |  3
    |  4
    |  5
    |  6
(6 rows)

insert into r1 (c1, c2) select c1, c2 from t2 returning c1, c2;
 c1 | c2 
----+----
  1 |   
  2 |   
  3 |   
  6 |   
  4 |   
  5 |   
(6 rows)

insert into r1 (c1, c2) select c2, c1 from t2 returning c1, c2;
 c1 | c2 
----+----
    |  1
    |  2
    |  3
    |  6
    |  4
    |  5
(6 rows)

insert into r1 (c1, c2) select c1, c2 from d1 returning c1, c2;
 c1 | c2 
----+----
  1 |   
  2 |   
  3 |   
  4 |   
  5 |   
  6 |   
(6 rows)

insert into r1 (c1, c2) select c1, c2 from d2 returning c1, c2;
 c1 | c2 
----+----
  1 |   
  2 |   
  3 |   
  4 |   
  5 |   
  6 |   
(6 rows)

insert into r1 (c1, c2) select c1, c2 from r1 returning c1, c2;
 c1 | c2 
----+----
  1 |   
  2 |   
  3 |   
  4 |   
  5 |   
  6 |   
  1 |   
  2 |   
  3 |   
  4 |   
  5 |   
  6 |   
    |  1
    |  2
    |  3
    |  4
    |  5
    |  6
  1 |   
  2 |   
  3 |   
  6 |   
  4 |   
  5 |   
    |  1
    |  2
    |  3
    |  6
    |  4
    |  5
  1 |   
  2 |   
  3 |   
  4 |   
  5 |   
  6 |   
  1 |   
  2 |   
  3 |   
  4 |   
  5 |   
  6 |   
(42 rows)

insert into r1 (c1, c2) select c1, c2 from r2 returning c1, c2;
 c1 | c2 
----+----
  2 |   
  1 |   
  3 |   
  4 |   
  5 |   
  6 |   
(6 rows)

rollback;
begin;
insert into r2 (c1, c2) select c1, c2 from t1 returning c1, c2;
 c1 | c2 
----+----
  1 |   
  2 |   
  3 |   
  4 |   
  5 |   
  6 |   
(6 rows)

insert into r2 (c1, c2) select c2, c1 from t1 returning c1, c2;
 c1 | c2 
----+----
    |  1
    |  2
    |  4
    |  5
    |  6
    |  3
(6 rows)

insert into r2 (c1, c2) select c1, c2 from d1 returning c1, c2;
 c1 | c2 
----+----
  4 |   
  5 |   
  1 |   
  2 |   
  3 |   
  6 |   
(6 rows)

insert into r2 (c1, c2) select c1, c2 from d2 returning c1, c2;
 c1 | c2 
----+----
  4 |   
  5 |   
  1 |   
  2 |   
  3 |   
  6 |   
(6 rows)

insert into r2 (c1, c2) select c1, c2 from r1 returning c1, c2;
 c1 | c2 
----+----
  3 |   
  4 |   
  6 |   
  1 |   
  2 |   
  5 |   
(6 rows)

insert into r2 (c1, c2) select c1, c2 from r2 returning c1, c2;
 c1 | c2 
----+----
  2 |   
  1 |   
  6 |   
    |  5
  5 |   
  4 |   
  5 |   
  4 |   
  6 |   
  1 |   
  2 |   
  3 |   
  6 |   
  1 |   
  2 |   
  3 |   
  6 |   
  3 |   
  4 |   
  2 |   
  3 |   
  4 |   
  5 |   
    |  1
    |  2
    |  4
    |  6
  4 |   
  5 |   
  1 |   
  2 |   
  1 |   
  3 |   
  5 |   
    |  3
  6 |   
(36 rows)

rollback;
--
-- pg_relation_size() dispatches an internal query, to fetch the relation's
-- size on each segment. The internal query doesn't need to be part of the
-- distributed transactin. Test that we correctly issue two-phase commit in
-- those segments that are affected by the INSERT, and that we don't try
-- to perform distributed commit on the other segments.
--
insert into r1 (c4) values (pg_relation_size('r2'));
--
-- copy to a partial replicated table from file should work
--
select gp_debug_set_create_table_default_numsegments(2);
 gp_debug_set_create_table_default_numsegments 
-----------------------------------------------
 2
(1 row)

create table partial_rpt_from (c1 int, c2 int) distributed replicated;
select gp_debug_reset_create_table_default_numsegments();
 gp_debug_reset_create_table_default_numsegments 
-------------------------------------------------
 
(1 row)

copy partial_rpt_from (c1, c2) from stdin with delimiter ',';
select * from gp_dist_random('partial_rpt_from');
 c1 | c2 
----+----
  1 |  2
  1 |  2
(2 rows)

--
-- copy from a partial replicated table to file should work
--
select gp_debug_set_create_table_default_numsegments(2);
 gp_debug_set_create_table_default_numsegments 
-----------------------------------------------
 2
(1 row)

create table partial_rpt_to (c1 int, c2 int) distributed replicated;
select gp_debug_reset_create_table_default_numsegments();
 gp_debug_reset_create_table_default_numsegments 
-------------------------------------------------
 
(1 row)

insert into partial_rpt_to values (1,1);
copy partial_rpt_to to stdout;
1	1
-- change a replica to provide data
\c
set search_path=test_partial_table,public;
copy partial_rpt_to to stdout;
1	1
-- change to another replica to provide data
\c
set search_path=test_partial_table,public;
copy partial_rpt_to to stdout;
1	1
-- start_ignore
-- We need to do a cluster expansion which will check if there are partial
-- tables, we need to drop the partial tables to keep the cluster expansion
-- run correctly.
reset search_path;
drop schema test_partial_table cascade;
NOTICE:  drop cascades to 7 other objects
DETAIL:  drop cascades to table test_partial_table.t1
drop cascades to table test_partial_table.d1
drop cascades to table test_partial_table.r1
drop cascades to table test_partial_table.t2
drop cascades to table test_partial_table.d2
drop cascades to table test_partial_table.r2
drop cascades to table test_partial_table.partial_rpt
-- end_ignore
