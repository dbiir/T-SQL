--
-- Testing catalog API functions for indexes over partitioned tables

--
-- ************************************************************
-- * Create the functions to be used for testing 
-- ************************************************************
--
create function gp_build_logical_index(IN rootoid oid,
  OUT logicalIndexOid Oid,
  OUT nColumns smallint,
  OUT indKey text,
  OUT indUnique bool,
  OUT indPred pg_node_tree,
  OUT indExprs pg_node_tree,
  OUT partCons text,
  OUT defaultLevels pg_node_tree,
  OUT indType int2)
returns setof record
language C volatile NO SQL as '@abs_builddir@/regress@DLSUFFIX@', 'gp_build_logical_index_info';

create function gp_get_physical_index_relid(oid, oid, int[], text, text, bool)
returns oid
language C volatile NO SQL AS '@abs_builddir@/regress@DLSUFFIX@', 'gp_get_physical_index_relid';

--
-- ************************************************************
-- * Scenario 1
-- * 	- single level partition.
-- *	- no default parts, no dropped columns
-- ************************************************************
--
create table part_table1
(
  part_key int,
  content  text
)
partition by range(part_key)
(
	partition part1 start ('1') end ('10'),
	partition part2 start('11') end ('20')
);

-- physical index on all parts
-- output show 1 logical index 
create index rp_i1 on part_table1(part_key);

select nColumns, indKey, indUnique, indPred, indExprs, partCons, defaultLevels, indType from gp_build_logical_index('part_table1'::regclass);

-- partial index on all part
-- output shows 1 logical index with partial predicate 
create index parent_partial_ind1 on part_table1(part_key)
where part_key >=1 and part_key < 10;

select indKey, pg_get_expr(indpred, 'part_table1'::regclass), partCons from gp_build_logical_index('part_table1'::regclass)
where indpred is NOT NULL;

-- add a new part - index automatically created 
alter table part_table1 add partition part4 start('31') end ('40');

-- output should still show that 2 logical indexes exists on all parts 
select count(*) from gp_build_logical_index('part_table1'::regclass);

select indKey, pg_get_expr(indpred, 'part_table1'::regclass), partCons from gp_build_logical_index('part_table1'::regclass)
where indpred is NOT NULL;

-- create index on just 1 part
create index rp_i2 on part_table1_1_prt_part4(part_key, content);

-- extra logical index in the output with the constraint of the part_table1_1_prt_part4 constraint.
select count(*) from gp_build_logical_index('part_table1'::regclass);

select indKey, defaultLevels, partCons from gp_build_logical_index('part_table1'::regclass)
where partcons is NOT NULL;

-- split a part into 2 parts - index created on both the parts
-- the existing part4 along with indexes is dropped 
-- and 2 new parts are added - NO new indexes create
alter table part_table1 split partition for ('31') at ('35') into (partition part41, partition part42);

-- back to showing 2 rows - the 2nd index above is gone
select indKey, defaultLevels, partCons from gp_build_logical_index('part_table1'::regclass);

--
-- ************************************************************
-- * Scenario 2
-- * 	- single level partition.
-- *	- testing exchange 
-- ************************************************************
--
create table exchange_tab
(
  part_key int,
  content text
);

-- These indexes must exist on the table before we can exchange, because
-- they exist as a partitioned index on part_table1
create index like_rp_i1 on exchange_tab(part_key);
create index like_parent_partial_ind1 on exchange_tab(part_key)
where part_key >=1 and part_key < 10;

create index e1 on exchange_tab(lower(content));

-- exchanging with part2
-- the 3 indexs on exchange_tab is retained
alter table part_table1 exchange partition for ('11') with table exchange_tab;

-- output of the function shows the index on expression on just the exchanged part.
select indKey, pg_get_expr(indExprs, 'part_table1'::regclass), partCons from gp_build_logical_index('part_table1'::regclass)
where indExprs is NOT NULL;


--
-- ************************************************************
-- * Scenario 3
-- * 	- multi-level partitions 
-- * 	  1st level - 12 parts + 1 default part
-- * 	  2nd level - 3 parts + 1 default part 
-- ************************************************************
--
create table part_table2 (trans_id int, date date, region text)
distributed by (trans_id)
partition by range(date)
subpartition by list(region)
subpartition template
(
 subpartition usa    values ('usa'),
 subpartition asia   values ('asia'),
 subpartition europe values ('europe'),
 default subpartition other_regions)
 (start (date '2008-01-01') end (date '2009-01-01')
 every (interval '1 month'),
 default partition outlying_years);

-- create indexes (will be created on all parts/subparts)
create index first_index on part_table2(trans_id);

-- output will show 1 row returned -- pulled up to root
select indKey, defaultLevels, partCons from gp_build_logical_index('part_table2'::regclass);

-- create a partial index on part_table2 (will be created on all parts/subparts)
create index second_index on part_table2(trans_id)  
where trans_id >=1000 and trans_id < 2000;  

-- output will show 1 index with partial pred
select indKey, pg_get_expr(indPred, 'part_table2'::regclass), defaultLevels, partCons from gp_build_logical_index('part_table2'::regclass)
where indPred is NOT NULL;

-- create index on expression on all parts
create index third_index on part_table2(lower(region));

-- output will show 1 index on expression
select indKey, indPred, pg_get_expr(indExprs, 'part_table2'::regclass), partCons from gp_build_logical_index('part_table2'::regclass)
where indExprs is NOT NULL;

-- create indexes on all leaf parts of a mid-level partition
-- logical index should be pulled up to the mid-level partition.
create index fourth_index1 on part_table2_1_prt_11_2_prt_usa(date); 
create index fourth_index2 on part_table2_1_prt_11_2_prt_asia(date); 
create index fourth_index3 on part_table2_1_prt_11_2_prt_europe(date); 
create index fourth_index4 on part_table2_1_prt_11_2_prt_other_regions(date); 

-- row with following constraint shows up 
--  ((date >= '2008-10-01'::date) AND (date < '2008-11-01'::date))
select indKey, partCons from gp_build_logical_index('part_table2'::regclass)
order by indKey;

-- Create an index on the mid-level -- internal part -- will not show up
-- in the result.  Adding indexes to mid-level/internal root partitions will
-- recurse to their children. Upstream Postgres has CREATE INDEX ONLY, but GPDB
-- does not have this feature yet.  Set SQL_inheritance to false temporarily to
-- force it to be created on the mid-level partition
set SQL_inheritance to false;
create index idummy1 on part_table2_1_prt_9(date); 
set SQL_inheritance to true;
select indKey, defaultLevels, partCons from gp_build_logical_index('part_table2'::regclass)
order by indKey;

-- create an index on a default part
-- result should show this as an extra row
create index fifth_index on part_table2_1_prt_8_2_prt_other_regions(date);

-- following row shows up 
--            | (i 1)         | ((date >= '2008-07-01'::date) AND (date < '2008-08-01'::date))
select indKey, defaultLevels, partCons from gp_build_logical_index('part_table2'::regclass)
order by indKey;

-- create an index on a bunch of default partitions 
create index subset_index1 on part_table2_1_prt_7_2_prt_other_regions(upper(region));
create index subset_index2 on part_table2_1_prt_9_2_prt_other_regions(upper(region));
create index subset_index3 on part_table2_1_prt_11_2_prt_other_regions(upper(region));
select pg_get_expr(indExprs, 'part_table2'::regclass), defaultLevels, partCons from gp_build_logical_index('part_table2'::regclass)
where partcons is NOT NULL
order by partcons;

create index subset_index4 on part_table2_1_prt_7_2_prt_other_regions(upper(region));
create index subset_index5 on part_table2_1_prt_outlying_years_2_prt_other_regions(upper(region));

select pg_get_expr(indExprs, 'part_table2'::regclass), defaultLevels, partCons from gp_build_logical_index('part_table2'::regclass)
where partcons is NOT NULL
order by partcons;

--
-- ************************************************************
-- * Scenario 3
-- * 	- multi-level partitions
-- * 	- truncate partition
-- * 	- dropped columns
-- ************************************************************
--
create table part_table3
(
  date date,
  region text,
  region1 text,
  amount decimal(10,2)
)
partition by range(date)
subpartition by list(region)
(
 partition part1 start(date '2008-01-01') end(date '2009-01-01')
 	(
	subpartition usa    values ('usa'),
 	subpartition asia   values ('asia'),
	default subpartition def
	),
 partition part2 start(date '2009-01-01') end(date '2010-01-01')
 	(
	subpartition usa    values ('usa'),
 	subpartition asia   values ('asia')
	)
);

-- insert some data
insert into part_table3 values ('2008-02-02', 'usa', 'Texas', 10.05), ('2008-03-03', 'asia', 'China', 1.01);
insert into part_table3 values ('2009-02-02', 'usa', 'Texas', 10.05), ('2009-03-03', 'asia', 'China', 1.01);

-- index on atts 1, 4
create index i1 on part_table3(date, amount); 
select indKey, defaultLevels, partCons from gp_build_logical_index('part_table3'::regclass);

-- truncate partitions until table is empty
select * from part_table3;
truncate part_table3_1_prt_part1_2_prt_asia;
select * from part_table3;
alter table part_table3 truncate partition for (rank(1));
select * from part_table3;
alter table part_table3 alter partition part2 truncate partition usa;
select * from part_table3;
alter table part_table3 truncate partition part2;
select * from part_table3;

-- drop column region1
alter table part_table3 drop column region1;  
select indKey, defaultLevels, partCons from gp_build_logical_index('part_table3'::regclass);

-- the index i1 on this part has atts - 1 3
alter table part_table3 add partition part3 start(date '2010-01-01') end (date '2011-01-01')
(subpartition usa values('usa')); 

-- only 1 logical index shows up !!
select indKey, defaultLevels, partCons from gp_build_logical_index('part_table3'::regclass);

-- extra row just on the default part show up
create index i2 on part_table3(region);
select indKey, defaultLevels, partCons from gp_build_logical_index('part_table3'::regclass)
order by nColumns;

-- create an index on ALL subparts of 2 parts (part3 no dropped col)
-- on part3 index is on attnum 3
-- on part1 index is on attnum 4
create index i31 on part_table3_1_prt_part3_2_prt_usa(amount);
create index i32 on part_table3_1_prt_part1_2_prt_usa(amount);
create index i33 on part_table3_1_prt_part1_2_prt_asia(amount);
create index i34 on part_table3_1_prt_part1_2_prt_def(amount);

select indKey, defaultLevels, partCons from gp_build_logical_index('part_table3'::regclass)
order by indKey;

-- dropped cols in the ind expr 
-- index expr varno are different
create index i41 on part_table3_1_prt_part3_2_prt_usa(ceil(amount));
create index i42 on part_table3_1_prt_part2_2_prt_usa(ceil(amount));
create index i43 on part_table3_1_prt_part2_2_prt_asia(ceil(amount));

-- 1 extra index on expression shoule show up with constraints of part3/part2
select pg_get_expr(indExprs, 'part_table3'::regclass), partCons from gp_build_logical_index('part_table3'::regclass)
where indexprs is NOT NULL and partcons is NOT NULL
order by indKey;

-- dropped cols in the ind pred
create index i52 on part_table3_1_prt_part2_2_prt_usa(amount) where amount < 1000;
create index i53 on part_table3_1_prt_part2_2_prt_asia(amount) where amount < 1000;

-- 1 extra row shows up with constraints of part3 and part2
select indPred, pg_get_expr(indExprs, 'part_table3'::regclass), defaultLevels, partCons from gp_build_logical_index('part_table3'::regclass)
where indexprs is NOT NULL and partcons is NOT NULL
order by indKey;

--
-- ************************************************************
-- * Scenario 4
-- * 	- test gp_get_physical_index_relid
-- * 	- test with dropped columns
-- ************************************************************
--
-- create similar index on part3
create index i51 on part_table3_1_prt_part3_2_prt_usa(amount) where amount < 1000;
-- we want the corresponding index in partition part_table3_1_prt_part3_2_prt_usa
-- indexprs have to match
select relname from 
pg_class where 
pg_class.oid = 
(select gp_get_physical_index_relid('part_table3'::regclass, 'part_table3_1_prt_part3_2_prt_usa'::regclass, indkey, indpred, indexprs, indisunique)
from pg_index 
where indexrelid = ('i43'::regclass));

-- should not return anything
select relname from 
pg_class where 
pg_class.oid = 
(select gp_get_physical_index_relid('part_table3'::regclass, 'part_table3_1_prt_part3_2_prt_usa'::regclass, indkey, NULL, indexprs, true)
from pg_index 
where indexrelid = ('i43'::regclass));

-- indpred have to match
select relname from
pg_class where
pg_class.oid =
(select gp_get_physical_index_relid('part_table3'::regclass, 'part_table3_1_prt_part3_2_prt_usa'::regclass, indkey, indpred, indexprs, false)
from pg_index
where indexrelid = 'i52'::regclass);

-- indpreds and indexprs don't match
select relname from
pg_class where
pg_class.oid =
(select gp_get_physical_index_relid('part_table3'::regclass, 'part_table3_1_prt_part2_2_prt_asia'::regclass, indkey, indpred, indexprs, true)
from pg_index
where indexrelid = 'i42'::regclass);

-- ************************************************************
-- * Scenario 5
-- * 	- test gp_get_physical_index_relid
-- * 	- test without dropped columns
-- ************************************************************
create table part_table4
(
 id int,
 rank int,
 year date,
 gender char(1)) DISTRIBUTED BY (id, gender, year)
 partition by list (gender)
  subpartition by range (year)
  subpartition template
  (
    start (date '2001-01-01'),
    start (date '2002-01-01'),
    start (date '2003-01-01'),
    start (date '2004-01-01'),
    start (date '2005-01-01')
)
(
 partition boys values ('M'), 
 partition girls values ('F')
);

-- create an index on all parts
create index id_index on part_table4(id);

-- create 2 indexes on part_table4_1_prt_girls_2_prt_1
create unique index id_index_unique on part_table4_1_prt_girls_2_prt_1(id);

-- create another index on column id
create index id_rank_index on part_table4_1_prt_girls_2_prt_1(id, rank); 

-- given index on part_table4_1_prt_boys_2_prt_3_id_idx, return similar index on part_table4_1_prt_girls_2_prt_1
-- return the non-unique index on column "id" on part "part_table4_1_prt_girls_2_prt_1"
select relname from
pg_class where
pg_class.oid =
(select gp_get_physical_index_relid('part_table4'::regclass, 'part_table4_1_prt_girls_2_prt_1'::regclass, indkey, indpred, indexprs, indisunique)
	from pg_index
	where indexrelid = ('part_table4_1_prt_boys_2_prt_3_id_idx'::regclass));

-- return the unique index on column "id" on part "part_table4_1_prt_girls_2_prt_1"
select relname from
pg_class where 
pg_class.oid =
(select gp_get_physical_index_relid('part_table4'::regclass, 'part_table4_1_prt_girls_2_prt_1'::regclass, indkey, indpred, indexprs, true)
	from pg_index
	where indexrelid = ('part_table4_1_prt_boys_2_prt_3_id_idx'::regclass));

-- ************************************************************
-- * Scenario 6
-- * 	- a part has an existing constraint
-- ************************************************************
create table part_table5
(
  c1 int check (c1 > 0),
  c2 int
)
partition by list(c1)
(
  partition part1 values(1),
  default partition def
);

create index part_table5_i1 on part_table5_1_prt_part1(c1);
create index part_table5_i2 on part_table5(c1) where c1 < 100;
create index part_table5_i3 on part_table5_1_prt_def(abs(c1));

-- returns 1 row with index on part_table5_1_prt_part1
select pg_get_expr(indPred, 'part_table5'::regclass), indExprs, partCons from gp_build_logical_index('part_table5'::regclass)
where defaultLevels is NULL and partcons is NULL;

-- returns 1 row with index on whole table
select pg_get_expr(indPred, 'part_table5'::regclass) from gp_build_logical_index('part_table5'::regclass)
where partCons is NULL;

-- returns 1 row with index on default part
select pg_get_expr(indExprs, 'part_table5'::regclass), defaultLevels from gp_build_logical_index('part_table5'::regclass)
where defaultLevels is NOT NULL;

-- ************************************************************
-- * Scenario 7
-- *    - negative tests
-- ************************************************************
-- regular table
select indKey, defaultLevels, partCons from gp_build_logical_index('pg_class'::regclass);

-- index doesn't exist on attnum 3 in the partition
select gp_get_physical_index_relid('part_table4'::regclass, 'part_table4_1_prt_girls_2_prt_1'::regclass, ('3'::int2vector), indpred, indexprs, true)
	from pg_index
	where indexrelid = ('part_table4_1_prt_boys_2_prt_3_id_idx'::regclass);

-- ************************************************************
-- * Scenario 8
-- *    - open-ended partitions
-- ************************************************************
create table part_table6(a int) 
PARTITION BY RANGE(a)
(
PARTITION p1 END (1) INCLUSIVE,
PARTITION p2 START (1) EXCLUSIVE END (2) INCLUSIVE,
PARTITION p3 START (2) EXCLUSIVE END (3) INCLUSIVE,
PARTITION p4 START (3) EXCLUSIVE END (4) INCLUSIVE
);
create index part_table6_1_ind on part_table6_1_prt_p1(a); 
create index part_table6_2_ind on part_table6_1_prt_p2(a);
create index part_table6_3_ind on part_table6_1_prt_p3(a);

create table part_table7(a int) 
PARTITION BY RANGE(a)
(
PARTITION p2 START (1) EXCLUSIVE END (2) INCLUSIVE,
PARTITION p3 START (2) EXCLUSIVE END (3) INCLUSIVE,
PARTITION p4 START (3) EXCLUSIVE END (4) INCLUSIVE,
PARTITION p5 START (4) EXCLUSIVE
);
create index part_table7_3_ind on part_table7_1_prt_p3(a); 
create index part_table7_4_ind on part_table7_1_prt_p4(a);
create index part_table7_5_ind on part_table7_1_prt_p5(a);

create table part_table8(a int) 
PARTITION BY RANGE(a)
(
PARTITION p1 END (1) INCLUSIVE,
PARTITION p2 START (1) EXCLUSIVE END (2) INCLUSIVE,
PARTITION p3 START (2) EXCLUSIVE END (3) INCLUSIVE,
PARTITION p4 START (3) EXCLUSIVE END (4) INCLUSIVE,
PARTITION p5 START (4) EXCLUSIVE
);
create index part_table8_ind on part_table8(a); 

-- non-contiguous indexes
create table part_table9(a int, b int) 
PARTITION BY RANGE(a)
(
PARTITION p1 END (1) INCLUSIVE,
PARTITION p2 START (1) EXCLUSIVE END (2) INCLUSIVE,
PARTITION p3 START (2) EXCLUSIVE END (3) INCLUSIVE,
PARTITION p4 START (3) EXCLUSIVE END (4) INCLUSIVE,
PARTITION p5 START (4) EXCLUSIVE
);
create index part_table9_1_ind on part_table9_1_prt_p1(a);
create index part_table9_2_ind on part_table9_1_prt_p2(a,b);
create index part_table9_3_ind on part_table9_1_prt_p3(a);

create table part_table10(a int, b int) 
PARTITION BY RANGE(a)
(
PARTITION p1 START (1) EXCLUSIVE END (2) EXCLUSIVE,
PARTITION p2 START (2) EXCLUSIVE END (3) INCLUSIVE,
PARTITION p3 START (3) EXCLUSIVE END (4) INCLUSIVE
);
create index part_table10_1_ind on part_table10_1_prt_p1(a);
create index part_table10_2_ind on part_table10_1_prt_p2(a);

select 'part_table6', partCons, defaultLevels from gp_build_logical_index('part_table6'::regclass);

select 'part_table7', partCons, defaultLevels from gp_build_logical_index('part_table7'::regclass);

select 'part_table8', partCons, defaultLevels from gp_build_logical_index('part_table8'::regclass);

select 'part_table9', partCons, defaultLevels from gp_build_logical_index('part_table9'::regclass);

select 'part_table10', partCons, defaultLevels from gp_build_logical_index('part_table10'::regclass);

-- AO partitioned tables: Orca treats them as bitmap indexes
create table part_table11(a int, b int, c int) with (appendonly=true) partition by list(b) (partition p1 values(1), partition p2 values(2));
create index part_table11_idx on part_table11(c);
select 'part_table11', partCons, defaultLevels from gp_build_logical_index('part_table11'::regclass);

-- mixed heap, AO and AOCO tables: Orca treats them as bitmap indexes
create table part_table12(a int, b int, c int) partition by list(b) 
(partition p1 values(1), 
partition p2 values(2) with (appendonly=true, orientation=column),
partition p3 values(3) with (appendonly=true),
partition p4 values(4)
);
create index part_table12_idx on part_table12(c);
select 'part_table12', partCons, defaultLevels, indType from gp_build_logical_index('part_table12'::regclass);


-- ************************************************************
-- * Scenario 9
-- *    - heterogenous storage and mixture of b-tree and bitmap
-- *      indexes
-- ************************************************************
create table part_table13(a int, b int, c int) 
partition by range(b) 
(
partition p1 start(1) end(10), 
partition p2 start(10) end (20) with (appendonly=true),
partition p3 start(20) end (30) with (appendonly=true,orientation=column),
partition p4 start(30) end (40)
);
   
-- heap/b-tree
create index part_table13_1_idx on part_table13_1_prt_p1 using btree(c); 
-- AO/b-tree: treated as bitmap index
create index part_table13_2_idx on part_table13_1_prt_p2 using btree(c); 
-- AOCO/bitmap
create index part_table13_3_idx on part_table13_1_prt_p3 using bitmap(c); 
-- heap/bitmap
create index part_table13_4_idx on part_table13_1_prt_p4 using bitmap(c); 

select 'part_table13', partCons, defaultLevels, indType from gp_build_logical_index('part_table13'::regclass);

--
-- ************************************************************
-- * Scenario 10
-- * 	- multi-levels partition exchange with external table
-- *
-- ************************************************************
--
create table exchange_sub_partition (a int,b int)
distributed by (a)
partition by range (a)
subpartition by range (b)
subpartition template
(start(1) end(3) every(1))
(start(1) end(3) every(1));

create external web table exchange_external_table(like exchange_sub_partition_1_prt_1_2_prt_1)
execute 'printf "2,2\n1,1\n"' on host
format 'csv';

alter table exchange_sub_partition
alter partition for (integer '2')
exchange partition for (integer '2') with table exchange_external_table without validation;

select * from exchange_sub_partition;

--
-- ************************************************************
-- * Scenario 11
-- *  - Test unnamed index creation on all partitions for a
-- *      single level partitioned table.
-- *  - no default parts, no dropped columns
-- ************************************************************
--
create table unnamed_index_part_table
(
  part_key int,
  index_key int
)
partition by range(part_key)
(
  partition part1 end (3),
  partition part2 start (3)
);

-- physical unnamed index on all parts
-- output shows indexes created on all parts
create index on unnamed_index_part_table(index_key);

SELECT n.nspname as "Schema", c.relname as "Name", c.relkind, c2.relname as "Table"
FROM pg_catalog.pg_class c
     LEFT JOIN pg_catalog.pg_namespace n ON n.oid = c.relnamespace
     LEFT JOIN pg_catalog.pg_index i ON i.indexrelid = c.oid
     LEFT JOIN pg_catalog.pg_class c2 ON i.indrelid = c2.oid
WHERE c.relkind IN ('i','') AND c2.relname like 'unnamed_index_part_table%';

--
-- ************************************************************
-- * Scenario 12
-- * 	- unnamed indexes on multi-level partitions
-- ************************************************************
--
create table unnamed_index_multi_part_table
(
  date date,
  region text,
  region1 text,
  amount decimal(10,2)
)
partition by range(date)
subpartition by list(region)
(
 partition part1 start(date '2008-01-01') end(date '2009-01-01')
	(
	subpartition usa	values ('usa'),
	subpartition asia	values ('asia'),
	default subpartition def
	),
 partition part2 start(date '2009-01-01') end(date '2010-01-01')
	(
	subpartition usa	values ('usa'),
	subpartition asia	values ('asia')
	)
);

-- create unnamed indexe (will be created on all parts/subparts)
create index on unnamed_index_multi_part_table(date, amount);

SELECT n.nspname as "Schema", c.relname as "Name", c.relkind, c2.relname as "Table"
FROM pg_catalog.pg_class c
     LEFT JOIN pg_catalog.pg_namespace n ON n.oid = c.relnamespace
     LEFT JOIN pg_catalog.pg_index i ON i.indexrelid = c.oid
     LEFT JOIN pg_catalog.pg_class c2 ON i.indrelid = c2.oid
WHERE c.relkind IN ('i','') AND c2.relname like 'unnamed_index_multi_part_table%';

-- cleanup
drop function gp_build_logical_index(oid);
drop function gp_get_physical_index_relid(oid, oid, int[], text, text, bool);

drop table exchange_tab;
drop table part_table1;
drop table part_table2;
drop table part_table3;
drop table part_table4;
drop table part_table5;
drop table part_table6;
drop table part_table7;
drop table part_table8;
drop table part_table9;
drop table part_table10;
drop table part_table11;
drop table part_table12;
drop table part_table13;
drop table exchange_sub_partition;
drop table exchange_external_table;
