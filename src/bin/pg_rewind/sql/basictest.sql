#!/bin/bash

# This file has the .sql extension, but it is actually launched as a shell
# script. This contortion is necessary because pg_regress normally uses
# psql to run the input scripts, and requires them to have the .sql
# extension, but we use a custom launcher script that runs the scripts using
# a shell instead.

TESTNAME=basictest

. sql/config_test.sh

# Do an insert in master.
function before_standby
{
PGOPTIONS=${PGOPTIONS_UTILITY} $MASTER_PSQL <<EOF
CREATE TABLE tbl1 (d text);
INSERT INTO tbl1 VALUES ('in master');

CREATE TABLE tbl2 (d text);
CREATE INDEX idx2 ON tbl2(d);
CHECKPOINT;
EOF
}

function standby_following_master
{
# Insert additional data on master that will be replicated to standby
PGOPTIONS=${PGOPTIONS_UTILITY} $MASTER_PSQL -c "INSERT INTO tbl1 values ('in master, before promotion');"

# Launch checkpoint after standby has been started
PGOPTIONS=${PGOPTIONS_UTILITY} $MASTER_PSQL -c "CHECKPOINT;"
}

# This script runs after the standby has been promoted. Old Master is still
# running.
function after_promotion
{
# Insert a row in the old master. This causes the master and standby to have
# "diverged", it's no longer possible to just apply the standy's logs over
# master directory - you need to rewind.
PGOPTIONS=${PGOPTIONS_UTILITY} $MASTER_PSQL -c "INSERT INTO tbl1 VALUES ('in master, after promotion');"

PGOPTIONS=${PGOPTIONS_UTILITY} $MASTER_PSQL -c "INSERT INTO tbl2 VALUES ('in master, after promotion');"

# Also insert a new row in the standby, which won't be present in the old
# master.
PGOPTIONS=${PGOPTIONS_UTILITY} $STANDBY_PSQL -c "INSERT INTO tbl1 VALUES ('in standby, after promotion');"
}

# Compare results generated by querying new master after rewind
function after_rewind
{
PGOPTIONS=${PGOPTIONS_UTILITY} $STANDBY_PSQL -c "SELECT * from tbl1"
PGOPTIONS=${PGOPTIONS_UTILITY} $STANDBY_PSQL -c "SET enable_seqscan=off; SET optimizer_enable_tablescan=off; SELECT * from tbl2 WHERE d LIKE '%something'"
}

# Run the test
. sql/run_test.sh
